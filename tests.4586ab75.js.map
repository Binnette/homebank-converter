{"mappings":"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","sources":["<anon>","node_modules/qunit/qunit/qunit.js","js/tests.js"],"sourcesContent":["import \"./tests.2ba1a519.js\";\n\n\n      var $parcel$global = globalThis;\n    \nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire7da1\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire7da1\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"132Nu\", function(module, exports) {\n/*!\n * QUnit 2.24.3\n * https://qunitjs.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n */ (function() {\n    'use strict';\n    function _arrayLikeToArray(r, a) {\n        (null == a || a > r.length) && (a = r.length);\n        for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n        return n;\n    }\n    function _arrayWithHoles(r) {\n        if (Array.isArray(r)) return r;\n    }\n    function _arrayWithoutHoles(r) {\n        if (Array.isArray(r)) return _arrayLikeToArray(r);\n    }\n    function _classCallCheck(a, n) {\n        if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n    function _defineProperties(e, r) {\n        for(var t = 0; t < r.length; t++){\n            var o = r[t];\n            o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n        }\n    }\n    function _createClass(e, r, t) {\n        return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n            writable: !1\n        }), e;\n    }\n    function _iterableToArray(r) {\n        if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n    }\n    function _iterableToArrayLimit(r, l) {\n        var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n        if (null != t) {\n            var e, n, i, u, a = [], f = !0, o = !1;\n            try {\n                if (i = (t = t.call(r)).next, 0 === l) {\n                    if (Object(t) !== t) return;\n                    f = !1;\n                } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n            } catch (r) {\n                o = !0, n = r;\n            } finally{\n                try {\n                    if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n                } finally{\n                    if (o) throw n;\n                }\n            }\n            return a;\n        }\n    }\n    function _nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    function _nonIterableSpread() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    function _slicedToArray(r, e) {\n        return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n    }\n    function _toConsumableArray(r) {\n        return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n    }\n    function _toPrimitive(t, r) {\n        if (\"object\" != typeof t || !t) return t;\n        var e = t[Symbol.toPrimitive];\n        if (void 0 !== e) {\n            var i = e.call(t, r || \"default\");\n            if (\"object\" != typeof i) return i;\n            throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return (\"string\" === r ? String : Number)(t);\n    }\n    function _toPropertyKey(t) {\n        var i = _toPrimitive(t, \"string\");\n        return \"symbol\" == typeof i ? i : i + \"\";\n    }\n    function _typeof(o) {\n        \"@babel/helpers - typeof\";\n        return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n            return typeof o;\n        } : function(o) {\n            return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n        }, _typeof(o);\n    }\n    function _unsupportedIterableToArray(r, a) {\n        if (r) {\n            if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n            var t = ({}).toString.call(r).slice(8, -1);\n            return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n        }\n    }\n    // We don't use global-this-polyfill [1], because it modifies\n    // the globals scope by default. QUnit must not affect the host context\n    // as developers may test their project may be such a polyfill, and/or\n    // they may intentionally test their project with and without certain\n    // polyfills and we must not affect that. It also uses an obscure\n    // mechanism that seems to sometimes causes a runtime error in older\n    // browsers (specifically Safari and IE versions that support\n    // Object.defineProperty but then report _T_ as undefined).\n    // [1] https://github.com/ungap/global-this/blob/v0.4.4/esm/index.js\n    //\n    // Another way is `Function('return this')()`, but doing so relies\n    // on eval which will cause a CSP error on some servers.\n    //\n    // Instead, simply check the four options that already exist\n    // in all supported environments.\n    function getGlobalThis() {\n        if (typeof globalThis !== 'undefined') // For SpiderMonkey, modern browsers, and recent Node.js\n        // eslint-disable-next-line no-undef\n        return globalThis;\n        if (typeof self !== 'undefined') // For web workers\n        // eslint-disable-next-line no-undef\n        return self;\n        if (typeof window$1 !== 'undefined') // For document context in browsers\n        return window$1;\n        if (typeof $parcel$global !== 'undefined') // For Node.js\n        // eslint-disable-next-line no-undef\n        return $parcel$global;\n        throw new Error('Unable to locate global object');\n    }\n    // This avoids a simple `export const` assignment as that would lead Rollup\n    // to change getGlobalThis and use the same (generated) variable name there.\n    var g = getGlobalThis();\n    // These optional globals are undefined in one or more environments:\n    // modern browser, old browser, Node.js, SpiderMonkey.\n    // Calling code must check these for truthy-ness before use.\n    var console$1 = g.console;\n    var setTimeout$1 = g.setTimeout;\n    var clearTimeout = g.clearTimeout;\n    var process$1 = g.process;\n    var window$1 = g.window;\n    var document = window$1 && window$1.document;\n    var navigator = window$1 && window$1.navigator;\n    var localSessionStorage = function() {\n        var x = 'qunit-test-string';\n        try {\n            g.sessionStorage.setItem(x, x);\n            g.sessionStorage.removeItem(x);\n            return g.sessionStorage;\n        } catch (e) {\n            return undefined;\n        }\n    }();\n    // Basic fallback for ES6 Map\n    // Support: IE 9-10, Safari 7, PhantomJS; Map is undefined\n    // Support: iOS 8; `new Map(iterable)` is not supported\n    //\n    // Fallback for ES7 Map#keys\n    // Support: IE 11; Map#keys is undefined\n    var StringMap = typeof g.Map === 'function' && typeof g.Map.prototype.keys === 'function' && typeof g.Symbol === 'function' && _typeof(g.Symbol.iterator) === 'symbol' ? g.Map : function StringMap(input) {\n        var _this = this;\n        var store = Object.create(null);\n        var hasOwn = Object.prototype.hasOwnProperty;\n        this.has = function(strKey) {\n            return hasOwn.call(store, strKey);\n        };\n        this.get = function(strKey) {\n            return store[strKey];\n        };\n        this.set = function(strKey, val) {\n            if (!hasOwn.call(store, strKey)) this.size++;\n            store[strKey] = val;\n            return this;\n        };\n        this.delete = function(strKey) {\n            if (hasOwn.call(store, strKey)) {\n                delete store[strKey];\n                this.size--;\n            }\n        };\n        this.forEach = function(callback) {\n            for(var strKey in store)callback(store[strKey], strKey);\n        };\n        this.keys = function() {\n            return Object.keys(store);\n        };\n        this.clear = function() {\n            store = Object.create(null);\n            this.size = 0;\n        };\n        this.size = 0;\n        if (input) input.forEach(function(val, strKey) {\n            _this.set(strKey, val);\n        });\n    };\n    // Basic fallback for ES6 Set\n    // Support: IE 11, `new Set(iterable)` parameter not yet implemented\n    // Test for Set#values() which came after Set(iterable).\n    var StringSet = typeof g.Set === 'function' && typeof g.Set.prototype.values === 'function' ? g.Set : function(input) {\n        var set = Object.create(null);\n        if (Array.isArray(input)) input.forEach(function(item) {\n            set[item] = true;\n        });\n        return {\n            add: function add(value) {\n                set[value] = true;\n            },\n            has: function has(value) {\n                return value in set;\n            },\n            get size () {\n                return Object.keys(set).length;\n            }\n        };\n    };\n    var toString = Object.prototype.toString;\n    var hasOwn$1 = Object.prototype.hasOwnProperty;\n    var performance = {\n        // eslint-disable-next-line compat/compat -- Checked\n        now: window$1 && window$1.performance && window$1.performance.now ? window$1.performance.now.bind(window$1.performance) : Date.now\n    };\n    // Returns a new Array with the elements that are in a but not in b\n    function diff$1(a, b) {\n        return a.filter(function(a) {\n            return b.indexOf(a) === -1;\n        });\n    }\n    /**\n   * Determines whether an element exists in a given array or not.\n   *\n   * @method inArray\n   * @param {any} elem\n   * @param {Array} array\n   * @return {boolean}\n   */ var inArray = Array.prototype.includes ? function(elem, array) {\n        return array.includes(elem);\n    } : function(elem, array) {\n        return array.indexOf(elem) !== -1;\n    };\n    /**\n   * Recursively clone an object into a plain array or object, taking only the\n   * own enumerable properties.\n   *\n   * @param {any} obj\n   * @param {bool} [allowArray=true]\n   * @return {Object|Array}\n   */ function objectValues(obj) {\n        var allowArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var vals = allowArray && is('array', obj) ? [] : {};\n        for(var key in obj)if (hasOwn$1.call(obj, key)) {\n            var val = obj[key];\n            vals[key] = val === Object(val) ? objectValues(val, allowArray) : val;\n        }\n        return vals;\n    }\n    /**\n   * Recursively clone an object into a plain object, taking only the\n   * subset of own enumerable properties that exist a given model.\n   *\n   * @param {any} obj\n   * @param {any} model\n   * @return {Object}\n   */ function objectValuesSubset(obj, model) {\n        // Return primitive values unchanged to avoid false positives or confusing\n        // results from assert.propContains().\n        // E.g. an actual null or false wrongly equaling an empty object,\n        // or an actual string being reported as object not matching a partial object.\n        if (obj !== Object(obj)) return obj;\n        // Unlike objectValues(), subset arrays to a plain objects as well.\n        // This enables subsetting [20, 30] with {1: 30}.\n        var subset = {};\n        for(var key in model)if (hasOwn$1.call(model, key) && hasOwn$1.call(obj, key)) subset[key] = objectValuesSubset(obj[key], model[key]);\n        return subset;\n    }\n    function extend(a, b, undefOnly) {\n        for(var prop in b)if (hasOwn$1.call(b, prop)) {\n            if (b[prop] === undefined) delete a[prop];\n            else if (!(undefOnly && typeof a[prop] !== 'undefined')) a[prop] = b[prop];\n        }\n        return a;\n    }\n    function objectType(obj) {\n        if (typeof obj === 'undefined') return 'undefined';\n        // Consider: typeof null === object\n        if (obj === null) return 'null';\n        var match = toString.call(obj).match(/^\\[object\\s(.*)\\]$/);\n        var type = match && match[1];\n        switch(type){\n            case 'Number':\n                if (isNaN(obj)) return 'nan';\n                return 'number';\n            case 'String':\n            case 'Boolean':\n            case 'Array':\n            case 'Set':\n            case 'Map':\n            case 'Date':\n            case 'RegExp':\n            case 'Function':\n            case 'Symbol':\n                return type.toLowerCase();\n            default:\n                return _typeof(obj);\n        }\n    }\n    // Safe object type checking\n    function is(type, obj) {\n        return objectType(obj) === type;\n    }\n    // Based on Java's String.hashCode, a simple but not\n    // rigorously collision resistant hashing function\n    function generateHash(module1, testName) {\n        var str = module1 + '\\x1C' + testName;\n        var hash = 0;\n        for(var i = 0; i < str.length; i++){\n            hash = (hash << 5) - hash + str.charCodeAt(i);\n            hash |= 0;\n        }\n        // Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n        // strictly necessary but increases user understanding that the id is a SHA-like hash\n        var hex = (0x100000000 + hash).toString(16);\n        if (hex.length < 8) hex = '0000000' + hex;\n        return hex.slice(-8);\n    }\n    /**\n   * Converts an error into a simple string for comparisons.\n   *\n   * @param {Error|any} error\n   * @return {string}\n   */ function errorString(error) {\n        // Use String() instead of toString() to handle non-object values like undefined or null.\n        var resultErrorString = String(error);\n        // If the error wasn't a subclass of Error but something like\n        // an object literal with name and message properties...\n        if (resultErrorString.slice(0, 7) === '[object') // Based on https://es5.github.io/#x15.11.4.4\n        return (error.name || 'Error') + (error.message ? \": \".concat(error.message) : '');\n        else return resultErrorString;\n    }\n    function escapeText(str) {\n        if (!str) return '';\n        // Both single quotes and double quotes (for attributes)\n        return ('' + str).replace(/['\"<>&]/g, function(s) {\n            switch(s){\n                case \"'\":\n                    return '&#039;';\n                case '\"':\n                    return '&quot;';\n                case '<':\n                    return '&lt;';\n                case '>':\n                    return '&gt;';\n                case '&':\n                    return '&amp;';\n            }\n        });\n    }\n    var BOXABLE_TYPES = new StringSet([\n        'boolean',\n        'number',\n        'string'\n    ]);\n    // Memory for previously seen containers (object, array, map, set).\n    // Used for recursion detection, and to avoid repeated comparison.\n    //\n    // Elements are { a: val, b: val }.\n    var memory = [];\n    function useStrictEquality(a, b) {\n        return a === b;\n    }\n    function useObjectValueEquality(a, b) {\n        return a === b || a.valueOf() === b.valueOf();\n    }\n    function compareConstructors(a, b) {\n        // Comparing constructors is more strict than using `instanceof`\n        return getConstructor(a) === getConstructor(b);\n    }\n    function getConstructor(obj) {\n        var proto = Object.getPrototypeOf(obj);\n        // If the obj prototype descends from a null constructor, treat it\n        // as a null prototype.\n        // Ref https://github.com/qunitjs/qunit/issues/851\n        //\n        // Allow objects with no prototype, from Object.create(null), to be equivalent to\n        // plain objects that have Object as their constructor.\n        return !proto || proto.constructor === null ? Object : obj.constructor;\n    }\n    function getRegExpFlags(regexp) {\n        return 'flags' in regexp ? regexp.flags : regexp.toString().match(/[gimuy]*$/)[0];\n    }\n    // Specialised comparisons after entryTypeCallbacks.object, based on `objectType()`\n    var objTypeCallbacks = {\n        undefined: useStrictEquality,\n        null: useStrictEquality,\n        // Handle boxed boolean\n        boolean: useObjectValueEquality,\n        number: function number(a, b) {\n            // Handle NaN and boxed number\n            return a === b || a.valueOf() === b.valueOf() || isNaN(a.valueOf()) && isNaN(b.valueOf());\n        },\n        // Handle boxed string\n        string: useObjectValueEquality,\n        symbol: useStrictEquality,\n        date: useObjectValueEquality,\n        nan: function nan() {\n            return true;\n        },\n        regexp: function regexp(a, b) {\n            return a.source === b.source && // Include flags in the comparison\n            getRegExpFlags(a) === getRegExpFlags(b);\n        },\n        // identical reference only\n        function: useStrictEquality,\n        array: function array(a, b) {\n            if (a.length !== b.length) // Safe and faster\n            return false;\n            for(var i = 0; i < a.length; i++){\n                if (!typeEquiv(a[i], b[i])) return false;\n            }\n            return true;\n        },\n        // Define sets a and b to be equivalent if for each element aVal in a, there\n        // is some element bVal in b such that aVal and bVal are equivalent. Element\n        // repetitions are not counted, so these are equivalent:\n        // a = new Set( [ X={}, Y=[], Y ] );\n        // b = new Set( [ Y, X, X ] );\n        set: function set(a, b) {\n            if (a.size !== b.size) // This optimization has certain quirks because of the lack of\n            // repetition counting. For instance, adding the same\n            // (reference-identical) element to two equivalent sets can\n            // make them non-equivalent.\n            return false;\n            var outerEq = true;\n            a.forEach(function(aVal) {\n                // Short-circuit if the result is already known. (Using for...of\n                // with a break clause would be cleaner here, but it would cause\n                // a syntax error on older JavaScript implementations even if\n                // Set is unused)\n                if (!outerEq) return;\n                var innerEq = false;\n                b.forEach(function(bVal) {\n                    // Likewise, short-circuit if the result is already known\n                    if (innerEq) return;\n                    // Swap out the global memory, as nested typeEquiv() would clobber it\n                    var originalMemory = memory;\n                    memory = [];\n                    if (typeEquiv(bVal, aVal)) innerEq = true;\n                    // Restore\n                    memory = originalMemory;\n                });\n                if (!innerEq) outerEq = false;\n            });\n            return outerEq;\n        },\n        // Define maps a and b to be equivalent if for each key-value pair (aKey, aVal)\n        // in a, there is some key-value pair (bKey, bVal) in b such that\n        // [ aKey, aVal ] and [ bKey, bVal ] are equivalent. Key repetitions are not\n        // counted, so these are equivalent:\n        // a = new Map( [ [ {}, 1 ], [ {}, 1 ], [ [], 1 ] ] );\n        // b = new Map( [ [ {}, 1 ], [ [], 1 ], [ [], 1 ] ] );\n        map: function map(a, b) {\n            if (a.size !== b.size) // This optimization has certain quirks because of the lack of\n            // repetition counting. For instance, adding the same\n            // (reference-identical) key-value pair to two equivalent maps\n            // can make them non-equivalent.\n            return false;\n            var outerEq = true;\n            a.forEach(function(aVal, aKey) {\n                // Short-circuit if the result is already known. (Using for...of\n                // with a break clause would be cleaner here, but it would cause\n                // a syntax error on older JavaScript implementations even if\n                // Map is unused)\n                if (!outerEq) return;\n                var innerEq = false;\n                b.forEach(function(bVal, bKey) {\n                    // Likewise, short-circuit if the result is already known\n                    if (innerEq) return;\n                    // Swap out the global memory, as nested typeEquiv() would clobber it\n                    var originalMemory = memory;\n                    memory = [];\n                    if (objTypeCallbacks.array([\n                        bVal,\n                        bKey\n                    ], [\n                        aVal,\n                        aKey\n                    ])) innerEq = true;\n                    // Restore\n                    memory = originalMemory;\n                });\n                if (!innerEq) outerEq = false;\n            });\n            return outerEq;\n        }\n    };\n    // Entry points from typeEquiv, based on `typeof`\n    var entryTypeCallbacks = {\n        undefined: useStrictEquality,\n        null: useStrictEquality,\n        boolean: useStrictEquality,\n        number: function number(a, b) {\n            // Handle NaN\n            return a === b || isNaN(a) && isNaN(b);\n        },\n        string: useStrictEquality,\n        symbol: useStrictEquality,\n        function: useStrictEquality,\n        object: function object(a, b) {\n            // Handle memory (skip recursion)\n            if (memory.some(function(pair) {\n                return pair.a === a && pair.b === b;\n            })) return true;\n            memory.push({\n                a: a,\n                b: b\n            });\n            var aObjType = objectType(a);\n            var bObjType = objectType(b);\n            if (aObjType !== 'object' || bObjType !== 'object') // Handle literal `null`\n            // Handle: Array, Map/Set, Date, Regxp/Function, boxed primitives\n            return aObjType === bObjType && objTypeCallbacks[aObjType](a, b);\n            // NOTE: Literal null must not make it here as it would throw\n            if (compareConstructors(a, b) === false) return false;\n            var aProperties = [];\n            var bProperties = [];\n            // Be strict and go deep, no filtering with hasOwnProperty.\n            for(var i in a){\n                // Collect a's properties\n                aProperties.push(i);\n                // Skip OOP methods that look the same\n                if (a.constructor !== Object && typeof a.constructor !== 'undefined' && typeof a[i] === 'function' && typeof b[i] === 'function' && a[i].toString() === b[i].toString()) continue;\n                if (!typeEquiv(a[i], b[i])) return false;\n            }\n            for(var _i in b)// Collect b's properties\n            bProperties.push(_i);\n            return objTypeCallbacks.array(aProperties.sort(), bProperties.sort());\n        }\n    };\n    function typeEquiv(a, b) {\n        // Optimization: Only perform type-specific comparison when pairs are not strictly equal.\n        if (a === b) return true;\n        var aType = _typeof(a);\n        var bType = _typeof(b);\n        if (aType !== bType) // Support comparing primitive to boxed primitives\n        // Try again after possibly unwrapping one\n        return (aType === 'object' && BOXABLE_TYPES.has(objectType(a)) ? a.valueOf() : a) === (bType === 'object' && BOXABLE_TYPES.has(objectType(b)) ? b.valueOf() : b);\n        return entryTypeCallbacks[aType](a, b);\n    }\n    function innerEquiv(a, b) {\n        var res = typeEquiv(a, b);\n        // Release any retained objects and reset recursion detection for next call\n        memory = [];\n        return res;\n    }\n    /**\n   * Test any two types of JavaScript values for equality.\n   *\n   * @author Philippe Rath <prathe@gmail.com>\n   * @author David Chan <david@troi.org>\n   */ function equiv(a, b) {\n        if (arguments.length === 2) return a === b || innerEquiv(a, b);\n        // Given 0 or 1 arguments, just return true (nothing to compare).\n        // Given (A,B,C,D) compare C,D then B,C then A,B.\n        var i = arguments.length - 1;\n        while(i > 0){\n            if (!innerEquiv(arguments[i - 1], arguments[i])) return false;\n            i--;\n        }\n        return true;\n    }\n    /**\n   * Config object: Maintain internal state\n   * Later exposed as QUnit.config\n   * `config` initialized at top of scope\n   */ var config = {\n        // HTML Reporter: Modify document.title when suite is done\n        altertitle: true,\n        // TODO: Move here from /src/core.js in QUnit 3.\n        // autostart: true,\n        // HTML Reporter: collapse every test except the first failing test\n        // If false, all failing tests will be expanded\n        collapse: true,\n        countStepsAsOne: false,\n        // TODO: Make explicit in QUnit 3.\n        // current: undefined,\n        // whether or not to fail when there are zero tests\n        // defaults to `true`\n        failOnZeroTests: true,\n        // Select by pattern or case-insensitive substring match against \"moduleName: testName\"\n        filter: undefined,\n        // TODO: Make explicit in QUnit 3.\n        // fixture: undefined,\n        // Depth up-to which object will be dumped\n        maxDepth: 5,\n        // Select case-insensitive match of the module name\n        module: undefined,\n        // HTML Reporter: Select module/test by array of internal IDs\n        moduleId: undefined,\n        // By default, run previously failed tests first\n        // very useful in combination with \"Hide passed tests\" checked\n        reorder: true,\n        reporters: {},\n        // When enabled, all tests must call expect()\n        requireExpects: false,\n        // By default, scroll to top of the page when suite is done\n        scrolltop: true,\n        // TODO: Make explicit in QUnit 3.\n        // seed: undefined,\n        // The storage module to use for reordering tests\n        storage: localSessionStorage,\n        testId: undefined,\n        // The updateRate controls how often QUnit will yield the main thread\n        // between tests. This is mainly for the benefit of the HTML Reporter,\n        // so that the browser can visually paint DOM changes with test results.\n        // This also helps avoid causing browsers to prompt a warning about\n        // long-running scripts.\n        // TODO: Move here from /src/core.js in QUnit 3.\n        // updateRate: 1000,\n        // HTML Reporter: List of URL parameters that are given visual controls\n        urlConfig: [],\n        // Internal: The first unnamed module\n        //\n        // By being defined as the intial value for currentModule, it is the\n        // receptacle and implied parent for any global tests. It is as if we\n        // called `QUnit.module( \"\" );` before any other tests were defined.\n        //\n        // If we reach begin() and no tests were put in it, we dequeue it as if it\n        // never existed, and in that case never expose it to the events and\n        // callbacks API.\n        //\n        // When global tests are defined, then this unnamed module will execute\n        // as any other module, including moduleStart/moduleDone events etc.\n        //\n        // Since this module isn't explicitly created by the user, they have no\n        // access to add hooks for it. The hooks object is defined to comply\n        // with internal expectations of test.js, but they will be empty.\n        // To apply hooks, place tests explicitly in a QUnit.module(), and use\n        // its hooks accordingly.\n        //\n        // For global hooks that apply to all tests and all modules, use QUnit.hooks.\n        //\n        // NOTE: This is *not* a \"global module\". It is not an ancestor of all modules\n        // and tests. It is merely the parent for any tests defined globally,\n        // before the first QUnit.module(). As such, the events for this unnamed\n        // module will fire as normal, right after its last test, and *not* at\n        // the end of the test run.\n        //\n        // NOTE: This also should probably also not become a global module, unless\n        // we keep it out of the public API. For example, it would likely not\n        // improve the user interface and plugin behaviour if all modules became\n        // wrapped between the start and end events of this module, and thus\n        // needlessly add indentation, indirection, or other visible noise.\n        // Unit tests for the callbacks API would detect that as a regression.\n        currentModule: {\n            name: '',\n            tests: [],\n            childModules: [],\n            testsRun: 0,\n            testsIgnored: 0,\n            hooks: {\n                before: [],\n                beforeEach: [],\n                afterEach: [],\n                after: []\n            }\n        },\n        // Internal: Exposed to make resets easier\n        // Ref https://github.com/qunitjs/qunit/pull/1598\n        globalHooks: {},\n        // Internal: ProcessingQueue singleton, created in /src/core.js\n        pq: null,\n        // Internal: Created in /src/core.js\n        // TODO: Move definitions here in QUnit 3.0.\n        // started: 0,\n        // Internal state\n        _event_listeners: Object.create(null),\n        _event_memory: {},\n        _deprecated_timeout_shown: false,\n        _deprecated_countEachStep_shown: false,\n        blocking: true,\n        callbacks: {},\n        modules: [],\n        queue: [],\n        stats: {\n            all: 0,\n            bad: 0,\n            testCount: 0\n        }\n    };\n    function readFlatPreconfigBoolean(val, dest) {\n        if (typeof val === 'boolean' || typeof val === 'string' && val !== '') config[dest] = val === true || val === 'true';\n    }\n    function readFlatPreconfigNumber(val, dest) {\n        if (typeof val === 'number' || typeof val === 'string' && /^[0-9]+$/.test(val)) config[dest] = +val;\n    }\n    function readFlatPreconfigString(val, dest) {\n        if (typeof val === 'string' && val !== '') config[dest] = val;\n    }\n    function readFlatPreconfigStringOrBoolean(val, dest) {\n        if (typeof val === 'boolean' || typeof val === 'string' && val !== '') config[dest] = val;\n    }\n    function readFlatPreconfigStringArray(val, dest) {\n        if (typeof val === 'string' && val !== '') config[dest] = [\n            val\n        ];\n    }\n    function readFlatPreconfig(obj) {\n        readFlatPreconfigBoolean(obj.qunit_config_altertitle, 'altertitle');\n        readFlatPreconfigBoolean(obj.qunit_config_autostart, 'autostart');\n        readFlatPreconfigBoolean(obj.qunit_config_collapse, 'collapse');\n        readFlatPreconfigBoolean(obj.qunit_config_failonzerotests, 'failOnZeroTests');\n        readFlatPreconfigString(obj.qunit_config_filter, 'filter');\n        readFlatPreconfigString(obj.qunit_config_fixture, 'fixture');\n        readFlatPreconfigBoolean(obj.qunit_config_hidepassed, 'hidepassed');\n        readFlatPreconfigNumber(obj.qunit_config_maxdepth, 'maxDepth');\n        readFlatPreconfigString(obj.qunit_config_module, 'module');\n        readFlatPreconfigStringArray(obj.qunit_config_moduleid, 'moduleId');\n        readFlatPreconfigBoolean(obj.qunit_config_noglobals, 'noglobals');\n        readFlatPreconfigBoolean(obj.qunit_config_notrycatch, 'notrycatch');\n        readFlatPreconfigBoolean(obj.qunit_config_reorder, 'reorder');\n        readFlatPreconfigBoolean(obj.qunit_config_requireexpects, 'requireExpects');\n        readFlatPreconfigBoolean(obj.qunit_config_scrolltop, 'scrolltop');\n        readFlatPreconfigStringOrBoolean(obj.qunit_config_seed, 'seed');\n        readFlatPreconfigStringArray(obj.qunit_config_testid, 'testId');\n        readFlatPreconfigNumber(obj.qunit_config_testtimeout, 'testTimeout');\n        var reporterKeys = {\n            qunit_config_reporters_console: 'console',\n            qunit_config_reporters_tap: 'tap'\n        };\n        for(var key in reporterKeys){\n            var val = obj[key];\n            // Based on readFlatPreconfigBoolean\n            if (typeof val === 'boolean' || typeof val === 'string' && val !== '') {\n                var dest = reporterKeys[key];\n                config.reporters[dest] = val === true || val === 'true' || val === '1';\n            }\n        }\n    }\n    if (process$1 && 'env' in process$1) readFlatPreconfig(process$1.env);\n    readFlatPreconfig(g);\n    // Apply a predefined QUnit.config object\n    //\n    // Ignore QUnit.config if it is a QUnit distribution instead of preconfig.\n    // That means QUnit was loaded twice! (Use the same approach as export.js)\n    var preConfig = g && g.QUnit && !g.QUnit.version && g.QUnit.config;\n    if (preConfig) extend(config, preConfig);\n    // Push a loose unnamed module to the modules collection\n    config.modules.push(config.currentModule);\n    if (config.seed === 'true' || config.seed === true) // Generate a random seed\n    // Length of `Math.random()` fraction, in base 36, may vary from 6-14.\n    // Pad and take slice to a consistent 10-digit value.\n    config.seed = (Math.random().toString(36) + '0000000000').slice(2, 12);\n    var dump = function() {\n        function quote(str) {\n            return '\"' + str.toString().replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"') + '\"';\n        }\n        function literal(o) {\n            return o + '';\n        }\n        function join(pre, arr, post) {\n            var s = dump.separator();\n            var inner = dump.indent(1);\n            if (arr.join) arr = arr.join(',' + s + inner);\n            if (!arr) return pre + post;\n            var base = dump.indent();\n            return [\n                pre,\n                inner + arr,\n                base + post\n            ].join(s);\n        }\n        function array(arr, stack) {\n            if (dump.maxDepth && dump.depth > dump.maxDepth) return '[object Array]';\n            this.up();\n            var i = arr.length;\n            var ret = new Array(i);\n            while(i--)ret[i] = this.parse(arr[i], undefined, stack);\n            this.down();\n            return join('[', ret, ']');\n        }\n        function isArray(obj) {\n            return(// Native Arrays\n            toString.call(obj) === '[object Array]' || // NodeList objects\n            typeof obj.length === 'number' && obj.item !== undefined && (obj.length ? obj.item(0) === obj[0] : obj.item(0) === null && obj[0] === undefined));\n        }\n        var reName = /^function (\\w+)/;\n        var dump = {\n            // The objType is used mostly internally, you can fix a (custom) type in advance\n            parse: function parse(obj, objType, stack) {\n                stack = stack || [];\n                var objIndex = stack.indexOf(obj);\n                if (objIndex !== -1) return \"recursion(\".concat(objIndex - stack.length, \")\");\n                objType = objType || this.typeOf(obj);\n                var parser = this.parsers[objType];\n                var parserType = _typeof(parser);\n                if (parserType === 'function') {\n                    stack.push(obj);\n                    var res = parser.call(this, obj, stack);\n                    stack.pop();\n                    return res;\n                }\n                if (parserType === 'string') return parser;\n                return '[ERROR: Missing QUnit.dump formatter for type ' + objType + ']';\n            },\n            typeOf: function typeOf(obj) {\n                var type;\n                if (obj === null) type = 'null';\n                else if (typeof obj === 'undefined') type = 'undefined';\n                else if (is('regexp', obj)) type = 'regexp';\n                else if (is('date', obj)) type = 'date';\n                else if (is('function', obj)) type = 'function';\n                else if (obj.setInterval !== undefined && obj.document !== undefined && obj.nodeType === undefined) type = 'window';\n                else if (obj.nodeType === 9) type = 'document';\n                else if (obj.nodeType) type = 'node';\n                else if (isArray(obj)) type = 'array';\n                else if (obj.constructor === Error.prototype.constructor) type = 'error';\n                else type = _typeof(obj);\n                return type;\n            },\n            separator: function separator() {\n                if (this.multiline) return this.HTML ? '<br />' : '\\n';\n                else return this.HTML ? '&#160;' : ' ';\n            },\n            // Extra can be a number, shortcut for increasing-calling-decreasing\n            indent: function indent(extra) {\n                if (!this.multiline) return '';\n                var chr = this.indentChar;\n                if (this.HTML) chr = chr.replace(/\\t/g, '   ').replace(/ /g, '&#160;');\n                return new Array(this.depth + (extra || 0)).join(chr);\n            },\n            up: function up(a) {\n                this.depth += a || 1;\n            },\n            down: function down(a) {\n                this.depth -= a || 1;\n            },\n            setParser: function setParser(name, parser) {\n                this.parsers[name] = parser;\n            },\n            // The next 3 are exposed so you can use them\n            quote: quote,\n            literal: literal,\n            join: join,\n            depth: 1,\n            maxDepth: config.maxDepth,\n            // This is the list of parsers, to modify them, use dump.setParser\n            parsers: {\n                window: '[Window]',\n                document: '[Document]',\n                error: function error(_error) {\n                    return 'Error(\"' + _error.message + '\")';\n                },\n                // This has been unused since QUnit 1.0.0.\n                // @todo Deprecate and remove.\n                unknown: '[Unknown]',\n                null: 'null',\n                undefined: 'undefined',\n                function: function _function(fn) {\n                    var ret = 'function';\n                    // Functions never have name in IE\n                    var name = 'name' in fn ? fn.name : (reName.exec(fn) || [])[1];\n                    if (name) ret += ' ' + name;\n                    ret += '(';\n                    ret = [\n                        ret,\n                        dump.parse(fn, 'functionArgs'),\n                        '){'\n                    ].join('');\n                    return join(ret, dump.parse(fn, 'functionCode'), '}');\n                },\n                array: array,\n                nodelist: array,\n                arguments: array,\n                object: function object(map, stack) {\n                    var ret = [];\n                    if (dump.maxDepth && dump.depth > dump.maxDepth) return '[object Object]';\n                    dump.up();\n                    var keys = [];\n                    for(var key in map)keys.push(key);\n                    // Some properties are not always enumerable on Error objects.\n                    var nonEnumerableProperties = [\n                        'message',\n                        'name'\n                    ];\n                    for(var i in nonEnumerableProperties){\n                        var _key = nonEnumerableProperties[i];\n                        if (_key in map && !inArray(_key, keys)) keys.push(_key);\n                    }\n                    keys.sort();\n                    for(var _i = 0; _i < keys.length; _i++){\n                        var _key2 = keys[_i];\n                        var val = map[_key2];\n                        ret.push(dump.parse(_key2, 'key') + ': ' + dump.parse(val, undefined, stack));\n                    }\n                    dump.down();\n                    return join('{', ret, '}');\n                },\n                node: function node(_node) {\n                    var open = dump.HTML ? '&lt;' : '<';\n                    var close = dump.HTML ? '&gt;' : '>';\n                    var tag = _node.nodeName.toLowerCase();\n                    var ret = open + tag;\n                    var attrs = _node.attributes;\n                    if (attrs) for(var i = 0; i < attrs.length; i++){\n                        var val = attrs[i].nodeValue;\n                        // IE6 includes all attributes in .attributes, even ones not explicitly\n                        // set. Those have values like undefined, null, 0, false, \"\" or\n                        // \"inherit\".\n                        if (val && val !== 'inherit') ret += ' ' + attrs[i].nodeName + '=' + dump.parse(val, 'attribute');\n                    }\n                    ret += close;\n                    // Show content of TextNode or CDATASection\n                    if (_node.nodeType === 3 || _node.nodeType === 4) ret += _node.nodeValue;\n                    return ret + open + '/' + tag + close;\n                },\n                // Function calls it internally, it's the arguments part of the function\n                functionArgs: function functionArgs(fn) {\n                    var l = fn.length;\n                    if (!l) return '';\n                    var args = new Array(l);\n                    while(l--)// 97 is 'a'\n                    args[l] = String.fromCharCode(97 + l);\n                    return ' ' + args.join(', ') + ' ';\n                },\n                // Object calls it internally, the key part of an item in a map\n                key: quote,\n                // Function calls it internally, it's the content of the function\n                functionCode: '[code]',\n                // Node calls it internally, it's a html attribute value\n                attribute: quote,\n                string: quote,\n                date: quote,\n                regexp: literal,\n                number: literal,\n                boolean: literal,\n                symbol: function symbol(sym) {\n                    return sym.toString();\n                }\n            },\n            // If true, entities are escaped ( <, >, \\t, space and \\n )\n            HTML: false,\n            // Indentation unit\n            indentChar: '  ',\n            // If true, items in a collection, are separated by a \\n, else just a space.\n            multiline: true\n        };\n        return dump;\n    }();\n    // Support: IE 9\n    // Detect if the console object exists and no-op otherwise.\n    // This allows support for IE 9, which doesn't have a console\n    // object if the developer tools are not open.\n    // Support: IE 9\n    // Function#bind is supported, but no console.log.bind().\n    // Support: SpiderMonkey (mozjs 68+)\n    // The console object has a log method, but no warn method.\n    var Logger = {\n        warn: console$1 ? Function.prototype.bind.call(console$1.warn || console$1.log, console$1) : function() {}\n    };\n    var SuiteReport = /*#__PURE__*/ function() {\n        function SuiteReport(name, parentSuite) {\n            _classCallCheck(this, SuiteReport);\n            this.name = name;\n            this.fullName = parentSuite ? parentSuite.fullName.concat(name) : [];\n            // When an \"error\" event is emitted from onUncaughtException(), the\n            // \"runEnd\" event should report the status as failed. The \"runEnd\" event data\n            // is tracked through this property (via the \"runSuite\" instance).\n            this.globalFailureCount = 0;\n            this.tests = [];\n            this.childSuites = [];\n            if (parentSuite) parentSuite.pushChildSuite(this);\n        }\n        return _createClass(SuiteReport, [\n            {\n                key: \"start\",\n                value: function start(recordTime) {\n                    if (recordTime) this._startTime = performance.now();\n                    return {\n                        name: this.name,\n                        fullName: this.fullName.slice(),\n                        tests: this.tests.map(function(test) {\n                            return test.start();\n                        }),\n                        childSuites: this.childSuites.map(function(suite) {\n                            return suite.start();\n                        }),\n                        testCounts: {\n                            total: this.getTestCounts().total\n                        }\n                    };\n                }\n            },\n            {\n                key: \"end\",\n                value: function end(recordTime) {\n                    if (recordTime) this._endTime = performance.now();\n                    return {\n                        name: this.name,\n                        fullName: this.fullName.slice(),\n                        tests: this.tests.map(function(test) {\n                            return test.end();\n                        }),\n                        childSuites: this.childSuites.map(function(suite) {\n                            return suite.end();\n                        }),\n                        testCounts: this.getTestCounts(),\n                        runtime: this.getRuntime(),\n                        status: this.getStatus()\n                    };\n                }\n            },\n            {\n                key: \"pushChildSuite\",\n                value: function pushChildSuite(suite) {\n                    this.childSuites.push(suite);\n                }\n            },\n            {\n                key: \"pushTest\",\n                value: function pushTest(test) {\n                    this.tests.push(test);\n                }\n            },\n            {\n                key: \"getRuntime\",\n                value: function getRuntime() {\n                    return Math.round(this._endTime - this._startTime);\n                }\n            },\n            {\n                key: \"getTestCounts\",\n                value: function getTestCounts() {\n                    var counts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n                        passed: 0,\n                        failed: 0,\n                        skipped: 0,\n                        todo: 0,\n                        total: 0\n                    };\n                    counts.failed += this.globalFailureCount;\n                    counts.total += this.globalFailureCount;\n                    counts = this.tests.reduce(function(counts, test) {\n                        if (test.valid) {\n                            counts[test.getStatus()]++;\n                            counts.total++;\n                        }\n                        return counts;\n                    }, counts);\n                    return this.childSuites.reduce(function(counts, suite) {\n                        return suite.getTestCounts(counts);\n                    }, counts);\n                }\n            },\n            {\n                key: \"getStatus\",\n                value: function getStatus() {\n                    var _this$getTestCounts = this.getTestCounts(), total = _this$getTestCounts.total, failed = _this$getTestCounts.failed, skipped = _this$getTestCounts.skipped, todo = _this$getTestCounts.todo;\n                    if (failed) return 'failed';\n                    else {\n                        if (skipped === total) return 'skipped';\n                        else if (todo === total) return 'todo';\n                        else return 'passed';\n                    }\n                }\n            }\n        ]);\n    }();\n    var moduleStack = [];\n    var runSuite = new SuiteReport();\n    function isParentModuleInQueue() {\n        var modulesInQueue = config.modules.filter(function(module1) {\n            return !module1.ignored;\n        }).map(function(module1) {\n            return module1.moduleId;\n        });\n        return moduleStack.some(function(module1) {\n            return modulesInQueue.includes(module1.moduleId);\n        });\n    }\n    function createModule(name, testEnvironment, modifiers) {\n        var parentModule = moduleStack.length ? moduleStack.slice(-1)[0] : null;\n        var moduleName = parentModule !== null ? [\n            parentModule.name,\n            name\n        ].join(' > ') : name;\n        var parentSuite = parentModule ? parentModule.suiteReport : runSuite;\n        var skip = parentModule !== null && parentModule.skip || modifiers.skip;\n        var todo = parentModule !== null && parentModule.todo || modifiers.todo;\n        var env = {};\n        if (parentModule) extend(env, parentModule.testEnvironment);\n        extend(env, testEnvironment);\n        var module1 = {\n            name: moduleName,\n            parentModule: parentModule,\n            hooks: {\n                before: [],\n                beforeEach: [],\n                afterEach: [],\n                after: []\n            },\n            testEnvironment: env,\n            tests: [],\n            moduleId: generateHash(moduleName),\n            testsRun: 0,\n            testsIgnored: 0,\n            childModules: [],\n            suiteReport: new SuiteReport(name, parentSuite),\n            // Initialised by test.js when the module start executing,\n            // i.e. before the first test in this module (or a child).\n            stats: null,\n            // Pass along `skip` and `todo` properties from parent module, in case\n            // there is one, to childs. And use own otherwise.\n            // This property will be used to mark own tests and tests of child suites\n            // as either `skipped` or `todo`.\n            skip: skip,\n            todo: skip ? false : todo,\n            ignored: modifiers.ignored || false\n        };\n        if (parentModule) parentModule.childModules.push(module1);\n        config.modules.push(module1);\n        return module1;\n    }\n    function setHookFromEnvironment(hooks, environment, name) {\n        var potentialHook = environment[name];\n        if (typeof potentialHook === 'function') hooks[name].push(potentialHook);\n        delete environment[name];\n    }\n    function makeSetHook(module1, hookName) {\n        return function setHook(callback) {\n            if (config.currentModule !== module1) Logger.warn('The `' + hookName + '` hook was called inside the wrong module (`' + config.currentModule.name + '`). ' + 'Instead, use hooks provided by the callback to the containing module (`' + module1.name + '`). ' + 'This will become an error in QUnit 3.0.');\n            module1.hooks[hookName].push(callback);\n        };\n    }\n    function processModule(name, options, scope) {\n        var modifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        if (typeof options === 'function') {\n            scope = options;\n            options = undefined;\n        }\n        var module1 = createModule(name, options, modifiers);\n        // Transfer any initial hooks from the options object to the 'hooks' object\n        var testEnvironment = module1.testEnvironment;\n        var hooks = module1.hooks;\n        setHookFromEnvironment(hooks, testEnvironment, 'before');\n        setHookFromEnvironment(hooks, testEnvironment, 'beforeEach');\n        setHookFromEnvironment(hooks, testEnvironment, 'afterEach');\n        setHookFromEnvironment(hooks, testEnvironment, 'after');\n        var moduleFns = {\n            before: makeSetHook(module1, 'before'),\n            beforeEach: makeSetHook(module1, 'beforeEach'),\n            afterEach: makeSetHook(module1, 'afterEach'),\n            after: makeSetHook(module1, 'after')\n        };\n        var prevModule = config.currentModule;\n        config.currentModule = module1;\n        if (typeof scope === 'function') {\n            moduleStack.push(module1);\n            try {\n                var cbReturnValue = scope.call(module1.testEnvironment, moduleFns);\n                if (cbReturnValue && typeof cbReturnValue.then === 'function') Logger.warn(\"Returning a promise from a module callback is not supported. Instead, use hooks for async behavior. This will become an error in QUnit 3.0.\");\n            } finally{\n                // If the module closure threw an uncaught error during the load phase,\n                // we let this bubble up to global error handlers. But, not until after\n                // we teardown internal state to ensure correct module nesting.\n                // Ref https://github.com/qunitjs/qunit/issues/1478.\n                moduleStack.pop();\n                config.currentModule = module1.parentModule || prevModule;\n            }\n        }\n    }\n    /**\n   * Clear the SuiteReport tree of all tests and leave only current module as child suite\n   *\n   * This should be called before defining the first module.only() or test.only()\n   * because otherwise:\n   * - `runEnd.testCounts` is too high.\n   * - UI (HtmlReporter) and TAP (TapReporter) display totals too high.\n   * - Test runners like QTap might timeout because the TAP plan\n   *   would be printed as \"1..9\" even if only 2 tests are run,\n   *   which means tap-finished will wait for 3-9.\n   */ function clearSuiteReports(currentModule) {\n        var childSuite = null;\n        var suiteReport = currentModule.suiteReport;\n        while(suiteReport){\n            suiteReport.tests.length = 0;\n            var i = suiteReport.childSuites.indexOf(childSuite);\n            if (i === -1) suiteReport.childSuites.length = 0;\n            else {\n                // Reduce in-place to just currentModule.suiteReport or its intermediary\n                suiteReport.childSuites.splice(0, i);\n                suiteReport.childSuites.splice(1);\n            }\n            if (suiteReport === runSuite) suiteReport = null;\n            else {\n                childSuite = suiteReport;\n                currentModule = currentModule.parentModule;\n                suiteReport = currentModule && currentModule.suiteReport || runSuite;\n            }\n        }\n    }\n    var focused$1 = false; // indicates that the \"only\" filter was used\n    function module$1(name, options, scope) {\n        var ignored = focused$1 && !isParentModuleInQueue();\n        processModule(name, options, scope, {\n            ignored: ignored\n        });\n    }\n    module$1.only = function() {\n        if (!focused$1) {\n            // Upon the first module.only() call,\n            // delete any and all previously registered modules and tests.\n            config.modules.length = 0;\n            config.queue.length = 0;\n            clearSuiteReports(config.currentModule);\n            // Ignore any tests declared after this block within the same\n            // module parent. https://github.com/qunitjs/qunit/issues/1645\n            config.currentModule.ignored = true;\n        }\n        focused$1 = true;\n        processModule.apply(void 0, arguments);\n    };\n    module$1.skip = function(name, options, scope) {\n        if (focused$1) return;\n        processModule(name, options, scope, {\n            skip: true\n        });\n    };\n    module$1.if = function(name, condition, options, scope) {\n        if (focused$1) return;\n        processModule(name, options, scope, {\n            skip: !condition\n        });\n    };\n    module$1.todo = function(name, options, scope) {\n        if (focused$1) return;\n        processModule(name, options, scope, {\n            todo: true\n        });\n    };\n    // Stacktrace cleaner to focus on the path from error source to test suite.\n    //\n    // This should reduce a raw stack trace like this:\n    //\n    // > foo.broken()@/example/foo.js\n    // > Bar@/example/bar.js\n    // > @/test/bar.test.js\n    // > @/lib/qunit.js:500:12\n    // > @/lib/qunit.js:100:28\n    // > @/lib/qunit.js:200:56\n    // > setTimeout@\n    // > @/dist/vendor.js\n    //\n    // and shorten it to show up until the end of the user's bar.test.js code.\n    //\n    // > foo.broken()@/example/foo.js\n    // > Bar@/example/bar.js\n    // > @/test/bar.test.js\n    //\n    // QUnit will obtain one example trace (once per process/pageload suffices),\n    // strip off any :<line> and :<line>:<column>, and use that as match needle,\n    // to the first QUnit-internal frames, and then stop at that point.\n    // Any later frames, including those that are outside QUnit again, will be ommitted\n    // as being uninteresting to the test, since QUnit will have either started or\n    // resumed the test. This we also clean away browser built-ins, or other\n    // vendor/bundler that may be higher up the stack.\n    //\n    // Stripping :<line>:<column> is not for prettyness, it is essential for the\n    // match needle to work, since this sample trace will by definitin not be the\n    // same line as e.g. the QUnit.test() call we're trying to identify.\n    //\n    // See also:\n    // - https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\n    function qunitFileName() {\n        var error = new Error();\n        if (!error.stack) // Copy of sourceFromStacktrace() to avoid circular dependency\n        // Support: IE 9-11\n        try {\n            throw error;\n        } catch (err) {\n            error = err;\n        }\n        return (error.stack || '').replace(/^error$\\n/im, '').split('\\n')[0]// Global replace, because a frame like localhost:4000/lib/qunit.js:1234:50,\n        // would otherwise (harmlessly, but uselessly) remove only the port (first match).\n        // https://github.com/qunitjs/qunit/issues/1769\n        .replace(/(:\\d+)+\\)?/g, '')// Remove anything prior to the last slash (Unix/Windows) from the last frame,\n        // leaving only \"qunit.js\".\n        .replace(/.+[/\\\\]/, '');\n    }\n    var fileName = qunitFileName();\n    /**\n   * Responsibilities:\n   * - For internal errors from QUnit itself, remove the first qunit.js frames.\n   * - For errors in Node.js, format any remaining qunit.js and node:internal\n   *   frames as internal (i.e. grey out).\n   *\n   * @param {string} stack Error#stack\n   * @param {Function} formatInternal Format a string in an \"internal\" color\n   * @param {string|null} [eToString] Error#toString() to help remove\n   *  noise from Node.js/V8 stack traces.\n   */ function annotateStacktrace(stack, formatInternal) {\n        var eToString = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        var frames = stack.split('\\n');\n        var annotated = [];\n        if (eToString && eToString.indexOf(frames[0]) !== -1) // In Firefox and Safari e.stack starts with frame 0, but in V8 (Chrome/Node.js),\n        // e.stack starts first stringified message. Preserve this separately,\n        // so that, below, we can distinguish between internal frames on top\n        // (to remove) vs later internal frames (to format differently).\n        annotated.push(frames.shift());\n        var initialInternal = true;\n        for(var i = 0; i < frames.length; i++){\n            var frame = frames[i];\n            var isInternal = fileName && frame.indexOf(fileName) !== -1 || // Support Node 16+: ESM-style\n            // \"at wrap (node:internal/modules/cjs/loader:1)\"\n            frame.indexOf('node:internal/') !== -1 || // Support Node 12-14 (CJS-style)\n            // \"at load (internal/modules/cjs/loader.js:7)\"\n            frame.match(/^\\s+at .+\\(internal[^)]*\\)$/) || // Support Node 10\n            // \"at listOnTimeout (timers.js:263)\"\n            // Avoid matching \"(C:)\" on Windows\n            // Avoid matching \"(http:)\"\n            frame.match(/^\\s+at .+\\([a-z]+\\.js[:\\d]*\\)$/);\n            if (!isInternal) initialInternal = false;\n            // Remove initial internal frames entirely.\n            if (!initialInternal) annotated.push(isInternal ? formatInternal(frame) : frame);\n        }\n        return annotated.join('\\n');\n    }\n    function extractStacktrace(e, offset) {\n        offset = offset === undefined ? 4 : offset;\n        // Support: IE9, e.stack is not supported, we will return undefined\n        if (e && e.stack) {\n            var stack = e.stack.split('\\n');\n            // In Firefox and Safari, e.stack starts immediately with the first frame.\n            //\n            // In V8 (Chrome/Node.js), the stack starts first with a stringified error message,\n            // and the real stack starting on line 2.\n            if (/^error$/i.test(stack[0])) stack.shift();\n            if (fileName) {\n                var include = [];\n                for(var i = offset; i < stack.length; i++){\n                    if (stack[i].indexOf(fileName) !== -1) break;\n                    include.push(stack[i]);\n                }\n                if (include.length) return include.join('\\n');\n            }\n            return stack[offset];\n        }\n    }\n    function sourceFromStacktrace(offset) {\n        var error = new Error();\n        // Support: IE 9-11, iOS 7\n        // Not all browsers generate the `stack` property for `new Error()`\n        // See also https://github.com/qunitjs/qunit/issues/636\n        if (!error.stack) try {\n            throw error;\n        } catch (err) {\n            error = err;\n        }\n        return extractStacktrace(error, offset);\n    }\n    var Assert = /*#__PURE__*/ function() {\n        function Assert(testContext) {\n            _classCallCheck(this, Assert);\n            this.test = testContext;\n        }\n        return _createClass(Assert, [\n            {\n                key: \"timeout\",\n                value: function timeout(duration) {\n                    if (typeof duration !== 'number') throw new Error('You must pass a number as the duration to assert.timeout');\n                    this.test.timeout = duration;\n                    // If a timeout has been set, clear it and reset with the new duration\n                    if (config.timeout) {\n                        clearTimeout(config.timeout);\n                        config.timeout = null;\n                        if (config.timeoutHandler && this.test.timeout > 0) this.test.internalResetTimeout(this.test.timeout);\n                    }\n                }\n            },\n            {\n                key: \"step\",\n                value: function step(message) {\n                    var assertionMessage = message;\n                    var result = !!message;\n                    this.test.steps.push(message);\n                    if (typeof message === 'undefined' || message === '') assertionMessage = 'You must provide a message to assert.step';\n                    else if (typeof message !== 'string') {\n                        assertionMessage = 'You must provide a string value to assert.step';\n                        result = false;\n                    }\n                    this.pushResult({\n                        result: result,\n                        message: assertionMessage\n                    });\n                }\n            },\n            {\n                key: \"verifySteps\",\n                value: function verifySteps(steps, message) {\n                    // Since the steps array is just string values, we can clone with slice\n                    var actualStepsClone = this.test.steps.slice();\n                    this.deepEqual(actualStepsClone, steps, message);\n                    this.test.stepsCount += this.test.steps.length;\n                    this.test.steps.length = 0;\n                }\n            },\n            {\n                key: \"expect\",\n                value: function expect(asserts) {\n                    if (arguments.length === 1) this.test.expected = asserts;\n                    else return this.test.expected;\n                }\n            },\n            {\n                key: \"async\",\n                value: function async(count) {\n                    if (count === undefined) count = 1;\n                    else if (typeof count !== 'number') throw new TypeError('async takes number as an input');\n                    var requiredCalls = count;\n                    return this.test.internalStop(requiredCalls);\n                }\n            },\n            {\n                key: \"closeTo\",\n                value: function closeTo(actual, expected, delta, message) {\n                    if (typeof delta !== 'number') throw new TypeError('closeTo() requires a delta argument');\n                    this.pushResult({\n                        result: Math.abs(actual - expected) <= delta,\n                        actual: actual,\n                        expected: expected,\n                        message: message || \"value should be within \".concat(delta, \" inclusive\")\n                    });\n                }\n            },\n            {\n                key: \"push\",\n                value: function push(result, actual, expected, message, negative) {\n                    var currentAssert = this instanceof Assert ? this : config.current.assert;\n                    return currentAssert.pushResult({\n                        result: result,\n                        actual: actual,\n                        expected: expected,\n                        message: message,\n                        negative: negative\n                    });\n                }\n            },\n            {\n                key: \"pushResult\",\n                value: function pushResult(resultInfo) {\n                    // Destructure of resultInfo = { result, actual, expected, message, negative }\n                    var assert = this;\n                    var currentTest = assert instanceof Assert && assert.test || config.current;\n                    // Backwards compatibility fix.\n                    // Allows the direct use of global exported assertions and QUnit.assert.*\n                    // Although, it's use is not recommended as it can leak assertions\n                    // to other tests from async tests, because we only get a reference to the current test,\n                    // not exactly the test where assertion were intended to be called.\n                    if (!currentTest) throw new Error('assertion outside test context, in ' + sourceFromStacktrace(2));\n                    if (!(assert instanceof Assert)) assert = currentTest.assert;\n                    return assert.test.pushResult(resultInfo);\n                }\n            },\n            {\n                key: \"ok\",\n                value: function ok(result, message) {\n                    if (!message) message = result ? 'okay' : \"failed, expected argument to be truthy, was: \".concat(dump.parse(result));\n                    this.pushResult({\n                        result: !!result,\n                        actual: result,\n                        expected: true,\n                        message: message\n                    });\n                }\n            },\n            {\n                key: \"notOk\",\n                value: function notOk(result, message) {\n                    if (!message) message = !result ? 'okay' : \"failed, expected argument to be falsy, was: \".concat(dump.parse(result));\n                    this.pushResult({\n                        result: !result,\n                        actual: result,\n                        expected: false,\n                        message: message\n                    });\n                }\n            },\n            {\n                key: \"true\",\n                value: function _true(result, message) {\n                    this.pushResult({\n                        result: result === true,\n                        actual: result,\n                        expected: true,\n                        message: message\n                    });\n                }\n            },\n            {\n                key: \"false\",\n                value: function _false(result, message) {\n                    this.pushResult({\n                        result: result === false,\n                        actual: result,\n                        expected: false,\n                        message: message\n                    });\n                }\n            },\n            {\n                key: \"equal\",\n                value: function equal(actual, expected, message) {\n                    this.pushResult({\n                        // eslint-disable-next-line eqeqeq\n                        result: expected == actual,\n                        actual: actual,\n                        expected: expected,\n                        message: message\n                    });\n                }\n            },\n            {\n                key: \"notEqual\",\n                value: function notEqual(actual, expected, message) {\n                    this.pushResult({\n                        // eslint-disable-next-line eqeqeq\n                        result: expected != actual,\n                        actual: actual,\n                        expected: expected,\n                        message: message,\n                        negative: true\n                    });\n                }\n            },\n            {\n                key: \"propEqual\",\n                value: function propEqual(actual, expected, message) {\n                    actual = objectValues(actual);\n                    expected = objectValues(expected);\n                    this.pushResult({\n                        result: equiv(actual, expected),\n                        actual: actual,\n                        expected: expected,\n                        message: message\n                    });\n                }\n            },\n            {\n                key: \"notPropEqual\",\n                value: function notPropEqual(actual, expected, message) {\n                    actual = objectValues(actual);\n                    expected = objectValues(expected);\n                    this.pushResult({\n                        result: !equiv(actual, expected),\n                        actual: actual,\n                        expected: expected,\n                        message: message,\n                        negative: true\n                    });\n                }\n            },\n            {\n                key: \"propContains\",\n                value: function propContains(actual, expected, message) {\n                    actual = objectValuesSubset(actual, expected);\n                    // The expected parameter is usually a plain object, but clone it for\n                    // consistency with propEqual(), and to make it easy to explain that\n                    // inheritence is not considered (on either side), and to support\n                    // recursively checking subsets of nested objects.\n                    expected = objectValues(expected, false);\n                    this.pushResult({\n                        result: equiv(actual, expected),\n                        actual: actual,\n                        expected: expected,\n                        message: message\n                    });\n                }\n            },\n            {\n                key: \"notPropContains\",\n                value: function notPropContains(actual, expected, message) {\n                    actual = objectValuesSubset(actual, expected);\n                    expected = objectValues(expected);\n                    this.pushResult({\n                        result: !equiv(actual, expected),\n                        actual: actual,\n                        expected: expected,\n                        message: message,\n                        negative: true\n                    });\n                }\n            },\n            {\n                key: \"deepEqual\",\n                value: function deepEqual(actual, expected, message) {\n                    this.pushResult({\n                        result: equiv(actual, expected),\n                        actual: actual,\n                        expected: expected,\n                        message: message\n                    });\n                }\n            },\n            {\n                key: \"notDeepEqual\",\n                value: function notDeepEqual(actual, expected, message) {\n                    this.pushResult({\n                        result: !equiv(actual, expected),\n                        actual: actual,\n                        expected: expected,\n                        message: message,\n                        negative: true\n                    });\n                }\n            },\n            {\n                key: \"strictEqual\",\n                value: function strictEqual(actual, expected, message) {\n                    this.pushResult({\n                        result: expected === actual,\n                        actual: actual,\n                        expected: expected,\n                        message: message\n                    });\n                }\n            },\n            {\n                key: \"notStrictEqual\",\n                value: function notStrictEqual(actual, expected, message) {\n                    this.pushResult({\n                        result: expected !== actual,\n                        actual: actual,\n                        expected: expected,\n                        message: message,\n                        negative: true\n                    });\n                }\n            },\n            {\n                key: 'throws',\n                value: function throws(block, expected, message) {\n                    var _validateExpectedExce = validateExpectedExceptionArgs(expected, message, 'throws');\n                    var _validateExpectedExce2 = _slicedToArray(_validateExpectedExce, 2);\n                    expected = _validateExpectedExce2[0];\n                    message = _validateExpectedExce2[1];\n                    var currentTest = this instanceof Assert && this.test || config.current;\n                    if (typeof block !== 'function') {\n                        currentTest.assert.pushResult({\n                            result: false,\n                            actual: block,\n                            message: 'The value provided to `assert.throws` in \"' + currentTest.testName + '\" was not a function.'\n                        });\n                        return;\n                    }\n                    var actual;\n                    var result = false;\n                    currentTest.ignoreGlobalErrors = true;\n                    try {\n                        block.call(currentTest.testEnvironment);\n                    } catch (e) {\n                        actual = e;\n                    }\n                    currentTest.ignoreGlobalErrors = false;\n                    if (actual) {\n                        var _validateException = validateException(actual, expected, message);\n                        var _validateException2 = _slicedToArray(_validateException, 3);\n                        result = _validateException2[0];\n                        expected = _validateException2[1];\n                        message = _validateException2[2];\n                    }\n                    currentTest.assert.pushResult({\n                        result: result,\n                        // undefined if it didn't throw\n                        actual: actual && errorString(actual),\n                        expected: expected,\n                        message: message\n                    });\n                }\n            },\n            {\n                key: \"rejects\",\n                value: function rejects(promise, expected, message) {\n                    var _validateExpectedExce3 = validateExpectedExceptionArgs(expected, message, 'rejects');\n                    var _validateExpectedExce4 = _slicedToArray(_validateExpectedExce3, 2);\n                    expected = _validateExpectedExce4[0];\n                    message = _validateExpectedExce4[1];\n                    var currentTest = this instanceof Assert && this.test || config.current;\n                    var then = promise && promise.then;\n                    if (typeof then !== 'function') {\n                        currentTest.assert.pushResult({\n                            result: false,\n                            message: 'The value provided to `assert.rejects` in \"' + currentTest.testName + '\" was not a promise.',\n                            actual: promise\n                        });\n                        return;\n                    }\n                    var done = this.async();\n                    return then.call(promise, function handleFulfillment() {\n                        currentTest.assert.pushResult({\n                            result: false,\n                            message: 'The promise returned by the `assert.rejects` callback in \"' + currentTest.testName + '\" did not reject.',\n                            actual: promise\n                        });\n                        done();\n                    }, function handleRejection(actual) {\n                        var result;\n                        var _validateException3 = validateException(actual, expected, message);\n                        var _validateException4 = _slicedToArray(_validateException3, 3);\n                        result = _validateException4[0];\n                        expected = _validateException4[1];\n                        message = _validateException4[2];\n                        currentTest.assert.pushResult({\n                            result: result,\n                            // leave rejection value of undefined as-is\n                            actual: actual && errorString(actual),\n                            expected: expected,\n                            message: message\n                        });\n                        done();\n                    });\n                }\n            }\n        ]);\n    }();\n    function validateExpectedExceptionArgs(expected, message, assertionMethod) {\n        var expectedType = objectType(expected);\n        // 'expected' is optional unless doing string comparison\n        if (expectedType === 'string') {\n            if (message === undefined) {\n                message = expected;\n                expected = undefined;\n                return [\n                    expected,\n                    message\n                ];\n            } else throw new Error('assert.' + assertionMethod + ' does not accept a string value for the expected argument.\\n' + 'Use a non-string object value (e.g. RegExp or validator function) ' + 'instead if necessary.');\n        }\n        var valid = !expected || // TODO: be more explicit here\n        expectedType === 'regexp' || expectedType === 'function' || expectedType === 'object';\n        if (!valid) throw new Error('Invalid expected value type (' + expectedType + ') ' + 'provided to assert.' + assertionMethod + '.');\n        return [\n            expected,\n            message\n        ];\n    }\n    function validateException(actual, expected, message) {\n        var result = false;\n        var expectedType = objectType(expected);\n        // These branches should be exhaustive, based on validation done in validateExpectedException\n        // We don't want to validate\n        if (!expected) result = true;\n        else if (expectedType === 'regexp') {\n            result = expected.test(errorString(actual));\n            // Log the string form of the regexp\n            expected = String(expected);\n        // Expected is a constructor, maybe an Error constructor.\n        // Note the extra check on its prototype - this is an implicit\n        // requirement of \"instanceof\", else it will throw a TypeError.\n        } else if (expectedType === 'function' && expected.prototype !== undefined && actual instanceof expected) result = true;\n        else if (expectedType === 'object') {\n            result = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message;\n            // Log the string form of the Error object\n            expected = errorString(expected);\n        // Expected is a validation function which returns true if validation passed\n        } else if (expectedType === 'function') // protect against accidental semantics which could hard error in the test\n        try {\n            result = expected.call({}, actual) === true;\n            expected = null;\n        } catch (e) {\n            // assign the \"expected\" to a nice error string to communicate the local failure to the user\n            expected = errorString(e);\n        }\n        return [\n            result,\n            expected,\n            message\n        ];\n    }\n    // Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n    // Known to us are: Closure Compiler, Narwhal\n    // eslint-disable-next-line dot-notation\n    Assert.prototype.raises = Assert.prototype['throws'];\n    var SUPPORTED_EVENTS = [\n        'error',\n        'runStart',\n        'suiteStart',\n        'testStart',\n        'assertion',\n        'testEnd',\n        'suiteEnd',\n        'runEnd'\n    ];\n    var MEMORY_EVENTS = [\n        'error',\n        'runEnd'\n    ];\n    /**\n   * Emits an event with the specified data to all currently registered listeners.\n   * Callbacks will fire in the order in which they are registered (FIFO). This\n   * function is not exposed publicly; it is used by QUnit internals to emit\n   * logging events.\n   *\n   * @private\n   * @method emit\n   * @param {string} eventName\n   * @param {Object} data\n   * @return {void}\n   */ function emit(eventName, data) {\n        if (typeof eventName !== 'string') throw new TypeError('eventName must be a string when emitting an event');\n        // Clone the callbacks in case one of them registers a new callback\n        var originalCallbacks = config._event_listeners[eventName];\n        var callbacks = originalCallbacks ? _toConsumableArray(originalCallbacks) : [];\n        for(var i = 0; i < callbacks.length; i++)callbacks[i](data);\n        if (inArray(eventName, MEMORY_EVENTS)) config._event_memory[eventName] = data;\n    }\n    /**\n   * Registers a callback as a listener to the specified event.\n   *\n   * @public\n   * @method on\n   * @param {string} eventName\n   * @param {Function} callback\n   * @return {void}\n   */ function on(eventName, callback) {\n        if (typeof eventName !== 'string') throw new TypeError('eventName must be a string when registering a listener');\n        else if (!inArray(eventName, SUPPORTED_EVENTS)) {\n            var events = SUPPORTED_EVENTS.join(', ');\n            throw new Error(\"\\\"\".concat(eventName, \"\\\" is not a valid event; must be one of: \").concat(events, \".\"));\n        } else if (typeof callback !== 'function') throw new TypeError('callback must be a function when registering a listener');\n        var listeners = config._event_listeners[eventName] || (config._event_listeners[eventName] = []);\n        // Don't register the same callback more than once\n        if (!inArray(callback, listeners)) {\n            listeners.push(callback);\n            if (config._event_memory[eventName] !== undefined) callback(config._event_memory[eventName]);\n        }\n    }\n    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof $parcel$global !== 'undefined' ? $parcel$global : typeof self !== 'undefined' ? self : {};\n    function commonjsRequire(path) {\n        throw new Error('Could not dynamically require \"' + path + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n    }\n    var promisePolyfill = {\n        exports: {}\n    };\n    (function() {\n        /** @suppress {undefinedVars} */ var globalNS = function() {\n            // the only reliable means to get the global object is\n            // `Function('return this')()`\n            // However, this causes CSP violations in Chrome apps.\n            if (typeof globalThis !== 'undefined') return globalThis;\n            if (typeof self !== 'undefined') return self;\n            if (typeof window !== 'undefined') return window;\n            if (typeof commonjsGlobal !== 'undefined') return commonjsGlobal;\n            throw new Error('unable to locate global object');\n        }();\n        // Expose the polyfill if Promise is undefined or set to a\n        // non-function value. The latter can be due to a named HTMLElement\n        // being exposed by browsers for legacy reasons.\n        // https://github.com/taylorhakes/promise-polyfill/issues/114\n        if (typeof globalNS['Promise'] === 'function') {\n            promisePolyfill.exports = globalNS['Promise'];\n            return;\n        }\n        /**\n     * @this {Promise}\n     */ function finallyConstructor(callback) {\n            var constructor = this.constructor;\n            return this.then(function(value) {\n                // @ts-ignore\n                return constructor.resolve(callback()).then(function() {\n                    return value;\n                });\n            }, function(reason) {\n                // @ts-ignore\n                return constructor.resolve(callback()).then(function() {\n                    // @ts-ignore\n                    return constructor.reject(reason);\n                });\n            });\n        }\n        function allSettled(arr) {\n            var P = this;\n            return new P(function(resolve, reject) {\n                if (!(arr && typeof arr.length !== 'undefined')) return reject(new TypeError(_typeof(arr) + ' ' + arr + ' is not iterable(cannot read property Symbol(Symbol.iterator))'));\n                var args = Array.prototype.slice.call(arr);\n                if (args.length === 0) return resolve([]);\n                var remaining = args.length;\n                function res(i, val) {\n                    if (val && (_typeof(val) === 'object' || typeof val === 'function')) {\n                        var then = val.then;\n                        if (typeof then === 'function') {\n                            then.call(val, function(val) {\n                                res(i, val);\n                            }, function(e) {\n                                args[i] = {\n                                    status: 'rejected',\n                                    reason: e\n                                };\n                                if (--remaining === 0) resolve(args);\n                            });\n                            return;\n                        }\n                    }\n                    args[i] = {\n                        status: 'fulfilled',\n                        value: val\n                    };\n                    if (--remaining === 0) resolve(args);\n                }\n                for(var i = 0; i < args.length; i++)res(i, args[i]);\n            });\n        }\n        // Store setTimeout reference so promise-polyfill will be unaffected by\n        // other code modifying setTimeout (like sinon.useFakeTimers())\n        var setTimeoutFunc = setTimeout;\n        function isArray(x) {\n            return Boolean(x && typeof x.length !== 'undefined');\n        }\n        function noop() {}\n        // Polyfill for Function.prototype.bind\n        function bind(fn, thisArg) {\n            return function() {\n                fn.apply(thisArg, arguments);\n            };\n        }\n        /**\n     * @constructor\n     * @param {Function} fn\n     */ function Promise1(fn) {\n            if (!(this instanceof Promise1)) throw new TypeError('Promises must be constructed via new');\n            if (typeof fn !== 'function') throw new TypeError('not a function');\n            /** @type {!number} */ this._state = 0;\n            /** @type {!boolean} */ this._handled = false;\n            /** @type {Promise|undefined} */ this._value = undefined;\n            /** @type {!Array<!Function>} */ this._deferreds = [];\n            doResolve(fn, this);\n        }\n        function handle(self1, deferred) {\n            while(self1._state === 3)self1 = self1._value;\n            if (self1._state === 0) {\n                self1._deferreds.push(deferred);\n                return;\n            }\n            self1._handled = true;\n            Promise1._immediateFn(function() {\n                var cb = self1._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n                if (cb === null) {\n                    (self1._state === 1 ? resolve : reject)(deferred.promise, self1._value);\n                    return;\n                }\n                var ret;\n                try {\n                    ret = cb(self1._value);\n                } catch (e) {\n                    reject(deferred.promise, e);\n                    return;\n                }\n                resolve(deferred.promise, ret);\n            });\n        }\n        function resolve(self1, newValue) {\n            try {\n                // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n                if (newValue === self1) throw new TypeError('A promise cannot be resolved with itself.');\n                if (newValue && (_typeof(newValue) === 'object' || typeof newValue === 'function')) {\n                    var then = newValue.then;\n                    if (newValue instanceof Promise1) {\n                        self1._state = 3;\n                        self1._value = newValue;\n                        finale(self1);\n                        return;\n                    } else if (typeof then === 'function') {\n                        doResolve(bind(then, newValue), self1);\n                        return;\n                    }\n                }\n                self1._state = 1;\n                self1._value = newValue;\n                finale(self1);\n            } catch (e) {\n                reject(self1, e);\n            }\n        }\n        function reject(self1, newValue) {\n            self1._state = 2;\n            self1._value = newValue;\n            finale(self1);\n        }\n        function finale(self1) {\n            if (self1._state === 2 && self1._deferreds.length === 0) Promise1._immediateFn(function() {\n                if (!self1._handled) Promise1._unhandledRejectionFn(self1._value);\n            });\n            for(var i = 0, len = self1._deferreds.length; i < len; i++)handle(self1, self1._deferreds[i]);\n            self1._deferreds = null;\n        }\n        /**\n     * @constructor\n     */ function Handler(onFulfilled, onRejected, promise) {\n            this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n            this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n            this.promise = promise;\n        }\n        /**\n     * Take a potentially misbehaving resolver function and make sure\n     * onFulfilled and onRejected are only called once.\n     *\n     * Makes no guarantees about asynchrony.\n     */ function doResolve(fn, self1) {\n            var done = false;\n            try {\n                fn(function(value) {\n                    if (done) return;\n                    done = true;\n                    resolve(self1, value);\n                }, function(reason) {\n                    if (done) return;\n                    done = true;\n                    reject(self1, reason);\n                });\n            } catch (ex) {\n                if (done) return;\n                done = true;\n                reject(self1, ex);\n            }\n        }\n        Promise1.prototype['catch'] = function(onRejected) {\n            return this.then(null, onRejected);\n        };\n        Promise1.prototype.then = function(onFulfilled, onRejected) {\n            // @ts-ignore\n            var prom = new this.constructor(noop);\n            handle(this, new Handler(onFulfilled, onRejected, prom));\n            return prom;\n        };\n        Promise1.prototype['finally'] = finallyConstructor;\n        Promise1.all = function(arr) {\n            return new Promise1(function(resolve, reject) {\n                if (!isArray(arr)) return reject(new TypeError('Promise.all accepts an array'));\n                var args = Array.prototype.slice.call(arr);\n                if (args.length === 0) return resolve([]);\n                var remaining = args.length;\n                function res(i, val) {\n                    try {\n                        if (val && (_typeof(val) === 'object' || typeof val === 'function')) {\n                            var then = val.then;\n                            if (typeof then === 'function') {\n                                then.call(val, function(val) {\n                                    res(i, val);\n                                }, reject);\n                                return;\n                            }\n                        }\n                        args[i] = val;\n                        if (--remaining === 0) resolve(args);\n                    } catch (ex) {\n                        reject(ex);\n                    }\n                }\n                for(var i = 0; i < args.length; i++)res(i, args[i]);\n            });\n        };\n        Promise1.allSettled = allSettled;\n        Promise1.resolve = function(value) {\n            if (value && _typeof(value) === 'object' && value.constructor === Promise1) return value;\n            return new Promise1(function(resolve) {\n                resolve(value);\n            });\n        };\n        Promise1.reject = function(value) {\n            return new Promise1(function(resolve, reject) {\n                reject(value);\n            });\n        };\n        Promise1.race = function(arr) {\n            return new Promise1(function(resolve, reject) {\n                if (!isArray(arr)) return reject(new TypeError('Promise.race accepts an array'));\n                for(var i = 0, len = arr.length; i < len; i++)Promise1.resolve(arr[i]).then(resolve, reject);\n            });\n        };\n        // Use polyfill for setImmediate for performance gains\n        // @ts-ignore\n        if (typeof setImmediate === 'function') {\n            // @ts-ignore\n            var setImmediateFunc = setImmediate;\n            Promise1._immediateFn = function(fn) {\n                setImmediateFunc(fn);\n            };\n        } else Promise1._immediateFn = function(fn) {\n            setTimeoutFunc(fn, 0);\n        };\n        Promise1._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n            if (typeof console !== 'undefined' && console) console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n        };\n        promisePolyfill.exports = Promise1;\n    })();\n    var _Promise = promisePolyfill.exports;\n    // Register logging callbacks\n    function registerLoggingCallbacks(obj) {\n        var callbackNames = [\n            'begin',\n            'done',\n            'log',\n            'testStart',\n            'testDone',\n            'moduleStart',\n            'moduleDone'\n        ];\n        function registerLoggingCallback(key) {\n            return function loggingCallback(callback) {\n                if (typeof callback !== 'function') throw new Error('Callback parameter must be a function');\n                config.callbacks[key].push(callback);\n            };\n        }\n        for(var i = 0; i < callbackNames.length; i++){\n            var key = callbackNames[i];\n            // Initialize key collection of logging callback\n            if (typeof config.callbacks[key] === 'undefined') config.callbacks[key] = [];\n            obj[key] = registerLoggingCallback(key);\n        }\n    }\n    function runLoggingCallbacks(key, args) {\n        var callbacks = config.callbacks[key];\n        // Handling 'log' callbacks separately. Unlike the other callbacks,\n        // the log callback is not controlled by the processing queue,\n        // but rather used by asserts. Hence to promisfy the 'log' callback\n        // would mean promisfying each step of a test\n        if (key === 'log') {\n            callbacks.map(function(callback) {\n                return callback(args);\n            });\n            return;\n        }\n        // ensure that each callback is executed serially\n        var promiseChain = _Promise.resolve();\n        callbacks.forEach(function(callback) {\n            promiseChain = promiseChain.then(function() {\n                return _Promise.resolve(callback(args));\n            });\n        });\n        return promiseChain;\n    }\n    var TestReport = /*#__PURE__*/ function() {\n        function TestReport(name, suite, options) {\n            _classCallCheck(this, TestReport);\n            this.name = name;\n            this.suiteName = suite.name;\n            this.fullName = suite.fullName.concat(name);\n            this.runtime = 0;\n            this.assertions = [];\n            this.skipped = !!options.skip;\n            this.todo = !!options.todo;\n            this.valid = options.valid;\n            this._startTime = 0;\n            this._endTime = 0;\n            suite.pushTest(this);\n        }\n        return _createClass(TestReport, [\n            {\n                key: \"start\",\n                value: function start(recordTime) {\n                    if (recordTime) this._startTime = performance.now();\n                    return {\n                        name: this.name,\n                        suiteName: this.suiteName,\n                        fullName: this.fullName.slice()\n                    };\n                }\n            },\n            {\n                key: \"end\",\n                value: function end(recordTime) {\n                    if (recordTime) this._endTime = performance.now();\n                    return extend(this.start(), {\n                        runtime: this.getRuntime(),\n                        status: this.getStatus(),\n                        errors: this.getFailedAssertions(),\n                        assertions: this.getAssertions()\n                    });\n                }\n            },\n            {\n                key: \"pushAssertion\",\n                value: function pushAssertion(assertion) {\n                    this.assertions.push(assertion);\n                }\n            },\n            {\n                key: \"getRuntime\",\n                value: function getRuntime() {\n                    return Math.round(this._endTime - this._startTime);\n                }\n            },\n            {\n                key: \"getStatus\",\n                value: function getStatus() {\n                    if (this.skipped) return 'skipped';\n                    var testPassed = this.getFailedAssertions().length > 0 ? this.todo : !this.todo;\n                    if (!testPassed) return 'failed';\n                    else if (this.todo) return 'todo';\n                    else return 'passed';\n                }\n            },\n            {\n                key: \"getFailedAssertions\",\n                value: function getFailedAssertions() {\n                    return this.assertions.filter(function(assertion) {\n                        return !assertion.passed;\n                    });\n                }\n            },\n            {\n                key: \"getAssertions\",\n                value: function getAssertions() {\n                    return this.assertions.slice();\n                }\n            },\n            {\n                key: \"slimAssertions\",\n                value: function slimAssertions() {\n                    this.assertions = this.assertions.map(function(assertion) {\n                        delete assertion.actual;\n                        delete assertion.expected;\n                        return assertion;\n                    });\n                }\n            }\n        ]);\n    }();\n    function Test(settings) {\n        this.expected = null;\n        this.assertions = [];\n        this.module = config.currentModule;\n        this.steps = [];\n        // This powers the QUnit.config.countStepsAsOne feature.\n        // https://github.com/qunitjs/qunit/pull/1775\n        this.stepsCount = 0;\n        this.timeout = undefined;\n        this.data = undefined;\n        this.withData = false;\n        this.pauses = new StringMap();\n        this.nextPauseId = 1;\n        // For the most common case, we have:\n        // - 0: new Test\n        // - 1: addTest\n        // - 2: QUnit.test\n        // - 3: user file\n        //\n        // This needs is customised by test.each()\n        this.stackOffset = 3;\n        extend(this, settings);\n        // If a module is skipped, all its tests and the tests of the child suites\n        // should be treated as skipped even if they are defined as `only` or `todo`.\n        // As for `todo` module, all its tests will be treated as `todo` except for\n        // tests defined as `skip` which will be left intact.\n        //\n        // So, if a test is defined as `todo` and is inside a skipped module, we should\n        // then treat that test as if was defined as `skip`.\n        if (this.module.skip) {\n            this.skip = true;\n            this.todo = false;\n        // Skipped tests should be left intact\n        } else if (this.module.todo && !this.skip) this.todo = true;\n        // Queuing a late test after the run has ended is not allowed.\n        // This was once supported for internal use by QUnit.onError().\n        // Ref https://github.com/qunitjs/qunit/issues/1377\n        if (config.pq.finished) {\n            // Using this for anything other than onError(), such as testing in QUnit.done(),\n            // is unstable and will likely result in the added tests being ignored by CI.\n            // (Meaning the CI passes irregardless of the added tests).\n            //\n            // TODO: Make this an error in QUnit 3.0\n            // throw new Error( \"Unexpected test after runEnd\" );\n            Logger.warn('Unexpected test after runEnd. This is unstable and will fail in QUnit 3.0.');\n            return;\n        }\n        if (!this.skip && typeof this.callback !== 'function') {\n            var method = this.todo ? 'QUnit.todo' : 'QUnit.test';\n            throw new TypeError(\"You must provide a callback to \".concat(method, \"(\\\"\").concat(this.testName, \"\\\")\"));\n        }\n        // Register unique strings\n        for(var i = 0, l = this.module.tests; i < l.length; i++)if (this.module.tests[i].name === this.testName) this.testName += ' ';\n        this.testId = generateHash(this.module.name, this.testName);\n        // No validation after this. Beyond this point, failures must be recorded as\n        // a completed test with errors, instead of early bail out.\n        // Otherwise, internals may be left in an inconsistent state.\n        // Ref https://github.com/qunitjs/qunit/issues/1514\n        ++Test.count;\n        this.errorForStack = new Error();\n        if (this.callback && this.callback.validTest) // Omit the test-level trace for the internal \"No tests\" test failure,\n        // There is already an assertion-level trace, and that's noisy enough\n        // as it is.\n        this.errorForStack.stack = undefined;\n        this.testReport = new TestReport(this.testName, this.module.suiteReport, {\n            todo: this.todo,\n            skip: this.skip,\n            valid: this.valid()\n        });\n        this.module.tests.push({\n            name: this.testName,\n            testId: this.testId,\n            skip: !!this.skip\n        });\n        if (this.skip) {\n            // Skipped tests will fully ignore (and dereference for garbage collect) any sent callback\n            this.callback = function() {};\n            this.async = false;\n            this.expected = 0;\n        } else this.assert = new Assert(this);\n    }\n    Test.count = 0;\n    function getNotStartedModules(startModule) {\n        var module1 = startModule;\n        var modules = [];\n        while(module1 && module1.testsRun === 0){\n            modules.push(module1);\n            module1 = module1.parentModule;\n        }\n        // The above push modules from the child to the parent\n        // return a reversed order with the top being the top most parent module\n        return modules.reverse();\n    }\n    Test.prototype = {\n        // Use a getter to avoid computing a stack trace (which can be expensive),\n        // This is displayed by the HTML Reporter, but most other integrations do\n        // not access it.\n        get stack () {\n            return extractStacktrace(this.errorForStack, this.stackOffset);\n        },\n        before: function before() {\n            var _this = this;\n            var module1 = this.module;\n            var notStartedModules = getNotStartedModules(module1);\n            // ensure the callbacks are executed serially for each module\n            var moduleStartChain = _Promise.resolve();\n            notStartedModules.forEach(function(startModule) {\n                moduleStartChain = moduleStartChain.then(function() {\n                    startModule.stats = {\n                        all: 0,\n                        bad: 0,\n                        started: performance.now()\n                    };\n                    emit('suiteStart', startModule.suiteReport.start(true));\n                    return runLoggingCallbacks('moduleStart', {\n                        name: startModule.name,\n                        tests: startModule.tests\n                    });\n                });\n            });\n            return moduleStartChain.then(function() {\n                config.current = _this;\n                _this.testEnvironment = extend({}, module1.testEnvironment);\n                _this.started = performance.now();\n                emit('testStart', _this.testReport.start(true));\n                return runLoggingCallbacks('testStart', {\n                    name: _this.testName,\n                    module: module1.name,\n                    testId: _this.testId,\n                    previousFailure: _this.previousFailure\n                }).then(function() {\n                    if (!config.pollution) saveGlobal();\n                });\n            });\n        },\n        run: function run() {\n            config.current = this;\n            if (config.notrycatch) {\n                runTest(this);\n                return;\n            }\n            try {\n                runTest(this);\n            } catch (e) {\n                this.pushFailure('Died on test #' + (this.assertions.length + 1) + ': ' + (e.message || e) + '\\n' + this.stack, extractStacktrace(e, 0));\n                // Else next test will carry the responsibility\n                saveGlobal();\n                // Restart the tests if they're blocking\n                if (config.blocking) internalRecover(this);\n            }\n            function runTest(test) {\n                var promise;\n                if (test.withData) promise = test.callback.call(test.testEnvironment, test.assert, test.data);\n                else promise = test.callback.call(test.testEnvironment, test.assert);\n                test.resolvePromise(promise);\n                // If the test has an async \"pause\" on it, but the timeout is 0, then we push a\n                // failure as the test should be synchronous.\n                if (test.timeout === 0 && test.pauses.size > 0) pushFailure('Test did not finish synchronously even though assert.timeout( 0 ) was used.', sourceFromStacktrace(2));\n            }\n        },\n        after: function after() {\n            checkPollution();\n        },\n        queueGlobalHook: function queueGlobalHook(hook, hookName) {\n            var _this2 = this;\n            var runHook = function runHook() {\n                config.current = _this2;\n                var promise;\n                if (config.notrycatch) promise = hook.call(_this2.testEnvironment, _this2.assert);\n                else try {\n                    promise = hook.call(_this2.testEnvironment, _this2.assert);\n                } catch (error) {\n                    _this2.pushFailure('Global ' + hookName + ' failed on ' + _this2.testName + ': ' + errorString(error), extractStacktrace(error, 0));\n                    return;\n                }\n                _this2.resolvePromise(promise, hookName);\n            };\n            return runHook;\n        },\n        queueHook: function queueHook(hook, hookName, hookOwner) {\n            var _this3 = this;\n            var callHook = function callHook() {\n                var promise = hook.call(_this3.testEnvironment, _this3.assert);\n                _this3.resolvePromise(promise, hookName);\n            };\n            var runHook = function runHook() {\n                if (hookName === 'before') {\n                    if (hookOwner.testsRun !== 0) return;\n                    _this3.preserveEnvironment = true;\n                }\n                // The 'after' hook should only execute when there are not tests left and\n                // when the 'after' and 'finish' tasks are the only tasks left to process\n                if (hookName === 'after' && !lastTestWithinModuleExecuted(hookOwner) && (config.queue.length > 0 || config.pq.taskCount() > 2)) return;\n                config.current = _this3;\n                if (config.notrycatch) {\n                    callHook();\n                    return;\n                }\n                try {\n                    // This try-block includes the indirect call to resolvePromise, which shouldn't\n                    // have to be inside try-catch. But, since we support any user-provided thenable\n                    // object, the thenable might throw in some unexpected way.\n                    // This subtle behaviour is undocumented. To avoid new failures in minor releases\n                    // we will not change this until QUnit 3.\n                    // TODO: In QUnit 3, reduce this try-block to just hook.call(), matching\n                    // the simplicity of queueGlobalHook.\n                    callHook();\n                } catch (error) {\n                    _this3.pushFailure(hookName + ' failed on ' + _this3.testName + ': ' + (error.message || error), extractStacktrace(error, 0));\n                }\n            };\n            return runHook;\n        },\n        // Currently only used for module level hooks, can be used to add global level ones\n        hooks: function hooks(handler) {\n            var hooks = [];\n            function processGlobalhooks(test) {\n                if ((handler === 'beforeEach' || handler === 'afterEach') && config.globalHooks[handler]) for(var i = 0; i < config.globalHooks[handler].length; i++)hooks.push(test.queueGlobalHook(config.globalHooks[handler][i], handler));\n            }\n            function processHooks(test, module1) {\n                if (module1.parentModule) processHooks(test, module1.parentModule);\n                if (module1.hooks[handler].length) for(var i = 0; i < module1.hooks[handler].length; i++)hooks.push(test.queueHook(module1.hooks[handler][i], handler, module1));\n            }\n            // Hooks are ignored on skipped tests\n            if (!this.skip) {\n                processGlobalhooks(this);\n                processHooks(this, this.module);\n            }\n            return hooks;\n        },\n        finish: function finish() {\n            config.current = this;\n            // Release the timeout and timeout callback references to be garbage collected.\n            // https://github.com/qunitjs/qunit/pull/1708\n            if (setTimeout$1) {\n                clearTimeout(this.timeout);\n                config.timeoutHandler = null;\n            }\n            // Release the test callback to ensure that anything referenced has been\n            // released to be garbage collected.\n            this.callback = undefined;\n            if (this.steps.length) {\n                var stepsList = this.steps.join(', ');\n                this.pushFailure('Expected assert.verifySteps() to be called before end of test ' + \"after using assert.step(). Unverified steps: \".concat(stepsList), this.stack);\n            }\n            if (!config._deprecated_countEachStep_shown && !config.countStepsAsOne && this.expected !== null && this.stepsCount) {\n                config._deprecated_countEachStep_shown = true;\n                if (config.requireExpects) Logger.warn('Counting each assert.step() for assert.expect() is changing in QUnit 3.0. You can enable QUnit.config.countStepsAsOne to prepare for the upgrade. https://qunitjs.com/api/assert/expect/');\n                else Logger.warn('Counting each assert.step() for assert.expect() is changing in QUnit 3.0. Omit assert.expect() from tests that use assert.step(), or enable QUnit.config.countStepsAsOne to prepare for the upgrade. https://qunitjs.com/api/assert/expect/');\n            }\n            var actualCountForExpect = config.countStepsAsOne ? this.assertions.length - this.stepsCount : this.assertions.length;\n            if (config.requireExpects && this.expected === null) this.pushFailure(\"Expected number of assertions to be defined, but expect() was not called.\", this.stack);\n            else if (this.expected !== null && this.expected !== actualCountForExpect && this.stepsCount && this.expected === this.assertions.length - this.stepsCount && !config.countStepsAsOne) this.pushFailure('Expected ' + this.expected + ' assertions, but ' + actualCountForExpect + ' were run\\nIt looks like you might prefer to enable QUnit.config.countStepsAsOne, which will become the default in QUnit 3.0. https://qunitjs.com/api/assert/expect/', this.stack);\n            else if (this.expected !== null && this.expected !== actualCountForExpect && this.stepsCount && this.expected === this.assertions.length && config.countStepsAsOne) this.pushFailure('Expected ' + this.expected + ' assertions, but ' + actualCountForExpect + ' were run\\nRemember that with QUnit.config.countStepsAsOne and in QUnit 3.0, steps no longer count as separate assertions. https://qunitjs.com/api/assert/expect/', this.stack);\n            else if (this.expected !== null && this.expected !== actualCountForExpect) this.pushFailure('Expected ' + this.expected + ' assertions, but ' + actualCountForExpect + ' were run', this.stack);\n            else if (this.expected === null && !actualCountForExpect) this.pushFailure(\"Expected at least one assertion, but none were run - call expect(0) to accept zero assertions.\", this.stack);\n            var module1 = this.module;\n            var moduleName = module1.name;\n            var testName = this.testName;\n            var skipped = !!this.skip;\n            var todo = !!this.todo;\n            var bad = 0;\n            var storage = config.storage;\n            this.runtime = Math.round(performance.now() - this.started);\n            config.stats.all += this.assertions.length;\n            config.stats.testCount += 1;\n            module1.stats.all += this.assertions.length;\n            for(var i = 0; i < this.assertions.length; i++)// A failing assertion will counts toward the HTML Reporter's\n            // \"X assertions, Y failed\" line even if it was inside a todo.\n            // Inverting this would be similarly confusing since all but the last\n            // passing assertion inside a todo test should be considered as good.\n            // These stats don't decide the outcome of anything, so counting them\n            // as failing seems the most intuitive.\n            if (!this.assertions[i].result) {\n                bad++;\n                config.stats.bad++;\n                module1.stats.bad++;\n            }\n            if (skipped) incrementTestsIgnored(module1);\n            else incrementTestsRun(module1);\n            // Store result when possible.\n            // Note that this also marks todo tests as bad, thus they get hoisted,\n            // and always run first on refresh.\n            if (storage) {\n                if (bad) storage.setItem('qunit-test-' + moduleName + '-' + testName, bad);\n                else storage.removeItem('qunit-test-' + moduleName + '-' + testName);\n            }\n            // After emitting the js-reporters event we cleanup the assertion data to\n            // avoid leaking it. It is not used by the legacy testDone callbacks.\n            emit('testEnd', this.testReport.end(true));\n            this.testReport.slimAssertions();\n            var test = this;\n            return runLoggingCallbacks('testDone', {\n                name: testName,\n                module: moduleName,\n                skipped: skipped,\n                todo: todo,\n                failed: bad,\n                passed: this.assertions.length - bad,\n                total: this.assertions.length,\n                runtime: skipped ? 0 : this.runtime,\n                // HTML Reporter use\n                assertions: this.assertions,\n                testId: this.testId,\n                // Source of Test\n                // generating stack trace is expensive, so using a getter will help defer this until we need it\n                get source () {\n                    return test.stack;\n                }\n            }).then(function() {\n                if (allTestsExecuted(module1)) {\n                    var completedModules = [\n                        module1\n                    ];\n                    // Check if the parent modules, iteratively, are done. If that the case,\n                    // we emit the `suiteEnd` event and trigger `moduleDone` callback.\n                    var parent = module1.parentModule;\n                    while(parent && allTestsExecuted(parent)){\n                        completedModules.push(parent);\n                        parent = parent.parentModule;\n                    }\n                    var moduleDoneChain = _Promise.resolve();\n                    completedModules.forEach(function(completedModule) {\n                        moduleDoneChain = moduleDoneChain.then(function() {\n                            return logSuiteEnd(completedModule);\n                        });\n                    });\n                    return moduleDoneChain;\n                }\n            }).then(function() {\n                config.current = undefined;\n            });\n            function logSuiteEnd(module1) {\n                // Reset `module.hooks` to ensure that anything referenced in these hooks\n                // has been released to be garbage collected. Descendant modules that were\n                // entirely skipped, e.g. due to filtering, will never have this method\n                // called for them, but might have hooks with references pinning data in\n                // memory (even if the hooks weren't actually executed), so we reset the\n                // hooks on all descendant modules here as well. This is safe because we\n                // will never call this as long as any descendant modules still have tests\n                // to run. This also means that in multi-tiered nesting scenarios we might\n                // reset the hooks multiple times on some modules, but that's harmless.\n                var modules = [\n                    module1\n                ];\n                while(modules.length){\n                    var nextModule = modules.shift();\n                    nextModule.hooks = {};\n                    modules.push.apply(modules, _toConsumableArray(nextModule.childModules));\n                }\n                emit('suiteEnd', module1.suiteReport.end(true));\n                return runLoggingCallbacks('moduleDone', {\n                    name: module1.name,\n                    tests: module1.tests,\n                    failed: module1.stats.bad,\n                    passed: module1.stats.all - module1.stats.bad,\n                    total: module1.stats.all,\n                    runtime: Math.round(performance.now() - module1.stats.started)\n                });\n            }\n        },\n        preserveTestEnvironment: function preserveTestEnvironment() {\n            if (this.preserveEnvironment) {\n                this.module.testEnvironment = this.testEnvironment;\n                this.testEnvironment = extend({}, this.module.testEnvironment);\n            }\n        },\n        queue: function queue() {\n            var test = this;\n            if (!this.valid()) {\n                incrementTestsIgnored(this.module);\n                return;\n            }\n            function runTest() {\n                return [\n                    function() {\n                        return test.before();\n                    }\n                ].concat(_toConsumableArray(test.hooks('before')), [\n                    function() {\n                        test.preserveTestEnvironment();\n                    }\n                ], _toConsumableArray(test.hooks('beforeEach')), [\n                    function() {\n                        test.run();\n                    }\n                ], _toConsumableArray(test.hooks('afterEach').reverse()), _toConsumableArray(test.hooks('after').reverse()), [\n                    function() {\n                        test.after();\n                    },\n                    function() {\n                        return test.finish();\n                    }\n                ]);\n            }\n            var previousFailCount = config.storage && +config.storage.getItem('qunit-test-' + this.module.name + '-' + this.testName);\n            // Prioritize previously failed tests, detected from storage\n            var prioritize = config.reorder && !!previousFailCount;\n            this.previousFailure = !!previousFailCount;\n            config.pq.add(runTest, prioritize);\n        },\n        pushResult: function pushResult(resultInfo) {\n            if (this !== config.current) {\n                var message = resultInfo && resultInfo.message || '';\n                var testName = this && this.testName || '';\n                var error = \"Assertion occurred after test finished.\\n> Test: \" + testName + '\\n' + '> Message: ' + message + '\\n';\n                throw new Error(error);\n            }\n            // Destructure of resultInfo = { result, actual, expected, message, negative }\n            var details = {\n                module: this.module.name,\n                name: this.testName,\n                result: resultInfo.result,\n                message: resultInfo.message,\n                actual: resultInfo.actual,\n                testId: this.testId,\n                negative: resultInfo.negative || false,\n                runtime: Math.round(performance.now() - this.started),\n                todo: !!this.todo\n            };\n            if (hasOwn$1.call(resultInfo, 'expected')) details.expected = resultInfo.expected;\n            if (!resultInfo.result) {\n                var source = resultInfo.source || sourceFromStacktrace();\n                if (source) details.source = source;\n            }\n            this.logAssertion(details);\n            this.assertions.push({\n                result: !!resultInfo.result,\n                message: resultInfo.message\n            });\n        },\n        pushFailure: function pushFailure(message, source) {\n            if (!(this instanceof Test)) throw new Error('pushFailure() assertion outside test context, was ' + sourceFromStacktrace(2));\n            this.pushResult({\n                result: false,\n                message: message || 'error',\n                source: source\n            });\n        },\n        /**\n     * Log assertion details using both the old QUnit.log interface and\n     * QUnit.on( \"assertion\" ) interface.\n     *\n     * @private\n     */ logAssertion: function logAssertion(details) {\n            runLoggingCallbacks('log', details);\n            var assertion = {\n                passed: details.result,\n                actual: details.actual,\n                expected: details.expected,\n                message: details.message,\n                stack: details.source,\n                todo: details.todo\n            };\n            this.testReport.pushAssertion(assertion);\n            emit('assertion', assertion);\n        },\n        /**\n     * Reset config.timeout with a new timeout duration.\n     *\n     * @param {number} timeoutDuration\n     */ internalResetTimeout: function internalResetTimeout(timeoutDuration) {\n            clearTimeout(config.timeout);\n            config.timeout = setTimeout$1(config.timeoutHandler(timeoutDuration), timeoutDuration);\n        },\n        /**\n     * Create a new async pause and return a new function that can release the pause.\n     *\n     * This mechanism is internally used by:\n     *\n     * - explicit async pauses, created by calling `assert.async()`,\n     * - implicit async pauses, created when `QUnit.test()` or module hook callbacks\n     *   use async-await or otherwise return a Promise.\n     *\n     * Happy scenario:\n     *\n     * - Pause is created by calling internalStop().\n     *\n     *   Pause is released normally by invoking release() during the same test.\n     *\n     *   The release() callback lets internal processing resume.\n     *\n     * Failure scenarios:\n     *\n     * - The test fails due to an uncaught exception.\n     *\n     *   In this case, Test.run() will call internalRecover() which empties the clears all\n     *   async pauses and sets the cancelled flag, which means we silently ignore any\n     *   late calls to the resume() callback, as we will have moved on to a different\n     *   test by then, and we don't want to cause an extra \"release during a different test\"\n     *   errors that the developer isn't really responsible for. This can happen when a test\n     *   correctly schedules a call to release(), but also causes an uncaught error. The\n     *   uncaught error means we will no longer wait for the release (as it might not arrive).\n     *\n     * - Pause is never released, or called an insufficient number of times.\n     *\n     *   Our timeout handler will kill the pause and resume test processing, basically\n     *   like internalRecover(), but for one pause instead of any/all.\n     *\n     *   Here, too, any late calls to resume() will be silently ignored to avoid\n     *   extra errors. We tolerate this since the original test will have already been\n     *   marked as failure.\n     *\n     *   TODO: QUnit 3 will enable timeouts by default <https://github.com/qunitjs/qunit/issues/1483>,\n     *   but right now a test will hang indefinitely if async pauses are not released,\n     *   unless QUnit.config.testTimeout or assert.timeout() is used.\n     *\n     * - Pause is spontaneously released during a different test,\n     *   or when no test is currently running.\n     *\n     *   This is close to impossible because this error only happens if the original test\n     *   succesfully finished first (since other failure scenarios kill pauses and ignore\n     *   late calls). It can happen if a test ended exactly as expected, but has some\n     *   external or shared state continuing to hold a reference to the release callback,\n     *   and either the same test scheduled another call to it in the future, or a later test\n     *   causes it to be called through some shared state.\n     *\n     * - Pause release() is called too often, during the same test.\n     *\n     *   This simply throws an error, after which uncaught error handling picks it up\n     *   and processing resumes.\n     *\n     * @param {number} [requiredCalls=1]\n     */ internalStop: function internalStop() {\n            var requiredCalls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n            config.blocking = true;\n            var test = this;\n            var pauseId = this.nextPauseId++;\n            var pause = {\n                cancelled: false,\n                remaining: requiredCalls\n            };\n            test.pauses.set(pauseId, pause);\n            function release() {\n                if (pause.cancelled) return;\n                if (config.current === undefined) throw new Error('Unexpected release of async pause after tests finished.\\n' + \"> Test: \".concat(test.testName, \" [async #\").concat(pauseId, \"]\"));\n                if (config.current !== test) throw new Error('Unexpected release of async pause during a different test.\\n' + \"> Test: \".concat(test.testName, \" [async #\").concat(pauseId, \"]\"));\n                if (pause.remaining <= 0) throw new Error('Tried to release async pause that was already released.\\n' + \"> Test: \".concat(test.testName, \" [async #\").concat(pauseId, \"]\"));\n                // The `requiredCalls` parameter exists to support `assert.async(count)`\n                pause.remaining--;\n                if (pause.remaining === 0) test.pauses.delete(pauseId);\n                internalStart(test);\n            }\n            // Set a recovery timeout, if so configured.\n            if (setTimeout$1) {\n                var timeoutDuration;\n                if (typeof test.timeout === 'number') timeoutDuration = test.timeout;\n                else if (typeof config.testTimeout === 'number') timeoutDuration = config.testTimeout;\n                if (typeof timeoutDuration === 'number' && timeoutDuration > 0) {\n                    config.timeoutHandler = function(timeout) {\n                        return function() {\n                            config.timeout = null;\n                            pause.cancelled = true;\n                            test.pauses.delete(pauseId);\n                            test.pushFailure(\"Test took longer than \".concat(timeout, \"ms; test timed out.\"), sourceFromStacktrace(2));\n                            internalRecover(test);\n                        };\n                    };\n                    clearTimeout(config.timeout);\n                    config.timeout = setTimeout$1(config.timeoutHandler(timeoutDuration), timeoutDuration);\n                } else {\n                    clearTimeout(config.timeout);\n                    config.timeout = setTimeout$1(function() {\n                        config.timeout = null;\n                        if (!config._deprecated_timeout_shown) {\n                            config._deprecated_timeout_shown = true;\n                            Logger.warn(\"Test \\\"\".concat(test.testName, \"\\\" took longer than 3000ms, but no timeout was set. Set QUnit.config.testTimeout or call assert.timeout() to avoid a timeout in QUnit 3. https://qunitjs.com/api/config/testTimeout/\"));\n                        }\n                    }, 3000);\n                }\n            }\n            return release;\n        },\n        resolvePromise: function resolvePromise(promise, phase) {\n            if (promise != null) {\n                var _test = this;\n                var then = promise.then;\n                if (typeof then === 'function') {\n                    var resume = _test.internalStop();\n                    var resolve = function resolve() {\n                        resume();\n                    };\n                    if (config.notrycatch) then.call(promise, resolve);\n                    else {\n                        var reject = function reject(error) {\n                            var message = 'Promise rejected ' + (!phase ? 'during' : phase.replace(/Each$/, '')) + ' \"' + _test.testName + '\": ' + (error && error.message || error);\n                            _test.pushFailure(message, extractStacktrace(error, 0));\n                            // Else next test will carry the responsibility\n                            saveGlobal();\n                            // Unblock\n                            internalRecover(_test);\n                        };\n                        then.call(promise, resolve, reject);\n                    }\n                }\n            }\n        },\n        valid: function valid() {\n            // Internally-generated tests are always valid\n            if (this.callback && this.callback.validTest) return true;\n            function moduleChainIdMatch(testModule, selectedId) {\n                return(// undefined or empty array\n                !selectedId || !selectedId.length || inArray(testModule.moduleId, selectedId) || testModule.parentModule && moduleChainIdMatch(testModule.parentModule, selectedId));\n            }\n            if (!moduleChainIdMatch(this.module, config.moduleId)) return false;\n            if (config.testId && config.testId.length && !inArray(this.testId, config.testId)) return false;\n            function moduleChainNameMatch(testModule, selectedModule) {\n                if (!selectedModule) // undefined or empty string\n                return true;\n                var testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n                if (testModuleName === selectedModule) return true;\n                else if (testModule.parentModule) return moduleChainNameMatch(testModule.parentModule, selectedModule);\n                else return false;\n            }\n            var selectedModule = config.module && config.module.toLowerCase();\n            if (!moduleChainNameMatch(this.module, selectedModule)) return false;\n            var filter = config.filter;\n            if (!filter) return true;\n            var regexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec(filter);\n            var fullName = this.module.name + ': ' + this.testName;\n            return regexFilter ? this.regexFilter(!!regexFilter[1], regexFilter[2], regexFilter[3], fullName) : this.stringFilter(filter, fullName);\n        },\n        regexFilter: function regexFilter(exclude, pattern, flags, fullName) {\n            var regex = new RegExp(pattern, flags);\n            var match = regex.test(fullName);\n            return match !== exclude;\n        },\n        stringFilter: function stringFilter(filter, fullName) {\n            filter = filter.toLowerCase();\n            fullName = fullName.toLowerCase();\n            var include = filter.charAt(0) !== '!';\n            if (!include) filter = filter.slice(1);\n            // If the filter matches, we need to honour include\n            if (fullName.indexOf(filter) !== -1) return include;\n            // Otherwise, do the opposite\n            return !include;\n        }\n    };\n    function pushFailure() {\n        if (!config.current) throw new Error('pushFailure() assertion outside test context, in ' + sourceFromStacktrace(2));\n        // Gets current test obj\n        var currentTest = config.current;\n        return currentTest.pushFailure.apply(currentTest, arguments);\n    }\n    function saveGlobal() {\n        config.pollution = [];\n        if (config.noglobals) {\n            for(var key in g)if (hasOwn$1.call(g, key)) {\n                // In Opera sometimes DOM element ids show up here, ignore them\n                if (/^qunit-test-output/.test(key)) continue;\n                config.pollution.push(key);\n            }\n        }\n    }\n    function checkPollution() {\n        var old = config.pollution;\n        saveGlobal();\n        var newGlobals = diff$1(config.pollution, old);\n        if (newGlobals.length > 0) pushFailure('Introduced global variable(s): ' + newGlobals.join(', '));\n        var deletedGlobals = diff$1(old, config.pollution);\n        if (deletedGlobals.length > 0) pushFailure('Deleted global variable(s): ' + deletedGlobals.join(', '));\n    }\n    var focused = false; // indicates that the \"only\" filter was used\n    function addTest(settings) {\n        if (focused || config.currentModule.ignored) return;\n        var newTest = new Test(settings);\n        newTest.queue();\n    }\n    function addOnlyTest(settings) {\n        if (config.currentModule.ignored) return;\n        if (!focused) {\n            config.queue.length = 0;\n            clearSuiteReports(config.currentModule);\n            focused = true;\n        }\n        var newTest = new Test(settings);\n        newTest.queue();\n    }\n    // Will be exposed as QUnit.test\n    function test(testName, callback) {\n        addTest({\n            testName: testName,\n            callback: callback\n        });\n    }\n    function makeEachTestName(testName, argument) {\n        return \"\".concat(testName, \" [\").concat(argument, \"]\");\n    }\n    // Characters to avoid in test names especially CLI/AP output:\n    // * x00-1F: e.g. NULL, backspace (\\b), line breaks (\\r\\n), ESC.\n    // * x74: DEL.\n    // * xA0: non-breaking space.\n    //\n    // See https://en.wikipedia.org/wiki/ASCII#Character_order\n    //\n    // eslint-disable-next-line no-control-regex\n    var rNonObviousStr = /[\\x00-\\x1F\\x7F\\xA0]/;\n    function runEach(data, eachFn) {\n        if (Array.isArray(data)) for(var i = 0; i < data.length; i++){\n            var value = data[i];\n            // Create automatic labels for primitive data in arrays passed to test.each().\n            // We want to avoid the default \"example [0], example [1]\" where possible since\n            // these are not self-explanatory in results, and are also tedious to locate\n            // the source of since the numerical key of an array isn't literally in the\n            // code (you have to count).\n            //\n            // Design requirements:\n            // * Unique. Each label must be unique and correspond 1:1 with a data value.\n            //   This way each test name will hash to a unique testId with Rerun link,\n            //   without having to rely on Test class enforcing uniqueness with invisible\n            //   space hack.\n            // * Unambigious. While technical uniqueness is a hard requirement above,\n            //   we also want the labels to be obvious and unambiguous to humans.\n            //   For example, abbrebating \"foobar\" and \"foobaz\" to \"f\" and \"fo\" is\n            //   technically unique, but ambigious to humans which one is which.\n            // * Short and readable. Where possible we omit the array index numbers\n            //   so that in most cases, the value is simply shown as-is.\n            //   We prefer \"example [foo], example [bar]\"\n            //   over \"example [0: foo], example [2: bar]\".\n            //   This also has the benefit of being stable and robust against e.g.\n            //   re-ordering data or adding new items during development, without\n            //   invalidating a previous filter or rerun link immediately.\n            var valueType = _typeof(value);\n            var testKey = i;\n            if (valueType === 'string' && value.length <= 40 && !rNonObviousStr.test(value) && !/\\s*\\d+: /.test(value)) testKey = value;\n            else if (valueType === 'string' || valueType === 'number' || valueType === 'boolean' || valueType === 'undefined' || value === null) {\n                var valueForName = String(value);\n                if (!rNonObviousStr.test(valueForName)) testKey = i + ': ' + (valueForName.length <= 30 ? valueForName : valueForName.slice(0, 29) + \"\\u2026\");\n            }\n            eachFn(value, testKey);\n        }\n        else if (_typeof(data) === 'object' && data !== null) for(var key in data)eachFn(data[key], key);\n        else throw new Error(\"test.each() expects an array or object as input, but\\nfound \".concat(_typeof(data), \" instead.\"));\n    }\n    extend(test, {\n        todo: function todo(testName, callback) {\n            addTest({\n                testName: testName,\n                callback: callback,\n                todo: true\n            });\n        },\n        skip: function skip(testName) {\n            addTest({\n                testName: testName,\n                skip: true\n            });\n        },\n        if: function _if(testName, condition, callback) {\n            addTest({\n                testName: testName,\n                callback: callback,\n                skip: !condition\n            });\n        },\n        only: function only(testName, callback) {\n            addOnlyTest({\n                testName: testName,\n                callback: callback\n            });\n        },\n        each: function each(testName, dataset, callback) {\n            runEach(dataset, function(data, testKey) {\n                addTest({\n                    testName: makeEachTestName(testName, testKey),\n                    callback: callback,\n                    withData: true,\n                    stackOffset: 5,\n                    data: data\n                });\n            });\n        }\n    });\n    test.todo.each = function(testName, dataset, callback) {\n        runEach(dataset, function(data, testKey) {\n            addTest({\n                testName: makeEachTestName(testName, testKey),\n                callback: callback,\n                todo: true,\n                withData: true,\n                stackOffset: 5,\n                data: data\n            });\n        });\n    };\n    test.skip.each = function(testName, dataset) {\n        runEach(dataset, function(_, testKey) {\n            addTest({\n                testName: makeEachTestName(testName, testKey),\n                stackOffset: 5,\n                skip: true\n            });\n        });\n    };\n    test.if.each = function(testName, condition, dataset, callback) {\n        runEach(dataset, function(data, testKey) {\n            addTest({\n                testName: makeEachTestName(testName, testKey),\n                callback: callback,\n                withData: true,\n                stackOffset: 5,\n                skip: !condition,\n                data: condition ? data : undefined\n            });\n        });\n    };\n    test.only.each = function(testName, dataset, callback) {\n        runEach(dataset, function(data, testKey) {\n            addOnlyTest({\n                testName: makeEachTestName(testName, testKey),\n                callback: callback,\n                withData: true,\n                stackOffset: 5,\n                data: data\n            });\n        });\n    };\n    // Forcefully release all processing holds.\n    function internalRecover(test) {\n        test.pauses.forEach(function(pause) {\n            pause.cancelled = true;\n        });\n        test.pauses.clear();\n        internalStart(test);\n    }\n    // Release a processing hold, scheduling a resumption attempt if no holds remain.\n    function internalStart(test) {\n        // Ignore if other async pauses still exist.\n        if (test.pauses.size > 0) return;\n        // Add a slight delay to allow more assertions etc.\n        if (setTimeout$1) {\n            clearTimeout(config.timeout);\n            config.timeout = setTimeout$1(function() {\n                if (test.pauses.size > 0) return;\n                clearTimeout(config.timeout);\n                config.timeout = null;\n                config.blocking = false;\n                config.pq.advance();\n            });\n        } else {\n            config.blocking = false;\n            config.pq.advance();\n        }\n    }\n    function collectTests(module1) {\n        var tests = [].concat(module1.tests);\n        var modules = _toConsumableArray(module1.childModules);\n        // Do a breadth-first traversal of the child modules\n        while(modules.length){\n            var nextModule = modules.shift();\n            tests.push.apply(tests, nextModule.tests);\n            modules.push.apply(modules, _toConsumableArray(nextModule.childModules));\n        }\n        return tests;\n    }\n    // This returns true after all executable and skippable tests\n    // in a module have been proccessed, and informs 'suiteEnd'\n    // and moduleDone().\n    function allTestsExecuted(module1) {\n        return module1.testsRun + module1.testsIgnored === collectTests(module1).length;\n    }\n    // This returns true during the last executable non-skipped test\n    // within a module, and informs the running of the 'after' hook\n    // for a given module. This runs only once for a given module,\n    // but must run during the last non-skipped test. When it runs,\n    // there may be non-zero skipped tests left.\n    function lastTestWithinModuleExecuted(module1) {\n        return module1.testsRun === collectTests(module1).filter(function(test) {\n            return !test.skip;\n        }).length - 1;\n    }\n    function incrementTestsRun(module1) {\n        module1.testsRun++;\n        while(module1 = module1.parentModule)module1.testsRun++;\n    }\n    function incrementTestsIgnored(module1) {\n        module1.testsIgnored++;\n        while(module1 = module1.parentModule)module1.testsIgnored++;\n    }\n    /* global module, exports, define */ function exportQUnit(QUnit) {\n        var exportedModule = false;\n        if (window$1 && document) {\n            // QUnit may be defined when it is preconfigured but then only QUnit and QUnit.config may be defined.\n            if (window$1.QUnit && window$1.QUnit.version) throw new Error('QUnit has already been defined.');\n            window$1.QUnit = QUnit;\n            exportedModule = true;\n        }\n        // For Node.js\n        if (module && module.exports) {\n            module.exports = QUnit;\n            // For consistency with CommonJS environments' exports\n            module.exports.QUnit = QUnit;\n            exportedModule = true;\n        }\n        // For CommonJS with exports, but without module.exports, like Rhino\n        if (exports) {\n            exports.QUnit = QUnit;\n            exportedModule = true;\n        }\n        // For AMD\n        if (typeof define === 'function' && define.amd) {\n            define(function() {\n                return QUnit;\n            });\n            QUnit.config.autostart = false;\n            exportedModule = true;\n        }\n        // For other environments, including Web Workers (globalThis === self),\n        // SpiderMonkey (mozjs), and other embedded JavaScript engines\n        if (!exportedModule) g.QUnit = QUnit;\n    }\n    var ConsoleReporter = /*#__PURE__*/ function() {\n        function ConsoleReporter(runner) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            _classCallCheck(this, ConsoleReporter);\n            // Cache references to console methods to ensure we can report failures\n            // from tests tests that mock the console object itself.\n            // https://github.com/qunitjs/qunit/issues/1340\n            // Support IE 9: Function#bind is supported, but no console.log.bind().\n            this.log = options.log || Function.prototype.bind.call(console$1.log, console$1);\n            runner.on('error', this.onError.bind(this));\n            runner.on('runStart', this.onRunStart.bind(this));\n            runner.on('testStart', this.onTestStart.bind(this));\n            runner.on('testEnd', this.onTestEnd.bind(this));\n            runner.on('runEnd', this.onRunEnd.bind(this));\n        }\n        return _createClass(ConsoleReporter, [\n            {\n                key: \"onError\",\n                value: function onError(error) {\n                    this.log('error', error);\n                }\n            },\n            {\n                key: \"onRunStart\",\n                value: function onRunStart(runStart) {\n                    this.log('runStart', runStart);\n                }\n            },\n            {\n                key: \"onTestStart\",\n                value: function onTestStart(test) {\n                    this.log('testStart', test);\n                }\n            },\n            {\n                key: \"onTestEnd\",\n                value: function onTestEnd(test) {\n                    this.log('testEnd', test);\n                }\n            },\n            {\n                key: \"onRunEnd\",\n                value: function onRunEnd(runEnd) {\n                    this.log('runEnd', runEnd);\n                }\n            }\n        ], [\n            {\n                key: \"init\",\n                value: function init(runner, options) {\n                    return new ConsoleReporter(runner, options);\n                }\n            }\n        ]);\n    }();\n    // TODO: Consider using globalThis instead of window, so that the reporter\n    // works for Node.js as well. As this can add overhead, we should make\n    // this opt-in before we enable it for CLI.\n    //\n    // QUnit 3 will switch from `window` to `globalThis` and then make it\n    // no longer an implicit feature of the HTML Reporter, but rather let\n    // it be opt-in via `QUnit.config.reporters = ['perf']` or something\n    // like that.\n    var nativePerf = window$1 && typeof window$1.performance !== 'undefined' && // eslint-disable-next-line compat/compat -- Checked\n    typeof window$1.performance.mark === 'function' && // eslint-disable-next-line compat/compat -- Checked\n    typeof window$1.performance.measure === 'function' ? window$1.performance : undefined;\n    var perf = {\n        measure: nativePerf ? function(comment, startMark, endMark) {\n            // `performance.measure` may fail if the mark could not be found.\n            // reasons a specific mark could not be found include: outside code invoking `performance.clearMarks()`\n            try {\n                nativePerf.measure(comment, startMark, endMark);\n            } catch (ex) {\n                Logger.warn('performance.measure could not be executed because of ', ex.message);\n            }\n        } : function() {},\n        mark: nativePerf ? nativePerf.mark.bind(nativePerf) : function() {}\n    };\n    var PerfReporter = /*#__PURE__*/ function() {\n        function PerfReporter(runner) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            _classCallCheck(this, PerfReporter);\n            this.perf = options.perf || perf;\n            runner.on('runStart', this.onRunStart.bind(this));\n            runner.on('runEnd', this.onRunEnd.bind(this));\n            runner.on('suiteStart', this.onSuiteStart.bind(this));\n            runner.on('suiteEnd', this.onSuiteEnd.bind(this));\n            runner.on('testStart', this.onTestStart.bind(this));\n            runner.on('testEnd', this.onTestEnd.bind(this));\n        }\n        return _createClass(PerfReporter, [\n            {\n                key: \"onRunStart\",\n                value: function onRunStart() {\n                    this.perf.mark('qunit_suite_0_start');\n                }\n            },\n            {\n                key: \"onSuiteStart\",\n                value: function onSuiteStart(suiteStart) {\n                    var suiteLevel = suiteStart.fullName.length;\n                    this.perf.mark(\"qunit_suite_\".concat(suiteLevel, \"_start\"));\n                }\n            },\n            {\n                key: \"onSuiteEnd\",\n                value: function onSuiteEnd(suiteEnd) {\n                    var suiteLevel = suiteEnd.fullName.length;\n                    var suiteName = suiteEnd.fullName.join(\" \\u2013 \");\n                    this.perf.mark(\"qunit_suite_\".concat(suiteLevel, \"_end\"));\n                    this.perf.measure(\"QUnit Test Suite: \".concat(suiteName), \"qunit_suite_\".concat(suiteLevel, \"_start\"), \"qunit_suite_\".concat(suiteLevel, \"_end\"));\n                }\n            },\n            {\n                key: \"onTestStart\",\n                value: function onTestStart() {\n                    this.perf.mark('qunit_test_start');\n                }\n            },\n            {\n                key: \"onTestEnd\",\n                value: function onTestEnd(testEnd) {\n                    this.perf.mark('qunit_test_end');\n                    var testName = testEnd.fullName.join(\" \\u2013 \");\n                    this.perf.measure(\"QUnit Test: \".concat(testName), 'qunit_test_start', 'qunit_test_end');\n                }\n            },\n            {\n                key: \"onRunEnd\",\n                value: function onRunEnd() {\n                    this.perf.mark('qunit_suite_0_end');\n                    this.perf.measure('QUnit Test Run', 'qunit_suite_0_start', 'qunit_suite_0_end');\n                }\n            }\n        ], [\n            {\n                key: \"init\",\n                value: function init(runner, options) {\n                    return new PerfReporter(runner, options);\n                }\n            }\n        ]);\n    }();\n    var FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY = true;\n    var _ref;\n    var $ = {\n        enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY),\n        // modifiers\n        reset: init(0, 0),\n        bold: init(1, 22),\n        dim: init(2, 22),\n        italic: init(3, 23),\n        underline: init(4, 24),\n        inverse: init(7, 27),\n        hidden: init(8, 28),\n        strikethrough: init(9, 29),\n        // colors\n        black: init(30, 39),\n        red: init(31, 39),\n        green: init(32, 39),\n        yellow: init(33, 39),\n        blue: init(34, 39),\n        magenta: init(35, 39),\n        cyan: init(36, 39),\n        white: init(37, 39),\n        gray: init(90, 39),\n        grey: init(90, 39),\n        // background colors\n        bgBlack: init(40, 49),\n        bgRed: init(41, 49),\n        bgGreen: init(42, 49),\n        bgYellow: init(43, 49),\n        bgBlue: init(44, 49),\n        bgMagenta: init(45, 49),\n        bgCyan: init(46, 49),\n        bgWhite: init(47, 49)\n    };\n    function run(arr, str) {\n        var i = 0, tmp, beg = '', end = '';\n        for(; i < arr.length; i++){\n            tmp = arr[i];\n            beg += tmp.open;\n            end += tmp.close;\n            if (!!~str.indexOf(tmp.close)) str = str.replace(tmp.rgx, tmp.close + tmp.open);\n        }\n        return beg + str + end;\n    }\n    function chain(has, keys) {\n        var ctx = {\n            has: has,\n            keys: keys\n        };\n        ctx.reset = $.reset.bind(ctx);\n        ctx.bold = $.bold.bind(ctx);\n        ctx.dim = $.dim.bind(ctx);\n        ctx.italic = $.italic.bind(ctx);\n        ctx.underline = $.underline.bind(ctx);\n        ctx.inverse = $.inverse.bind(ctx);\n        ctx.hidden = $.hidden.bind(ctx);\n        ctx.strikethrough = $.strikethrough.bind(ctx);\n        ctx.black = $.black.bind(ctx);\n        ctx.red = $.red.bind(ctx);\n        ctx.green = $.green.bind(ctx);\n        ctx.yellow = $.yellow.bind(ctx);\n        ctx.blue = $.blue.bind(ctx);\n        ctx.magenta = $.magenta.bind(ctx);\n        ctx.cyan = $.cyan.bind(ctx);\n        ctx.white = $.white.bind(ctx);\n        ctx.gray = $.gray.bind(ctx);\n        ctx.grey = $.grey.bind(ctx);\n        ctx.bgBlack = $.bgBlack.bind(ctx);\n        ctx.bgRed = $.bgRed.bind(ctx);\n        ctx.bgGreen = $.bgGreen.bind(ctx);\n        ctx.bgYellow = $.bgYellow.bind(ctx);\n        ctx.bgBlue = $.bgBlue.bind(ctx);\n        ctx.bgMagenta = $.bgMagenta.bind(ctx);\n        ctx.bgCyan = $.bgCyan.bind(ctx);\n        ctx.bgWhite = $.bgWhite.bind(ctx);\n        return ctx;\n    }\n    function init(open, close) {\n        var blk = {\n            open: \"\\x1B[\".concat(open, \"m\"),\n            close: \"\\x1B[\".concat(close, \"m\"),\n            rgx: new RegExp(\"\\\\x1b\\\\[\".concat(close, \"m\"), 'g')\n        };\n        return function(txt) {\n            if (this !== void 0 && this.has !== void 0) {\n                !!~this.has.indexOf(open) || (this.has.push(open), this.keys.push(blk));\n                return txt === void 0 ? this : $.enabled ? run(this.keys, txt + '') : txt + '';\n            }\n            return txt === void 0 ? chain([\n                open\n            ], [\n                blk\n            ]) : $.enabled ? run([\n                blk\n            ], txt + '') : txt + '';\n        };\n    }\n    /**\n   * Format a given value into YAML.\n   *\n   * YAML is a superset of JSON that supports all the same data\n   * types and syntax, and more. As such, it is always possible\n   * to fallback to JSON.stringfify, but we generally avoid\n   * that to make output easier to read for humans.\n   *\n   * Supported data types:\n   *\n   * - null\n   * - boolean\n   * - number\n   * - string\n   * - array\n   * - object\n   *\n   * Anything else (including NaN, Infinity, and undefined)\n   * must be described in strings, for display purposes.\n   *\n   * Note that quotes are optional in YAML strings if the\n   * strings are \"simple\", and as such we generally prefer\n   * that for improved readability. We output strings in\n   * one of three ways:\n   *\n   * - bare unquoted text, for simple one-line strings.\n   * - JSON (quoted text), for complex one-line strings.\n   * - YAML Block, for complex multi-line strings.\n   *\n   * Objects with cyclical references will be stringifed as\n   * \"[Circular]\" as they cannot otherwise be represented.\n   */ function prettyYamlValue(value) {\n        var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n        if (value === undefined) // Not supported in JSON/YAML, turn into string\n        // and let the below output it as bare string.\n        value = String(value);\n        // Support IE 9-11: Use isFinite instead of ES6 Number.isFinite\n        if (typeof value === 'number' && !isFinite(value)) // Turn NaN and Infinity into simple strings.\n        // Paranoia: Don't return directly just in case there's\n        // a way to add special characters here.\n        value = String(value);\n        if (typeof value === 'number') // Simple numbers\n        return JSON.stringify(value);\n        if (typeof value === 'string') {\n            // If any of these match, then we can't output it\n            // as bare unquoted text, because that would either\n            // cause data loss or invalid YAML syntax.\n            //\n            // - Quotes, escapes, line breaks, or JSON-like stuff.\n            // - Not allowed in YAML unquoted strings per https://yaml.org/spec/1.2.2/#733-plain-style\n            //   * \": \" (colon followed by space)\n            //   * \" #\" (space followed by hash)\n            var rSpecialJson = /['\"\\\\/[{}\\]\\r\\n|:#]/;\n            // - Characters that are special at the start of a YAML value\n            var rSpecialYaml = /[-?:,[\\]{}#&*!|=>'\"%@`]/;\n            // - Leading or trailing whitespace.\n            var rUntrimmed = /(^\\s|\\s$)/;\n            // - Ambiguous as YAML number, e.g. '2', '-1.2', '.2', or '2_000'\n            var rNumerical = /^[\\d._-]+$/;\n            // - Ambiguous as YAML bool.\n            //   Use case-insensitive match, although technically only\n            //   fully-lower, fully-upper, or uppercase-first would be ambiguous.\n            //   e.g. true/True/TRUE, but not tRUe.\n            var rBool = /^(true|false|y|n|yes|no|on|off)$/i;\n            // Is this a complex string?\n            if (value === '' || rSpecialJson.test(value) || rSpecialYaml.test(value[0]) || rUntrimmed.test(value) || rNumerical.test(value) || rBool.test(value)) {\n                if (!/\\n/.test(value)) // Complex one-line string, use JSON (quoted string)\n                return JSON.stringify(value);\n                // See also <https://yaml-multiline.info/>\n                // Support IE 9-11: Avoid ES6 String#repeat\n                var _prefix = new Array(indent * 2 + 1).join(' ');\n                var trailingLinebreakMatch = value.match(/\\n+$/);\n                var trailingLinebreaks = trailingLinebreakMatch ? trailingLinebreakMatch[0].length : 0;\n                if (trailingLinebreaks === 1) {\n                    // Use the most straight-forward \"Block\" string in YAML\n                    // without any \"Chomping\" indicators.\n                    var lines = value// Ignore the last new line, since we'll get that one for free\n                    // with the straight-forward Block syntax.\n                    .replace(/\\n$/, '').split('\\n').map(function(line) {\n                        return _prefix + line;\n                    });\n                    return '|\\n' + lines.join('\\n');\n                } else {\n                    // This has either no trailing new lines, or more than 1.\n                    // Use |+ so that YAML parsers will preserve it exactly.\n                    var _lines = value.split('\\n').map(function(line) {\n                        return _prefix + line;\n                    });\n                    return '|+\\n' + _lines.join('\\n');\n                }\n            } else // Simple string, use bare unquoted text\n            return value;\n        }\n        var prefix = new Array(indent + 1).join(' ');\n        // Handle null, boolean, array, and object\n        return JSON.stringify(decycledShallowClone(value), null, 2).split('\\n').map(function(line, i) {\n            return i === 0 ? line : prefix + line;\n        }).join('\\n');\n    }\n    /**\n   * Creates a shallow clone of an object where cycles have\n   * been replaced with \"[Circular]\".\n   */ function decycledShallowClone(object) {\n        var ancestors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        if (ancestors.indexOf(object) !== -1) return '[Circular]';\n        var type = Object.prototype.toString.call(object).replace(/^\\[.+\\s(.+?)]$/, '$1').toLowerCase();\n        var clone;\n        switch(type){\n            case 'array':\n                ancestors.push(object);\n                clone = object.map(function(element) {\n                    return decycledShallowClone(element, ancestors);\n                });\n                ancestors.pop();\n                break;\n            case 'object':\n                ancestors.push(object);\n                clone = {};\n                Object.keys(object).forEach(function(key) {\n                    clone[key] = decycledShallowClone(object[key], ancestors);\n                });\n                ancestors.pop();\n                break;\n            default:\n                clone = object;\n        }\n        return clone;\n    }\n    var TapReporter = /*#__PURE__*/ function() {\n        function TapReporter(runner) {\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            _classCallCheck(this, TapReporter);\n            // Cache references to console methods to ensure we can report failures\n            // from tests tests that mock the console object itself.\n            // https://github.com/qunitjs/qunit/issues/1340\n            // Support IE 9: Function#bind is supported, but no console.log.bind().\n            this.log = options.log || Function.prototype.bind.call(console$1.log, console$1);\n            this.testCount = 0;\n            this.started = false;\n            this.ended = false;\n            this.bailed = false;\n            runner.on('error', this.onError.bind(this));\n            runner.on('runStart', this.onRunStart.bind(this));\n            runner.on('testEnd', this.onTestEnd.bind(this));\n            runner.on('runEnd', this.onRunEnd.bind(this));\n        }\n        return _createClass(TapReporter, [\n            {\n                key: \"onRunStart\",\n                value: function onRunStart(_runSuite) {\n                    if (!this.started) {\n                        this.log('TAP version 13');\n                        this.started = true;\n                    }\n                }\n            },\n            {\n                key: \"onError\",\n                value: function onError(error) {\n                    if (this.bailed) return;\n                    this.bailed = true;\n                    // Imitate onTestEnd\n                    // Skip this if we're past \"runEnd\" as it would look odd\n                    if (!this.ended) {\n                        this.onRunStart();\n                        this.testCount = this.testCount + 1;\n                        this.log(\"not ok \".concat(this.testCount, \" \").concat($.red('global failure')));\n                        this.logError(error);\n                    }\n                    this.log('Bail out! ' + errorString(error).split('\\n')[0]);\n                    if (this.ended) this.logError(error);\n                }\n            },\n            {\n                key: \"onTestEnd\",\n                value: function onTestEnd(test) {\n                    var _this = this;\n                    this.testCount = this.testCount + 1;\n                    if (test.status === 'passed') this.log(\"ok \".concat(this.testCount, \" \").concat(test.fullName.join(' > ')));\n                    else if (test.status === 'skipped') this.log(\"ok \".concat(this.testCount, \" \").concat($.yellow(test.fullName.join(' > ')), \" # SKIP\"));\n                    else if (test.status === 'todo') {\n                        this.log(\"not ok \".concat(this.testCount, \" \").concat($.cyan(test.fullName.join(' > ')), \" # TODO\"));\n                        test.errors.forEach(function(error) {\n                            return _this.logAssertion(error, 'todo');\n                        });\n                    } else {\n                        this.log(\"not ok \".concat(this.testCount, \" \").concat($.red(test.fullName.join(' > '))));\n                        test.errors.forEach(function(error) {\n                            return _this.logAssertion(error);\n                        });\n                    }\n                }\n            },\n            {\n                key: \"onRunEnd\",\n                value: function onRunEnd(runEnd) {\n                    this.ended = true;\n                    this.log(\"1..\".concat(runEnd.testCounts.total));\n                    this.log(\"# pass \".concat(runEnd.testCounts.passed));\n                    this.log(\"# \".concat($.yellow(\"skip \".concat(runEnd.testCounts.skipped))));\n                    this.log(\"# \".concat($.cyan(\"todo \".concat(runEnd.testCounts.todo))));\n                    this.log(\"# \".concat($.red(\"fail \".concat(runEnd.testCounts.failed))));\n                }\n            },\n            {\n                key: \"logAssertion\",\n                value: function logAssertion(error, severity) {\n                    var out = '  ---';\n                    out += \"\\n  message: \".concat(prettyYamlValue(error.message || 'failed'));\n                    out += \"\\n  severity: \".concat(prettyYamlValue(severity || 'failed'));\n                    // When pushFailure() is used, actual/expected are initially unset but\n                    // eventually in Test#logAssertion, for testReport#pushAssertion, these are\n                    // forged into existence as undefined.\n                    var hasAny = error.expected !== undefined || error.actual !== undefined;\n                    if (hasAny) {\n                        out += \"\\n  actual  : \".concat(prettyYamlValue(error.actual));\n                        out += \"\\n  expected: \".concat(prettyYamlValue(error.expected));\n                    }\n                    if (error.stack) {\n                        // Since stacks aren't user generated, take a bit of liberty by\n                        // adding a trailing new line to allow a straight-forward YAML Blocks.\n                        var fmtStack = annotateStacktrace(error.stack, $.grey);\n                        if (fmtStack.length) out += \"\\n  stack: \".concat(prettyYamlValue(fmtStack + '\\n'));\n                    }\n                    out += '\\n  ...';\n                    this.log(out);\n                }\n            },\n            {\n                key: \"logError\",\n                value: function logError(error) {\n                    var out = '  ---';\n                    out += \"\\n  message: \".concat(prettyYamlValue(errorString(error)));\n                    out += \"\\n  severity: \".concat(prettyYamlValue('failed'));\n                    if (error && error.stack) {\n                        var fmtStack = annotateStacktrace(error.stack, $.grey, error.toString());\n                        if (fmtStack.length) out += \"\\n  stack: \".concat(prettyYamlValue(fmtStack + '\\n'));\n                    }\n                    out += '\\n  ...';\n                    this.log(out);\n                }\n            }\n        ], [\n            {\n                key: \"init\",\n                value: function init(runner, options) {\n                    return new TapReporter(runner, options);\n                }\n            }\n        ]);\n    }();\n    var reporters = {\n        console: ConsoleReporter,\n        perf: PerfReporter,\n        tap: TapReporter\n    };\n    function makeAddGlobalHook(hookName) {\n        return function addGlobalHook(callback) {\n            if (!config.globalHooks[hookName]) config.globalHooks[hookName] = [];\n            config.globalHooks[hookName].push(callback);\n        };\n    }\n    var hooks = {\n        beforeEach: makeAddGlobalHook('beforeEach'),\n        afterEach: makeAddGlobalHook('afterEach')\n    };\n    /**\n   * Creates a seeded \"sample\" generator which is used for randomizing tests.\n   */ function unitSamplerGenerator(seed) {\n        // 32-bit xorshift, requires only a nonzero seed\n        // https://excamera.com/sphinx/article-xorshift.html\n        var sample = parseInt(generateHash(seed), 16) || -1;\n        return function() {\n            sample ^= sample << 13;\n            sample ^= sample >>> 17;\n            sample ^= sample << 5;\n            // ECMAScript has no unsigned number type\n            if (sample < 0) sample += 0x100000000;\n            return sample / 0x100000000;\n        };\n    }\n    var ProcessingQueue = /*#__PURE__*/ function() {\n        /**\n     * @param {Function} test Reference to the QUnit.test() method\n     */ function ProcessingQueue(test) {\n            _classCallCheck(this, ProcessingQueue);\n            this.test = test;\n            this.priorityCount = 0;\n            this.unitSampler = null;\n            // This is a queue of functions that are tasks within a single test.\n            // After tests are dequeued from config.queue they are expanded into\n            // a set of tasks in this queue.\n            this.taskQueue = [];\n            this.finished = false;\n        }\n        /**\n     * Advances the taskQueue to the next task. If the taskQueue is empty,\n     * process the testQueue\n     */ return _createClass(ProcessingQueue, [\n            {\n                key: \"advance\",\n                value: function advance() {\n                    this.advanceTaskQueue();\n                    if (!this.taskQueue.length && !config.blocking && !config.current) this.advanceTestQueue();\n                }\n            },\n            {\n                key: \"advanceTaskQueue\",\n                value: function advanceTaskQueue() {\n                    var start = performance.now();\n                    config.depth = (config.depth || 0) + 1;\n                    this.processTaskQueue(start);\n                    config.depth--;\n                }\n            },\n            {\n                key: \"processTaskQueue\",\n                value: function processTaskQueue(start) {\n                    var _this = this;\n                    if (this.taskQueue.length && !config.blocking) {\n                        var elapsedTime = performance.now() - start;\n                        if (!setTimeout$1 || config.updateRate <= 0 || elapsedTime < config.updateRate) {\n                            var task = this.taskQueue.shift();\n                            _Promise.resolve(task()).then(function() {\n                                if (!_this.taskQueue.length) _this.advance();\n                                else _this.processTaskQueue(start);\n                            });\n                        } else setTimeout$1(function() {\n                            _this.advance();\n                        });\n                    }\n                }\n            },\n            {\n                key: \"advanceTestQueue\",\n                value: function advanceTestQueue() {\n                    if (!config.blocking && !config.queue.length && config.depth === 0) {\n                        this.done();\n                        return;\n                    }\n                    var testTasks = config.queue.shift();\n                    this.addToTaskQueue(testTasks());\n                    if (this.priorityCount > 0) this.priorityCount--;\n                    this.advance();\n                }\n            },\n            {\n                key: \"addToTaskQueue\",\n                value: function addToTaskQueue(tasksArray) {\n                    var _this$taskQueue;\n                    (_this$taskQueue = this.taskQueue).push.apply(_this$taskQueue, _toConsumableArray(tasksArray));\n                }\n            },\n            {\n                key: \"taskCount\",\n                value: function taskCount() {\n                    return this.taskQueue.length;\n                }\n            },\n            {\n                key: \"add\",\n                value: function add(testTasksFunc, prioritize) {\n                    if (prioritize) config.queue.splice(this.priorityCount++, 0, testTasksFunc);\n                    else if (config.seed) {\n                        if (!this.unitSampler) this.unitSampler = unitSamplerGenerator(config.seed);\n                        // Insert into a random position after all prioritized items\n                        var index = Math.floor(this.unitSampler() * (config.queue.length - this.priorityCount + 1));\n                        config.queue.splice(this.priorityCount + index, 0, testTasksFunc);\n                    } else config.queue.push(testTasksFunc);\n                }\n            },\n            {\n                key: \"done\",\n                value: function done() {\n                    // We have reached the end of the processing queue and are about to emit the\n                    // \"runEnd\" event after which reporters typically stop listening and exit\n                    // the process. First, check if we need to emit one final test.\n                    if (config.stats.testCount === 0 && config.failOnZeroTests === true) {\n                        var error;\n                        if (config.filter && config.filter.length) error = new Error(\"No tests matched the filter \\\"\".concat(config.filter, \"\\\".\"));\n                        else if (config.module && config.module.length) error = new Error(\"No tests matched the module \\\"\".concat(config.module, \"\\\".\"));\n                        else if (config.moduleId && config.moduleId.length) error = new Error(\"No tests matched the moduleId \\\"\".concat(config.moduleId, \"\\\".\"));\n                        else if (config.testId && config.testId.length) error = new Error(\"No tests matched the testId \\\"\".concat(config.testId, \"\\\".\"));\n                        else error = new Error('No tests were run.');\n                        this.test('global failure', extend(function(assert) {\n                            assert.pushResult({\n                                result: false,\n                                message: error.message,\n                                source: error.stack\n                            });\n                        }, {\n                            validTest: true\n                        }));\n                        // We do need to call `advance()` in order to resume the processing queue.\n                        // Once this new test is finished processing, we'll reach `done` again, and\n                        // that time the above condition will evaluate to false.\n                        this.advance();\n                        return;\n                    }\n                    var storage = config.storage;\n                    var runtime = Math.round(performance.now() - config.started);\n                    var passed = config.stats.all - config.stats.bad;\n                    this.finished = true;\n                    emit('runEnd', runSuite.end(true));\n                    runLoggingCallbacks('done', {\n                        // @deprecated since 2.19.0 Use done() without `details` parameter,\n                        // or use `QUnit.on('runEnd')` instead. Parameter to be replaced in\n                        // QUnit 3.0 with test counts.\n                        passed: passed,\n                        failed: config.stats.bad,\n                        total: config.stats.all,\n                        runtime: runtime\n                    }).then(function() {\n                        // Clear own storage items if all tests passed\n                        if (storage && config.stats.bad === 0) for(var i = storage.length - 1; i >= 0; i--){\n                            var key = storage.key(i);\n                            if (key.indexOf('qunit-test-') === 0) storage.removeItem(key);\n                        }\n                    });\n                }\n            }\n        ]);\n    }();\n    /**\n   * Handle a global error that should result in a failed test run.\n   *\n   * Summary:\n   *\n   * - If we're strictly inside a test (or one if its module hooks), the exception\n   *   becomes a failed assertion.\n   *\n   *   This has the important side-effect that uncaught exceptions (such as\n   *   calling an undefined function) during a \"todo\" test do NOT result in\n   *   a failed test run.\n   *\n   * - If we're anywhere outside a test (be it in early event callbacks, or\n   *   internally between tests, or somewhere after \"runEnd\" if the process is\n   *   still alive for some reason), then send an \"error\" event to the reporters.\n   *\n   * @since 2.17.0\n   * @param {Error|any} error\n   */ function onUncaughtException(error) {\n        if (config.current) // This omits 'actual' and 'expected' (undefined)\n        config.current.assert.pushResult({\n            result: false,\n            message: \"global failure: \".concat(errorString(error)),\n            // We could let callers specify an offset to subtract a number of frames via\n            // sourceFromStacktrace, in case they are a wrapper further away from the error\n            // handler, and thus reduce some noise in the stack trace. However, we're not\n            // doing this right now because it would almost never be used in practice given\n            // the vast majority of error values will be Error objects, and thus have their\n            // own stack trace already.\n            source: error && error.stack || sourceFromStacktrace(2)\n        });\n        else {\n            // The \"error\" event was added in QUnit 2.17.\n            // Increase \"bad assertion\" stats despite no longer pushing an assertion in this case.\n            // This ensures \"runEnd\" and \"QUnit.done()\" handlers behave as expected, since the \"bad\"\n            // count is typically how reporters decide on the boolean outcome of the test run.\n            runSuite.globalFailureCount++;\n            config.stats.bad++;\n            config.stats.all++;\n            emit('error', error);\n        }\n    }\n    /**\n   * Handle a window.onerror error.\n   *\n   * If there is a current test that sets the internal `ignoreGlobalErrors` field\n   * (such as during `assert.throws()`), then the error is ignored and native\n   * error reporting is suppressed as well. This is because in browsers, an error\n   * can sometimes end up in `window.onerror` instead of in the local try/catch.\n   * This ignoring of errors does not apply to our general onUncaughtException\n   * method, nor to our `unhandledRejection` handlers, as those are not meant\n   * to receive an \"expected\" error during `assert.throws()`.\n   *\n   * @see <https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror>\n   * @deprecated since 2.17.0 Use QUnit.onUncaughtException instead.\n   * @param {Object} details\n   * @param {string} details.message\n   * @param {string} details.fileName\n   * @param {number} details.lineNumber\n   * @param {string|undefined} [details.stacktrace]\n   * @return {bool} True if native error reporting should be suppressed.\n   */ function onWindowError(details) {\n        Logger.warn(\"QUnit.onError is deprecated and will be removed in QUnit 3.0. Please use QUnit.onUncaughtException instead.\");\n        if (config.current && config.current.ignoreGlobalErrors) return true;\n        var err = new Error(details.message);\n        err.stack = details.stacktrace || details.fileName + ':' + details.lineNumber;\n        onUncaughtException(err);\n        return false;\n    }\n    /* eslint-disable indent */ /*\n   * This file is a modified version of google-diff-match-patch's JavaScript implementation\n   * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n   * modifications are licensed as more fully set forth in LICENSE.txt.\n   *\n   * The original source of google-diff-match-patch is attributable and licensed as follows:\n   *\n   * Copyright 2006 Google Inc.\n   * https://code.google.com/p/google-diff-match-patch/\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   * https://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * More Info:\n   *  https://code.google.com/p/google-diff-match-patch/\n   *\n   * Usage: QUnit.diff(expected, actual)\n   *\n   */ function DiffMatchPatch() {}\n    //  DIFF FUNCTIONS\n    /**\n   * The data structure representing a diff is an array of tuples:\n   * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n   * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n   */ var DIFF_DELETE = -1;\n    var DIFF_INSERT = 1;\n    var DIFF_EQUAL = 0;\n    var hasOwn = Object.prototype.hasOwnProperty;\n    /**\n   * Find the differences between two texts.  Simplifies the problem by stripping\n   * any common prefix or suffix off the texts before diffing.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n   *     then don't run a line-level diff first to identify the changed areas.\n   *     Defaults to true, which does a faster, slightly less optimal diff.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   */ DiffMatchPatch.prototype.DiffMain = function(text1, text2, optChecklines) {\n        // The diff must be complete in up to 1 second.\n        var deadline = Date.now() + 1000;\n        // Check for null inputs.\n        if (text1 === null || text2 === null) throw new Error('Cannot diff null input.');\n        // Check for equality (speedup).\n        if (text1 === text2) {\n            if (text1) return [\n                [\n                    DIFF_EQUAL,\n                    text1\n                ]\n            ];\n            return [];\n        }\n        if (typeof optChecklines === 'undefined') optChecklines = true;\n        // Trim off common prefix (speedup).\n        var commonlength = this.diffCommonPrefix(text1, text2);\n        var commonprefix = text1.substring(0, commonlength);\n        text1 = text1.substring(commonlength);\n        text2 = text2.substring(commonlength);\n        // Trim off common suffix (speedup).\n        commonlength = this.diffCommonSuffix(text1, text2);\n        var commonsuffix = text1.substring(text1.length - commonlength);\n        text1 = text1.substring(0, text1.length - commonlength);\n        text2 = text2.substring(0, text2.length - commonlength);\n        // Compute the diff on the middle block.\n        var diffs = this.diffCompute(text1, text2, optChecklines, deadline);\n        // Restore the prefix and suffix.\n        if (commonprefix) diffs.unshift([\n            DIFF_EQUAL,\n            commonprefix\n        ]);\n        if (commonsuffix) diffs.push([\n            DIFF_EQUAL,\n            commonsuffix\n        ]);\n        this.diffCleanupMerge(diffs);\n        return diffs;\n    };\n    /**\n   * Reduce the number of edits by eliminating operationally trivial equalities.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   */ DiffMatchPatch.prototype.diffCleanupEfficiency = function(diffs) {\n        var changes, equalities, equalitiesLength, lastequality, pointer, preIns, preDel, postIns, postDel;\n        changes = false;\n        equalities = []; // Stack of indices where equalities are found.\n        equalitiesLength = 0; // Keeping our own length var is faster in JS.\n        /** @type {?string} */ lastequality = null;\n        // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n        pointer = 0; // Index of current position.\n        // Is there an insertion operation before the last equality.\n        preIns = false;\n        // Is there a deletion operation before the last equality.\n        preDel = false;\n        // Is there an insertion operation after the last equality.\n        postIns = false;\n        // Is there a deletion operation after the last equality.\n        postDel = false;\n        while(pointer < diffs.length){\n            // Equality found.\n            if (diffs[pointer][0] === DIFF_EQUAL) {\n                if (diffs[pointer][1].length < 4 && (postIns || postDel)) {\n                    // Candidate found.\n                    equalities[equalitiesLength++] = pointer;\n                    preIns = postIns;\n                    preDel = postDel;\n                    lastequality = diffs[pointer][1];\n                } else {\n                    // Not a candidate, and can never become one.\n                    equalitiesLength = 0;\n                    lastequality = null;\n                }\n                postIns = postDel = false;\n            // An insertion or deletion.\n            } else {\n                if (diffs[pointer][0] === DIFF_DELETE) postDel = true;\n                else postIns = true;\n                /*\n         * Five types to be split:\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\n         * <ins>A</del>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<del>C</del>\n         */ if (lastequality && (preIns && preDel && postIns && postDel || lastequality.length < 2 && preIns + preDel + postIns + postDel === 3)) {\n                    // Duplicate record.\n                    diffs.splice(equalities[equalitiesLength - 1], 0, [\n                        DIFF_DELETE,\n                        lastequality\n                    ]);\n                    // Change second copy to insert.\n                    diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n                    equalitiesLength--; // Throw away the equality we just deleted;\n                    lastequality = null;\n                    if (preIns && preDel) {\n                        // No changes made which could affect previous entry, keep going.\n                        postIns = postDel = true;\n                        equalitiesLength = 0;\n                    } else {\n                        equalitiesLength--; // Throw away the previous equality.\n                        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n                        postIns = postDel = false;\n                    }\n                    changes = true;\n                }\n            }\n            pointer++;\n        }\n        if (changes) this.diffCleanupMerge(diffs);\n    };\n    /**\n   * Convert a diff array into a pretty HTML report.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   * @param {integer} string to be beautified.\n   * @return {string} HTML representation.\n   */ DiffMatchPatch.prototype.diffPrettyHtml = function(diffs) {\n        var html = [];\n        for(var x = 0; x < diffs.length; x++){\n            var op = diffs[x][0]; // Operation (insert, delete, equal)\n            var data = diffs[x][1]; // Text of change.\n            switch(op){\n                case DIFF_INSERT:\n                    html[x] = '<ins>' + escapeText(data) + '</ins>';\n                    break;\n                case DIFF_DELETE:\n                    html[x] = '<del>' + escapeText(data) + '</del>';\n                    break;\n                case DIFF_EQUAL:\n                    html[x] = '<span>' + escapeText(data) + '</span>';\n                    break;\n            }\n        }\n        return html.join('');\n    };\n    /**\n   * Determine the common prefix of two strings.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {number} The number of characters common to the start of each\n   *     string.\n   */ DiffMatchPatch.prototype.diffCommonPrefix = function(text1, text2) {\n        var pointermid, pointermax, pointermin, pointerstart;\n        // Quick check for common null cases.\n        if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) return 0;\n        // Binary search.\n        // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n        pointermin = 0;\n        pointermax = Math.min(text1.length, text2.length);\n        pointermid = pointermax;\n        pointerstart = 0;\n        while(pointermin < pointermid){\n            if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {\n                pointermin = pointermid;\n                pointerstart = pointermin;\n            } else pointermax = pointermid;\n            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n        }\n        return pointermid;\n    };\n    /**\n   * Determine the common suffix of two strings.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {number} The number of characters common to the end of each string.\n   */ DiffMatchPatch.prototype.diffCommonSuffix = function(text1, text2) {\n        var pointermid, pointermax, pointermin, pointerend;\n        // Quick check for common null cases.\n        if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) return 0;\n        // Binary search.\n        // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n        pointermin = 0;\n        pointermax = Math.min(text1.length, text2.length);\n        pointermid = pointermax;\n        pointerend = 0;\n        while(pointermin < pointermid){\n            if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n                pointermin = pointermid;\n                pointerend = pointermin;\n            } else pointermax = pointermid;\n            pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n        }\n        return pointermid;\n    };\n    /**\n   * Find the differences between two texts.  Assumes that the texts do not\n   * have any common prefix or suffix.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {boolean} checklines Speedup flag.  If false, then don't run a\n   *     line-level diff first to identify the changed areas.\n   *     If true, then run a faster, slightly less optimal diff.\n   * @param {number} deadline Time when the diff should be complete by.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   * @private\n   */ DiffMatchPatch.prototype.diffCompute = function(text1, text2, checklines, deadline) {\n        var diffs, longtext, shorttext, i, hm, text1A, text2A, text1B, text2B, midCommon, diffsA, diffsB;\n        if (!text1) // Just add some text (speedup).\n        return [\n            [\n                DIFF_INSERT,\n                text2\n            ]\n        ];\n        if (!text2) // Just delete some text (speedup).\n        return [\n            [\n                DIFF_DELETE,\n                text1\n            ]\n        ];\n        longtext = text1.length > text2.length ? text1 : text2;\n        shorttext = text1.length > text2.length ? text2 : text1;\n        i = longtext.indexOf(shorttext);\n        if (i !== -1) {\n            // Shorter text is inside the longer text (speedup).\n            diffs = [\n                [\n                    DIFF_INSERT,\n                    longtext.substring(0, i)\n                ],\n                [\n                    DIFF_EQUAL,\n                    shorttext\n                ],\n                [\n                    DIFF_INSERT,\n                    longtext.substring(i + shorttext.length)\n                ]\n            ];\n            // Swap insertions for deletions if diff is reversed.\n            if (text1.length > text2.length) diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n            return diffs;\n        }\n        if (shorttext.length === 1) // Single character string.\n        // After the previous speedup, the character can't be an equality.\n        return [\n            [\n                DIFF_DELETE,\n                text1\n            ],\n            [\n                DIFF_INSERT,\n                text2\n            ]\n        ];\n        // Check to see if the problem can be split in two.\n        hm = this.diffHalfMatch(text1, text2);\n        if (hm) {\n            // A half-match was found, sort out the return data.\n            text1A = hm[0];\n            text1B = hm[1];\n            text2A = hm[2];\n            text2B = hm[3];\n            midCommon = hm[4];\n            // Send both pairs off for separate processing.\n            diffsA = this.DiffMain(text1A, text2A, checklines, deadline);\n            diffsB = this.DiffMain(text1B, text2B, checklines, deadline);\n            // Merge the results.\n            return diffsA.concat([\n                [\n                    DIFF_EQUAL,\n                    midCommon\n                ]\n            ], diffsB);\n        }\n        if (checklines && text1.length > 100 && text2.length > 100) return this.diffLineMode(text1, text2, deadline);\n        return this.diffBisect(text1, text2, deadline);\n    };\n    /**\n   * Do the two texts share a substring which is at least half the length of the\n   * longer text?\n   * This speedup can produce non-minimal diffs.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     text1, the suffix of text1, the prefix of text2, the suffix of\n   *     text2 and the common middle.  Or null if there was no match.\n   * @private\n   */ DiffMatchPatch.prototype.diffHalfMatch = function(text1, text2) {\n        var longtext, shorttext, dmp, text1A, text2B, text2A, text1B, midCommon, hm1, hm2, hm;\n        longtext = text1.length > text2.length ? text1 : text2;\n        shorttext = text1.length > text2.length ? text2 : text1;\n        if (longtext.length < 4 || shorttext.length * 2 < longtext.length) return null; // Pointless.\n        dmp = this; // 'this' becomes 'window' in a closure.\n        /**\n     * Does a substring of shorttext exist within longtext such that the substring\n     * is at least half the length of longtext?\n     * Closure, but does not reference any external variables.\n     * @param {string} longtext Longer string.\n     * @param {string} shorttext Shorter string.\n     * @param {number} i Start index of quarter length substring within longtext.\n     * @return {Array.<string>} Five element Array, containing the prefix of\n     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n     *     of shorttext and the common middle.  Or null if there was no match.\n     * @private\n     */ function diffHalfMatchI(longtext, shorttext, i) {\n            var seed, j, bestCommon, prefixLength, suffixLength, bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n            // Start with a 1/4 length substring at position i as a seed.\n            seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n            j = -1;\n            bestCommon = '';\n            while((j = shorttext.indexOf(seed, j + 1)) !== -1){\n                prefixLength = dmp.diffCommonPrefix(longtext.substring(i), shorttext.substring(j));\n                suffixLength = dmp.diffCommonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\n                if (bestCommon.length < suffixLength + prefixLength) {\n                    bestCommon = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n                    bestLongtextA = longtext.substring(0, i - suffixLength);\n                    bestLongtextB = longtext.substring(i + prefixLength);\n                    bestShorttextA = shorttext.substring(0, j - suffixLength);\n                    bestShorttextB = shorttext.substring(j + prefixLength);\n                }\n            }\n            if (bestCommon.length * 2 >= longtext.length) return [\n                bestLongtextA,\n                bestLongtextB,\n                bestShorttextA,\n                bestShorttextB,\n                bestCommon\n            ];\n            else return null;\n        }\n        // First check if the second quarter is the seed for a half-match.\n        hm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));\n        // Check again based on the third quarter.\n        hm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));\n        if (!hm1 && !hm2) return null;\n        else if (!hm2) hm = hm1;\n        else if (!hm1) hm = hm2;\n        else // Both matched.  Select the longest.\n        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n        // A half-match was found, sort out the return data.\n        if (text1.length > text2.length) {\n            text1A = hm[0];\n            text1B = hm[1];\n            text2A = hm[2];\n            text2B = hm[3];\n        } else {\n            text2A = hm[0];\n            text2B = hm[1];\n            text1A = hm[2];\n            text1B = hm[3];\n        }\n        midCommon = hm[4];\n        return [\n            text1A,\n            text1B,\n            text2A,\n            text2B,\n            midCommon\n        ];\n    };\n    /**\n   * Do a quick line-level diff on both strings, then rediff the parts for\n   * greater accuracy.\n   * This speedup can produce non-minimal diffs.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {number} deadline Time when the diff should be complete by.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   * @private\n   */ DiffMatchPatch.prototype.diffLineMode = function(text1, text2, deadline) {\n        var a, diffs, linearray, pointer, countInsert, countDelete, textInsert, textDelete, j;\n        // Scan the text on a line-by-line basis first.\n        a = this.diffLinesToChars(text1, text2);\n        text1 = a.chars1;\n        text2 = a.chars2;\n        linearray = a.lineArray;\n        diffs = this.DiffMain(text1, text2, false, deadline);\n        // Convert the diff back to original text.\n        this.diffCharsToLines(diffs, linearray);\n        // Eliminate freak matches (e.g. blank lines)\n        this.diffCleanupSemantic(diffs);\n        // Rediff any replacement blocks, this time character-by-character.\n        // Add a dummy entry at the end.\n        diffs.push([\n            DIFF_EQUAL,\n            ''\n        ]);\n        pointer = 0;\n        countDelete = 0;\n        countInsert = 0;\n        textDelete = '';\n        textInsert = '';\n        while(pointer < diffs.length){\n            switch(diffs[pointer][0]){\n                case DIFF_INSERT:\n                    countInsert++;\n                    textInsert += diffs[pointer][1];\n                    break;\n                case DIFF_DELETE:\n                    countDelete++;\n                    textDelete += diffs[pointer][1];\n                    break;\n                case DIFF_EQUAL:\n                    // Upon reaching an equality, check for prior redundancies.\n                    if (countDelete >= 1 && countInsert >= 1) {\n                        // Delete the offending records and add the merged ones.\n                        diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);\n                        pointer = pointer - countDelete - countInsert;\n                        a = this.DiffMain(textDelete, textInsert, false, deadline);\n                        for(j = a.length - 1; j >= 0; j--)diffs.splice(pointer, 0, a[j]);\n                        pointer = pointer + a.length;\n                    }\n                    countInsert = 0;\n                    countDelete = 0;\n                    textDelete = '';\n                    textInsert = '';\n                    break;\n            }\n            pointer++;\n        }\n        diffs.pop(); // Remove the dummy entry at the end.\n        return diffs;\n    };\n    /**\n   * Find the 'middle snake' of a diff, split the problem in two\n   * and return the recursively constructed diff.\n   * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {number} deadline Time at which to bail if not yet complete.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   * @private\n   */ DiffMatchPatch.prototype.diffBisect = function(text1, text2, deadline) {\n        var text1Length, text2Length, maxD, vOffset, vLength, v1, v2, x, delta, front, k1start, k1end, k2start, k2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n        // Cache the text lengths to prevent multiple calls.\n        text1Length = text1.length;\n        text2Length = text2.length;\n        maxD = Math.ceil((text1Length + text2Length) / 2);\n        vOffset = maxD;\n        vLength = 2 * maxD;\n        v1 = new Array(vLength);\n        v2 = new Array(vLength);\n        // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n        // integers and undefined.\n        for(x = 0; x < vLength; x++){\n            v1[x] = -1;\n            v2[x] = -1;\n        }\n        v1[vOffset + 1] = 0;\n        v2[vOffset + 1] = 0;\n        delta = text1Length - text2Length;\n        // If the total number of characters is odd, then the front path will collide\n        // with the reverse path.\n        front = delta % 2 !== 0;\n        // Offsets for start and end of k loop.\n        // Prevents mapping of space beyond the grid.\n        k1start = 0;\n        k1end = 0;\n        k2start = 0;\n        k2end = 0;\n        for(d = 0; d < maxD; d++){\n            // Bail out if deadline is reached.\n            if (Date.now() > deadline) break;\n            // Walk the front path one step.\n            for(k1 = -d + k1start; k1 <= d - k1end; k1 += 2){\n                k1Offset = vOffset + k1;\n                if (k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1]) x1 = v1[k1Offset + 1];\n                else x1 = v1[k1Offset - 1] + 1;\n                y1 = x1 - k1;\n                while(x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)){\n                    x1++;\n                    y1++;\n                }\n                v1[k1Offset] = x1;\n                if (x1 > text1Length) // Ran off the right of the graph.\n                k1end += 2;\n                else if (y1 > text2Length) // Ran off the bottom of the graph.\n                k1start += 2;\n                else if (front) {\n                    k2Offset = vOffset + delta - k1;\n                    if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n                        // Mirror x2 onto top-left coordinate system.\n                        x2 = text1Length - v2[k2Offset];\n                        if (x1 >= x2) // Overlap detected.\n                        return this.diffBisectSplit(text1, text2, x1, y1, deadline);\n                    }\n                }\n            }\n            // Walk the reverse path one step.\n            for(k2 = -d + k2start; k2 <= d - k2end; k2 += 2){\n                k2Offset = vOffset + k2;\n                if (k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1]) x2 = v2[k2Offset + 1];\n                else x2 = v2[k2Offset - 1] + 1;\n                y2 = x2 - k2;\n                while(x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)){\n                    x2++;\n                    y2++;\n                }\n                v2[k2Offset] = x2;\n                if (x2 > text1Length) // Ran off the left of the graph.\n                k2end += 2;\n                else if (y2 > text2Length) // Ran off the top of the graph.\n                k2start += 2;\n                else if (!front) {\n                    k1Offset = vOffset + delta - k2;\n                    if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n                        x1 = v1[k1Offset];\n                        y1 = vOffset + x1 - k1Offset;\n                        // Mirror x2 onto top-left coordinate system.\n                        x2 = text1Length - x2;\n                        if (x1 >= x2) // Overlap detected.\n                        return this.diffBisectSplit(text1, text2, x1, y1, deadline);\n                    }\n                }\n            }\n        }\n        // Diff took too long and hit the deadline or\n        // number of diffs equals number of characters, no commonality at all.\n        return [\n            [\n                DIFF_DELETE,\n                text1\n            ],\n            [\n                DIFF_INSERT,\n                text2\n            ]\n        ];\n    };\n    /**\n   * Given the location of the 'middle snake', split the diff in two parts\n   * and recurse.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {number} x Index of split point in text1.\n   * @param {number} y Index of split point in text2.\n   * @param {number} deadline Time at which to bail if not yet complete.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   * @private\n   */ DiffMatchPatch.prototype.diffBisectSplit = function(text1, text2, x, y, deadline) {\n        var text1a, text1b, text2a, text2b, diffs, diffsb;\n        text1a = text1.substring(0, x);\n        text2a = text2.substring(0, y);\n        text1b = text1.substring(x);\n        text2b = text2.substring(y);\n        // Compute both diffs serially.\n        diffs = this.DiffMain(text1a, text2a, false, deadline);\n        diffsb = this.DiffMain(text1b, text2b, false, deadline);\n        return diffs.concat(diffsb);\n    };\n    /**\n   * Reduce the number of edits by eliminating semantically trivial equalities.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   */ DiffMatchPatch.prototype.diffCleanupSemantic = function(diffs) {\n        var changes = false;\n        var equalities = []; // Stack of indices where equalities are found.\n        var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n        /** @type {?string} */ var lastequality = null;\n        // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n        var pointer = 0; // Index of current position.\n        // Number of characters that changed prior to the equality.\n        var lengthInsertions1 = 0;\n        var lengthDeletions1 = 0;\n        // Number of characters that changed after the equality.\n        var lengthInsertions2 = 0;\n        var lengthDeletions2 = 0;\n        while(pointer < diffs.length){\n            if (diffs[pointer][0] === DIFF_EQUAL) {\n                // Equality found.\n                equalities[equalitiesLength++] = pointer;\n                lengthInsertions1 = lengthInsertions2;\n                lengthDeletions1 = lengthDeletions2;\n                lengthInsertions2 = 0;\n                lengthDeletions2 = 0;\n                lastequality = diffs[pointer][1];\n            } else {\n                // An insertion or deletion.\n                if (diffs[pointer][0] === DIFF_INSERT) lengthInsertions2 += diffs[pointer][1].length;\n                else lengthDeletions2 += diffs[pointer][1].length;\n                // Eliminate an equality that is smaller or equal to the edits on both\n                // sides of it.\n                if (lastequality && lastequality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastequality.length <= Math.max(lengthInsertions2, lengthDeletions2)) {\n                    // Duplicate record.\n                    diffs.splice(equalities[equalitiesLength - 1], 0, [\n                        DIFF_DELETE,\n                        lastequality\n                    ]);\n                    // Change second copy to insert.\n                    diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n                    // Throw away the equality we just deleted.\n                    equalitiesLength--;\n                    // Throw away the previous equality (it needs to be reevaluated).\n                    equalitiesLength--;\n                    pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n                    // Reset the counters.\n                    lengthInsertions1 = 0;\n                    lengthDeletions1 = 0;\n                    lengthInsertions2 = 0;\n                    lengthDeletions2 = 0;\n                    lastequality = null;\n                    changes = true;\n                }\n            }\n            pointer++;\n        }\n        // Normalize the diff.\n        if (changes) this.diffCleanupMerge(diffs);\n        var deletion, insertion, overlapLength1, overlapLength2;\n        // Find any overlaps between deletions and insertions.\n        // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n        //   -> <del>abc</del>xxx<ins>def</ins>\n        // e.g: <del>xxxabc</del><ins>defxxx</ins>\n        //   -> <ins>def</ins>xxx<del>abc</del>\n        // Only extract an overlap if it is as big as the edit ahead or behind it.\n        pointer = 1;\n        while(pointer < diffs.length){\n            if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n                deletion = diffs[pointer - 1][1];\n                insertion = diffs[pointer][1];\n                overlapLength1 = this.diffCommonOverlap(deletion, insertion);\n                overlapLength2 = this.diffCommonOverlap(insertion, deletion);\n                if (overlapLength1 >= overlapLength2) {\n                    if (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {\n                        // Overlap found.  Insert an equality and trim the surrounding edits.\n                        diffs.splice(pointer, 0, [\n                            DIFF_EQUAL,\n                            insertion.substring(0, overlapLength1)\n                        ]);\n                        diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);\n                        diffs[pointer + 1][1] = insertion.substring(overlapLength1);\n                        pointer++;\n                    }\n                } else if (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {\n                    // Reverse overlap found.\n                    // Insert an equality and swap and trim the surrounding edits.\n                    diffs.splice(pointer, 0, [\n                        DIFF_EQUAL,\n                        deletion.substring(0, overlapLength2)\n                    ]);\n                    diffs[pointer - 1][0] = DIFF_INSERT;\n                    diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);\n                    diffs[pointer + 1][0] = DIFF_DELETE;\n                    diffs[pointer + 1][1] = deletion.substring(overlapLength2);\n                    pointer++;\n                }\n                pointer++;\n            }\n            pointer++;\n        }\n    };\n    /**\n   * Determine if the suffix of one string is the prefix of another.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {number} The number of characters common to the end of the first\n   *     string and the start of the second string.\n   * @private\n   */ DiffMatchPatch.prototype.diffCommonOverlap = function(text1, text2) {\n        // Cache the text lengths to prevent multiple calls.\n        var text1Length = text1.length;\n        var text2Length = text2.length;\n        // Eliminate the null case.\n        if (text1Length === 0 || text2Length === 0) return 0;\n        // Truncate the longer string.\n        if (text1Length > text2Length) text1 = text1.substring(text1Length - text2Length);\n        else if (text1Length < text2Length) text2 = text2.substring(0, text1Length);\n        var textLength = Math.min(text1Length, text2Length);\n        // Quick check for the worst case.\n        if (text1 === text2) return textLength;\n        // Start by looking for a single character match\n        // and increase length until no match is found.\n        // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n        var best = 0;\n        var length = 1;\n        while(true){\n            var pattern = text1.substring(textLength - length);\n            var found = text2.indexOf(pattern);\n            if (found === -1) return best;\n            length += found;\n            if (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) {\n                best = length;\n                length++;\n            }\n        }\n    };\n    /**\n   * Split two texts into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n   *     An object containing the encoded text1, the encoded text2 and\n   *     the array of unique strings.\n   *     The zeroth element of the array of unique strings is intentionally blank.\n   * @private\n   */ DiffMatchPatch.prototype.diffLinesToChars = function(text1, text2) {\n        var lineArray = []; // E.g. lineArray[4] === 'Hello\\n'\n        var lineHash = {}; // E.g. lineHash['Hello\\n'] === 4\n        // '\\x00' is a valid character, but various debuggers don't like it.\n        // So we'll insert a junk entry to avoid generating a null character.\n        lineArray[0] = '';\n        /**\n     * Split a text into an array of strings.  Reduce the texts to a string of\n     * hashes where each Unicode character represents one line.\n     * Modifies linearray and linehash through being a closure.\n     * @param {string} text String to encode.\n     * @return {string} Encoded string.\n     * @private\n     */ function diffLinesToCharsMunge(text) {\n            var chars = '';\n            // Walk the text, pulling out a substring for each line.\n            // text.split('\\n') would would temporarily double our memory footprint.\n            // Modifying text would create many large strings to garbage collect.\n            var lineStart = 0;\n            var lineEnd = -1;\n            // Keeping our own length variable is faster than looking it up.\n            var lineArrayLength = lineArray.length;\n            while(lineEnd < text.length - 1){\n                lineEnd = text.indexOf('\\n', lineStart);\n                if (lineEnd === -1) lineEnd = text.length - 1;\n                var line = text.substring(lineStart, lineEnd + 1);\n                lineStart = lineEnd + 1;\n                if (hasOwn.call(lineHash, line)) chars += String.fromCharCode(lineHash[line]);\n                else {\n                    chars += String.fromCharCode(lineArrayLength);\n                    lineHash[line] = lineArrayLength;\n                    lineArray[lineArrayLength++] = line;\n                }\n            }\n            return chars;\n        }\n        var chars1 = diffLinesToCharsMunge(text1);\n        var chars2 = diffLinesToCharsMunge(text2);\n        return {\n            chars1: chars1,\n            chars2: chars2,\n            lineArray: lineArray\n        };\n    };\n    /**\n   * Rehydrate the text in a diff from a string of line hashes to real lines of\n   * text.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   * @param {!Array.<string>} lineArray Array of unique strings.\n   * @private\n   */ DiffMatchPatch.prototype.diffCharsToLines = function(diffs, lineArray) {\n        for(var x = 0; x < diffs.length; x++){\n            var chars = diffs[x][1];\n            var text = [];\n            for(var y = 0; y < chars.length; y++)text[y] = lineArray[chars.charCodeAt(y)];\n            diffs[x][1] = text.join('');\n        }\n    };\n    /**\n   * Reorder and merge like edit sections.  Merge equalities.\n   * Any edit section can move as long as it doesn't cross an equality.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   */ DiffMatchPatch.prototype.diffCleanupMerge = function(diffs) {\n        diffs.push([\n            DIFF_EQUAL,\n            ''\n        ]); // Add a dummy entry at the end.\n        var pointer = 0;\n        var countDelete = 0;\n        var countInsert = 0;\n        var textDelete = '';\n        var textInsert = '';\n        while(pointer < diffs.length)switch(diffs[pointer][0]){\n            case DIFF_INSERT:\n                countInsert++;\n                textInsert += diffs[pointer][1];\n                pointer++;\n                break;\n            case DIFF_DELETE:\n                countDelete++;\n                textDelete += diffs[pointer][1];\n                pointer++;\n                break;\n            case DIFF_EQUAL:\n                // Upon reaching an equality, check for prior redundancies.\n                if (countDelete + countInsert > 1) {\n                    if (countDelete !== 0 && countInsert !== 0) {\n                        // Factor out any common prefixes.\n                        var commonlength = this.diffCommonPrefix(textInsert, textDelete);\n                        if (commonlength !== 0) {\n                            if (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL) diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength);\n                            else {\n                                diffs.splice(0, 0, [\n                                    DIFF_EQUAL,\n                                    textInsert.substring(0, commonlength)\n                                ]);\n                                pointer++;\n                            }\n                            textInsert = textInsert.substring(commonlength);\n                            textDelete = textDelete.substring(commonlength);\n                        }\n                        // Factor out any common suffixies.\n                        commonlength = this.diffCommonSuffix(textInsert, textDelete);\n                        if (commonlength !== 0) {\n                            diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1];\n                            textInsert = textInsert.substring(0, textInsert.length - commonlength);\n                            textDelete = textDelete.substring(0, textDelete.length - commonlength);\n                        }\n                    }\n                    // Delete the offending records and add the merged ones.\n                    if (countDelete === 0) diffs.splice(pointer - countInsert, countDelete + countInsert, [\n                        DIFF_INSERT,\n                        textInsert\n                    ]);\n                    else if (countInsert === 0) diffs.splice(pointer - countDelete, countDelete + countInsert, [\n                        DIFF_DELETE,\n                        textDelete\n                    ]);\n                    else diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert, [\n                        DIFF_DELETE,\n                        textDelete\n                    ], [\n                        DIFF_INSERT,\n                        textInsert\n                    ]);\n                    pointer = pointer - countDelete - countInsert + (countDelete ? 1 : 0) + (countInsert ? 1 : 0) + 1;\n                } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n                    // Merge this equality with the previous one.\n                    diffs[pointer - 1][1] += diffs[pointer][1];\n                    diffs.splice(pointer, 1);\n                } else pointer++;\n                countInsert = 0;\n                countDelete = 0;\n                textDelete = '';\n                textInsert = '';\n                break;\n        }\n        if (diffs[diffs.length - 1][1] === '') diffs.pop(); // Remove the dummy entry at the end.\n        // Second pass: look for single edits surrounded on both sides by equalities\n        // which can be shifted sideways to eliminate an equality.\n        // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n        var changes = false;\n        pointer = 1;\n        // Intentionally ignore the first and last element (don't need checking).\n        while(pointer < diffs.length - 1){\n            if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n                var diffPointer = diffs[pointer][1];\n                var position = diffPointer.substring(diffPointer.length - diffs[pointer - 1][1].length);\n                // This is a single edit surrounded by equalities.\n                if (position === diffs[pointer - 1][1]) {\n                    // Shift the edit over the previous equality.\n                    diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n                    diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n                    diffs.splice(pointer - 1, 1);\n                    changes = true;\n                } else if (diffPointer.substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {\n                    // Shift the edit over the next equality.\n                    diffs[pointer - 1][1] += diffs[pointer + 1][1];\n                    diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n                    diffs.splice(pointer + 1, 1);\n                    changes = true;\n                }\n            }\n            pointer++;\n        }\n        // If shifts were made, the diff needs reordering and another shift sweep.\n        if (changes) this.diffCleanupMerge(diffs);\n    };\n    function diff(o, n) {\n        var diff, output, text;\n        diff = new DiffMatchPatch();\n        output = diff.DiffMain(o, n);\n        diff.diffCleanupEfficiency(output);\n        text = diff.diffPrettyHtml(output);\n        return text;\n    }\n    var QUnit = {};\n    // The \"currentModule\" object would ideally be defined using the createModule()\n    // function. Since it isn't, add the missing suiteReport property to it now that\n    // we have loaded all source code required to do so.\n    //\n    // TODO: Consider defining currentModule in core.js or module.js in its entirely\n    // rather than partly in config.js and partly here.\n    config.currentModule.suiteReport = runSuite;\n    config.pq = new ProcessingQueue(test);\n    var globalStartCalled = false;\n    var runStarted = false;\n    // Figure out if we're running the tests from a server or not\n    QUnit.isLocal = window$1 && window$1.location && window$1.location.protocol === 'file:';\n    // Expose the current QUnit version\n    QUnit.version = '2.24.3';\n    extend(QUnit, {\n        config: config,\n        diff: diff,\n        dump: dump,\n        equiv: equiv,\n        reporters: reporters,\n        hooks: hooks,\n        is: is,\n        objectType: objectType,\n        on: on,\n        onError: onWindowError,\n        onUncaughtException: onUncaughtException,\n        pushFailure: pushFailure,\n        assert: Assert.prototype,\n        module: module$1,\n        test: test,\n        // alias other test flavors for easy access\n        todo: test.todo,\n        skip: test.skip,\n        only: test.only,\n        start: function start(count) {\n            if (config.current) throw new Error('QUnit.start cannot be called inside a test context.');\n            var globalStartAlreadyCalled = globalStartCalled;\n            globalStartCalled = true;\n            if (runStarted) throw new Error('Called start() while test already started running');\n            if (globalStartAlreadyCalled || count > 1) throw new Error('Called start() outside of a test context too many times');\n            if (config.autostart) throw new Error(\"Called start() outside of a test context when QUnit.config.autostart was true\");\n            // Until we remove QUnit.load() in QUnit 3, we keep `pageLoaded`.\n            // It no longer serves any purpose other than to support old test runners\n            // that still call only QUnit.load(), or that call both it and QUnit.start().\n            if (!config.pageLoaded) {\n                // If the test runner used `autostart = false` and is calling QUnit.start()\n                // to tell is their resources are ready, but the browser isn't ready yet,\n                // then enable autostart now, and we'll let the tests really start after\n                // the browser's \"load\" event handler calls autostart().\n                config.autostart = true;\n                // If we're in Node or another non-browser environment, we start now as there\n                // won't be any \"load\" event. We return early either way since autostart\n                // is responsible for calling scheduleBegin (avoid \"beginning\" twice).\n                if (!document) QUnit.autostart();\n                return;\n            }\n            scheduleBegin();\n        },\n        onUnhandledRejection: function onUnhandledRejection(reason) {\n            Logger.warn(\"QUnit.onUnhandledRejection is deprecated and will be removed in QUnit 3.0. Please use QUnit.onUncaughtException instead.\");\n            onUncaughtException(reason);\n        },\n        extend: function extend$1() {\n            Logger.warn(\"QUnit.extend is deprecated and will be removed in QUnit 3.0. Please use Object.assign instead.\");\n            // delegate to utility implementation, which does not warn and can be used elsewhere internally\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];\n            return extend.apply(this, args);\n        },\n        load: function load() {\n            Logger.warn(\"QUnit.load is deprecated and will be removed in QUnit 3.0. https://qunitjs.com/api/QUnit/load/\");\n            QUnit.autostart();\n        },\n        /**\n     * @internal\n     */ autostart: function autostart() {\n            config.pageLoaded = true;\n            // Initialize the configuration options\n            // TODO: Move this to config.js in QUnit 3.\n            extend(config, {\n                started: 0,\n                updateRate: 1000,\n                autostart: true,\n                filter: ''\n            }, true);\n            if (!runStarted) {\n                config.blocking = false;\n                if (config.autostart) scheduleBegin();\n            }\n        },\n        stack: function stack(offset) {\n            offset = (offset || 0) + 2;\n            // Support Safari: Use temp variable to avoid TCO for consistent cross-browser result\n            // https://bugs.webkit.org/show_bug.cgi?id=276187\n            var source = sourceFromStacktrace(offset);\n            return source;\n        }\n    });\n    registerLoggingCallbacks(QUnit);\n    function scheduleBegin() {\n        runStarted = true;\n        // Add a slight delay to allow definition of more modules and tests.\n        if (setTimeout$1) setTimeout$1(function() {\n            begin();\n        });\n        else begin();\n    }\n    function unblockAndAdvanceQueue() {\n        config.blocking = false;\n        config.pq.advance();\n    }\n    function begin() {\n        if (config.started) {\n            unblockAndAdvanceQueue();\n            return;\n        }\n        // QUnit.config.reporters is considered writable between qunit.js and QUnit.start().\n        // Now that QUnit.start() has been called, it is time to decide which built-in reporters\n        // to load.\n        if (config.reporters.console) reporters.console.init(QUnit);\n        if (config.reporters.tap) reporters.tap.init(QUnit);\n        // The test run hasn't officially begun yet\n        // Record the time of the test run's beginning\n        config.started = performance.now();\n        // Delete the loose unnamed module if unused.\n        if (config.modules[0].name === '' && config.modules[0].tests.length === 0) config.modules.shift();\n        var modulesLog = [];\n        for(var i = 0; i < config.modules.length; i++)// Don't expose the unnamed global test module to plugins.\n        if (config.modules[i].name !== '') modulesLog.push({\n            name: config.modules[i].name,\n            moduleId: config.modules[i].moduleId,\n            // Added in QUnit 1.16.0 for internal use by html-reporter,\n            // but no longer used since QUnit 2.7.0.\n            // @deprecated Kept unofficially to be removed in QUnit 3.0.\n            tests: config.modules[i].tests\n        });\n        // The test run is officially beginning now\n        emit('runStart', runSuite.start(true));\n        runLoggingCallbacks('begin', {\n            totalTests: Test.count,\n            modules: modulesLog\n        }).then(unblockAndAdvanceQueue);\n    }\n    exportQUnit(QUnit);\n    (function() {\n        if (!window$1 || !document) return;\n        var config = QUnit.config;\n        var hasOwn = Object.prototype.hasOwnProperty;\n        // Stores fixture HTML for resetting later\n        function storeFixture() {\n            // Avoid overwriting user-defined values\n            // TODO: Change to negative null/undefined check once declared in /src/config.js\n            if (hasOwn.call(config, 'fixture')) return;\n            var fixture = document.getElementById('qunit-fixture');\n            if (fixture) config.fixture = fixture.cloneNode(true);\n        }\n        QUnit.begin(storeFixture);\n        // Resets the fixture DOM element if available.\n        function resetFixture() {\n            if (config.fixture == null) return;\n            var fixture = document.getElementById('qunit-fixture');\n            var resetFixtureType = _typeof(config.fixture);\n            if (resetFixtureType === 'string') {\n                // support user defined values for `config.fixture`\n                var newFixture = document.createElement('div');\n                newFixture.setAttribute('id', 'qunit-fixture');\n                newFixture.innerHTML = config.fixture;\n                fixture.parentNode.replaceChild(newFixture, fixture);\n            } else {\n                var clonedFixture = config.fixture.cloneNode(true);\n                fixture.parentNode.replaceChild(clonedFixture, fixture);\n            }\n        }\n        QUnit.testStart(resetFixture);\n    })();\n    (function() {\n        // Only interact with URLs via window.location\n        var location = typeof window$1 !== 'undefined' && window$1.location;\n        if (!location) return;\n        var urlParams = getUrlParams();\n        // TODO: Move to /src/core/ in QUnit 3\n        // TODO: Document this as public API (read-only)\n        QUnit.urlParams = urlParams;\n        // TODO: Move to /src/core/config.js in QUnit 3,\n        // in accordance with /docs/api/config.index.md#order\n        QUnit.config.filter = urlParams.filter;\n        // NOTE: Based on readFlatPreconfigNumber from QUnit 3.\n        if (/^[0-9]+$/.test(urlParams.maxDepth)) QUnit.config.maxDepth = QUnit.dump.maxDepth = +urlParams.maxDepth;\n        QUnit.config.module = urlParams.module;\n        QUnit.config.moduleId = [].concat(urlParams.moduleId || []);\n        QUnit.config.testId = [].concat(urlParams.testId || []);\n        // Test order randomization\n        // Generate a random seed if `?seed` is specified without a value (boolean true),\n        // or when set to the string \"true\".\n        if (urlParams.seed === 'true' || urlParams.seed === true) // NOTE: This duplicates logic from /src/core/config.js. Consolidated in QUnit 3.\n        QUnit.config.seed = (Math.random().toString(36) + '0000000000').slice(2, 12);\n        else if (urlParams.seed) QUnit.config.seed = urlParams.seed;\n        // Add URL-parameter-mapped config values with UI form rendering data\n        QUnit.config.urlConfig.push({\n            id: 'hidepassed',\n            label: 'Hide passed tests',\n            tooltip: 'Only show tests and assertions that fail. Stored as query-strings.'\n        }, {\n            id: 'noglobals',\n            label: 'Check for Globals',\n            tooltip: \"Enabling this will test if any test introduces new properties on the global object (`window` in Browsers). Stored as query-strings.\"\n        }, {\n            id: 'notrycatch',\n            label: 'No try-catch',\n            tooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging exceptions in IE reasonable. Stored as query-strings.\"\n        });\n        QUnit.begin(function() {\n            var urlConfig = QUnit.config.urlConfig;\n            for(var i = 0; i < urlConfig.length; i++){\n                // Options can be either strings or objects with nonempty \"id\" properties\n                var option = QUnit.config.urlConfig[i];\n                if (typeof option !== 'string') option = option.id;\n                if (QUnit.config[option] === undefined) QUnit.config[option] = urlParams[option];\n            }\n        });\n        function getUrlParams() {\n            var urlParams = Object.create(null);\n            var params = location.search.slice(1).split('&');\n            var length = params.length;\n            for(var i = 0; i < length; i++)if (params[i]) {\n                var param = params[i].split('=');\n                var name = decodeQueryParam(param[0]);\n                // Allow just a key to turn on a flag, e.g., test.html?noglobals\n                var value = param.length === 1 || decodeQueryParam(param.slice(1).join('='));\n                if (name in urlParams) urlParams[name] = [].concat(urlParams[name], value);\n                else urlParams[name] = value;\n            }\n            return urlParams;\n        }\n        function decodeQueryParam(param) {\n            return decodeURIComponent(param.replace(/\\+/g, '%20'));\n        }\n    })();\n    var fuzzysort$1 = {\n        exports: {}\n    };\n    (function(module1) {\n        (function(root, UMD) {\n            if (module1.exports) module1.exports = UMD();\n            else root.fuzzysort = UMD();\n        })(commonjsGlobal, function UMD() {\n            function fuzzysortNew(instanceOptions) {\n                var fuzzysort = {\n                    single: function single(search, target, options) {\n                        if (search == 'farzher') return {\n                            target: \"farzher was here (^-^*)/\",\n                            score: 0,\n                            indexes: [\n                                0,\n                                1,\n                                2,\n                                3,\n                                4,\n                                5,\n                                6\n                            ]\n                        };\n                        if (!search) return null;\n                        if (!isObj(search)) search = fuzzysort.getPreparedSearch(search);\n                        if (!target) return null;\n                        if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                        var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n                        var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n                        return algorithm(search, target, search[0]);\n                    },\n                    go: function go(search, targets, options) {\n                        if (search == 'farzher') return [\n                            {\n                                target: \"farzher was here (^-^*)/\",\n                                score: 0,\n                                indexes: [\n                                    0,\n                                    1,\n                                    2,\n                                    3,\n                                    4,\n                                    5,\n                                    6\n                                ],\n                                obj: targets ? targets[0] : null\n                            }\n                        ];\n                        if (!search) return noResults;\n                        search = fuzzysort.prepareSearch(search);\n                        var searchLowerCode = search[0];\n                        var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;\n                        var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;\n                        var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n                        var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n                        var resultsLen = 0;\n                        var limitedCount = 0;\n                        var targetsLen = targets.length;\n                        // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n                        // options.keys\n                        if (options && options.keys) {\n                            var scoreFn = options.scoreFn || defaultScoreFn;\n                            var keys = options.keys;\n                            var keysLen = keys.length;\n                            for(var i = targetsLen - 1; i >= 0; --i){\n                                var obj = targets[i];\n                                var objResults = new Array(keysLen);\n                                for(var keyI = keysLen - 1; keyI >= 0; --keyI){\n                                    var key = keys[keyI];\n                                    var target = getValue(obj, key);\n                                    if (!target) {\n                                        objResults[keyI] = null;\n                                        continue;\n                                    }\n                                    if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                                    objResults[keyI] = algorithm(search, target, searchLowerCode);\n                                }\n                                objResults.obj = obj; // before scoreFn so scoreFn can use it\n                                var score = scoreFn(objResults);\n                                if (score === null) continue;\n                                if (score < threshold) continue;\n                                objResults.score = score;\n                                if (resultsLen < limit) {\n                                    q.add(objResults);\n                                    ++resultsLen;\n                                } else {\n                                    ++limitedCount;\n                                    if (score > q.peek().score) q.replaceTop(objResults);\n                                }\n                            }\n                        // options.key\n                        } else if (options && options.key) {\n                            var key = options.key;\n                            for(var i = targetsLen - 1; i >= 0; --i){\n                                var obj = targets[i];\n                                var target = getValue(obj, key);\n                                if (!target) continue;\n                                if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                                var result = algorithm(search, target, searchLowerCode);\n                                if (result === null) continue;\n                                if (result.score < threshold) continue;\n                                // have to clone result so duplicate targets from different obj can each reference the correct obj\n                                result = {\n                                    target: result.target,\n                                    _targetLowerCodes: null,\n                                    _nextBeginningIndexes: null,\n                                    score: result.score,\n                                    indexes: result.indexes,\n                                    obj: obj\n                                }; // hidden\n                                if (resultsLen < limit) {\n                                    q.add(result);\n                                    ++resultsLen;\n                                } else {\n                                    ++limitedCount;\n                                    if (result.score > q.peek().score) q.replaceTop(result);\n                                }\n                            }\n                        // no keys\n                        } else for(var i = targetsLen - 1; i >= 0; --i){\n                            var target = targets[i];\n                            if (!target) continue;\n                            if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                            var result = algorithm(search, target, searchLowerCode);\n                            if (result === null) continue;\n                            if (result.score < threshold) continue;\n                            if (resultsLen < limit) {\n                                q.add(result);\n                                ++resultsLen;\n                            } else {\n                                ++limitedCount;\n                                if (result.score > q.peek().score) q.replaceTop(result);\n                            }\n                        }\n                        if (resultsLen === 0) return noResults;\n                        var results = new Array(resultsLen);\n                        for(var i = resultsLen - 1; i >= 0; --i)results[i] = q.poll();\n                        results.total = resultsLen + limitedCount;\n                        return results;\n                    },\n                    goAsync: function goAsync(search, targets, options) {\n                        var canceled = false;\n                        var p = new Promise(function(resolve, reject) {\n                            if (search == 'farzher') return resolve([\n                                {\n                                    target: \"farzher was here (^-^*)/\",\n                                    score: 0,\n                                    indexes: [\n                                        0,\n                                        1,\n                                        2,\n                                        3,\n                                        4,\n                                        5,\n                                        6\n                                    ],\n                                    obj: targets ? targets[0] : null\n                                }\n                            ]);\n                            if (!search) return resolve(noResults);\n                            search = fuzzysort.prepareSearch(search);\n                            var searchLowerCode = search[0];\n                            var q = fastpriorityqueue();\n                            var iCurrent = targets.length - 1;\n                            var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;\n                            var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;\n                            var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n                            var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n                            var resultsLen = 0;\n                            var limitedCount = 0;\n                            function step() {\n                                if (canceled) return reject('canceled');\n                                var startMs = Date.now();\n                                // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n                                // options.keys\n                                if (options && options.keys) {\n                                    var scoreFn = options.scoreFn || defaultScoreFn;\n                                    var keys = options.keys;\n                                    var keysLen = keys.length;\n                                    for(; iCurrent >= 0; --iCurrent){\n                                        if (iCurrent % 1000 /*itemsPerCheck*/  === 0) {\n                                            if (Date.now() - startMs >= 10 /*asyncInterval*/ ) {\n                                                isNode ? setImmediate(step) : setTimeout(step);\n                                                return;\n                                            }\n                                        }\n                                        var obj = targets[iCurrent];\n                                        var objResults = new Array(keysLen);\n                                        for(var keyI = keysLen - 1; keyI >= 0; --keyI){\n                                            var key = keys[keyI];\n                                            var target = getValue(obj, key);\n                                            if (!target) {\n                                                objResults[keyI] = null;\n                                                continue;\n                                            }\n                                            if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                                            objResults[keyI] = algorithm(search, target, searchLowerCode);\n                                        }\n                                        objResults.obj = obj; // before scoreFn so scoreFn can use it\n                                        var score = scoreFn(objResults);\n                                        if (score === null) continue;\n                                        if (score < threshold) continue;\n                                        objResults.score = score;\n                                        if (resultsLen < limit) {\n                                            q.add(objResults);\n                                            ++resultsLen;\n                                        } else {\n                                            ++limitedCount;\n                                            if (score > q.peek().score) q.replaceTop(objResults);\n                                        }\n                                    }\n                                // options.key\n                                } else if (options && options.key) {\n                                    var key = options.key;\n                                    for(; iCurrent >= 0; --iCurrent){\n                                        if (iCurrent % 1000 /*itemsPerCheck*/  === 0) {\n                                            if (Date.now() - startMs >= 10 /*asyncInterval*/ ) {\n                                                isNode ? setImmediate(step) : setTimeout(step);\n                                                return;\n                                            }\n                                        }\n                                        var obj = targets[iCurrent];\n                                        var target = getValue(obj, key);\n                                        if (!target) continue;\n                                        if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                                        var result = algorithm(search, target, searchLowerCode);\n                                        if (result === null) continue;\n                                        if (result.score < threshold) continue;\n                                        // have to clone result so duplicate targets from different obj can each reference the correct obj\n                                        result = {\n                                            target: result.target,\n                                            _targetLowerCodes: null,\n                                            _nextBeginningIndexes: null,\n                                            score: result.score,\n                                            indexes: result.indexes,\n                                            obj: obj\n                                        }; // hidden\n                                        if (resultsLen < limit) {\n                                            q.add(result);\n                                            ++resultsLen;\n                                        } else {\n                                            ++limitedCount;\n                                            if (result.score > q.peek().score) q.replaceTop(result);\n                                        }\n                                    }\n                                // no keys\n                                } else for(; iCurrent >= 0; --iCurrent){\n                                    if (iCurrent % 1000 /*itemsPerCheck*/  === 0) {\n                                        if (Date.now() - startMs >= 10 /*asyncInterval*/ ) {\n                                            isNode ? setImmediate(step) : setTimeout(step);\n                                            return;\n                                        }\n                                    }\n                                    var target = targets[iCurrent];\n                                    if (!target) continue;\n                                    if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                                    var result = algorithm(search, target, searchLowerCode);\n                                    if (result === null) continue;\n                                    if (result.score < threshold) continue;\n                                    if (resultsLen < limit) {\n                                        q.add(result);\n                                        ++resultsLen;\n                                    } else {\n                                        ++limitedCount;\n                                        if (result.score > q.peek().score) q.replaceTop(result);\n                                    }\n                                }\n                                if (resultsLen === 0) return resolve(noResults);\n                                var results = new Array(resultsLen);\n                                for(var i = resultsLen - 1; i >= 0; --i)results[i] = q.poll();\n                                results.total = resultsLen + limitedCount;\n                                resolve(results);\n                            }\n                            isNode ? setImmediate(step) : step(); //setTimeout here is too slow\n                        });\n                        p.cancel = function() {\n                            canceled = true;\n                        };\n                        return p;\n                    },\n                    highlight: function highlight(result, hOpen, hClose) {\n                        if (typeof hOpen == 'function') return fuzzysort.highlightCallback(result, hOpen);\n                        if (result === null) return null;\n                        if (hOpen === undefined) hOpen = '<b>';\n                        if (hClose === undefined) hClose = '</b>';\n                        var highlighted = '';\n                        var matchesIndex = 0;\n                        var opened = false;\n                        var target = result.target;\n                        var targetLen = target.length;\n                        var matchesBest = result.indexes;\n                        for(var i = 0; i < targetLen; ++i){\n                            var char = target[i];\n                            if (matchesBest[matchesIndex] === i) {\n                                ++matchesIndex;\n                                if (!opened) {\n                                    opened = true;\n                                    highlighted += hOpen;\n                                }\n                                if (matchesIndex === matchesBest.length) {\n                                    highlighted += char + hClose + target.substr(i + 1);\n                                    break;\n                                }\n                            } else if (opened) {\n                                opened = false;\n                                highlighted += hClose;\n                            }\n                            highlighted += char;\n                        }\n                        return highlighted;\n                    },\n                    highlightCallback: function highlightCallback(result, cb) {\n                        if (result === null) return null;\n                        var target = result.target;\n                        var targetLen = target.length;\n                        var indexes = result.indexes;\n                        var highlighted = '';\n                        var matchI = 0;\n                        var indexesI = 0;\n                        var opened = false;\n                        var result = [];\n                        for(var i = 0; i < targetLen; ++i){\n                            var char = target[i];\n                            if (indexes[indexesI] === i) {\n                                ++indexesI;\n                                if (!opened) {\n                                    opened = true;\n                                    result.push(highlighted);\n                                    highlighted = '';\n                                }\n                                if (indexesI === indexes.length) {\n                                    highlighted += char;\n                                    result.push(cb(highlighted, matchI++));\n                                    highlighted = '';\n                                    result.push(target.substr(i + 1));\n                                    break;\n                                }\n                            } else if (opened) {\n                                opened = false;\n                                result.push(cb(highlighted, matchI++));\n                                highlighted = '';\n                            }\n                            highlighted += char;\n                        }\n                        return result;\n                    },\n                    prepare: function prepare(target) {\n                        if (!target) return {\n                            target: '',\n                            _targetLowerCodes: [\n                                0 /*this 0 doesn't make sense. here because an empty array causes the algorithm to deoptimize and run 50% slower!*/ \n                            ],\n                            _nextBeginningIndexes: null,\n                            score: null,\n                            indexes: null,\n                            obj: null\n                        }; // hidden\n                        return {\n                            target: target,\n                            _targetLowerCodes: fuzzysort.prepareLowerCodes(target),\n                            _nextBeginningIndexes: null,\n                            score: null,\n                            indexes: null,\n                            obj: null\n                        }; // hidden\n                    },\n                    prepareSlow: function prepareSlow(target) {\n                        if (!target) return {\n                            target: '',\n                            _targetLowerCodes: [\n                                0 /*this 0 doesn't make sense. here because an empty array causes the algorithm to deoptimize and run 50% slower!*/ \n                            ],\n                            _nextBeginningIndexes: null,\n                            score: null,\n                            indexes: null,\n                            obj: null\n                        }; // hidden\n                        return {\n                            target: target,\n                            _targetLowerCodes: fuzzysort.prepareLowerCodes(target),\n                            _nextBeginningIndexes: fuzzysort.prepareNextBeginningIndexes(target),\n                            score: null,\n                            indexes: null,\n                            obj: null\n                        }; // hidden\n                    },\n                    prepareSearch: function prepareSearch(search) {\n                        if (!search) search = '';\n                        return fuzzysort.prepareLowerCodes(search);\n                    },\n                    // Below this point is only internal code\n                    // Below this point is only internal code\n                    // Below this point is only internal code\n                    // Below this point is only internal code\n                    getPrepared: function getPrepared(target) {\n                        if (target.length > 999) return fuzzysort.prepare(target); // don't cache huge targets\n                        var targetPrepared = preparedCache.get(target);\n                        if (targetPrepared !== undefined) return targetPrepared;\n                        targetPrepared = fuzzysort.prepare(target);\n                        preparedCache.set(target, targetPrepared);\n                        return targetPrepared;\n                    },\n                    getPreparedSearch: function getPreparedSearch(search) {\n                        if (search.length > 999) return fuzzysort.prepareSearch(search); // don't cache huge searches\n                        var searchPrepared = preparedSearchCache.get(search);\n                        if (searchPrepared !== undefined) return searchPrepared;\n                        searchPrepared = fuzzysort.prepareSearch(search);\n                        preparedSearchCache.set(search, searchPrepared);\n                        return searchPrepared;\n                    },\n                    algorithm: function algorithm(searchLowerCodes, prepared, searchLowerCode) {\n                        var targetLowerCodes = prepared._targetLowerCodes;\n                        var searchLen = searchLowerCodes.length;\n                        var targetLen = targetLowerCodes.length;\n                        var searchI = 0; // where we at\n                        var targetI = 0; // where you at\n                        var typoSimpleI = 0;\n                        var matchesSimpleLen = 0;\n                        // very basic fuzzy match; to remove non-matching targets ASAP!\n                        // walk through target. find sequential matches.\n                        // if all chars aren't found then exit\n                        for(;;){\n                            var isMatch = searchLowerCode === targetLowerCodes[targetI];\n                            if (isMatch) {\n                                matchesSimple[matchesSimpleLen++] = targetI;\n                                ++searchI;\n                                if (searchI === searchLen) break;\n                                searchLowerCode = searchLowerCodes[typoSimpleI === 0 ? searchI : typoSimpleI === searchI ? searchI + 1 : typoSimpleI === searchI - 1 ? searchI - 1 : searchI];\n                            }\n                            ++targetI;\n                            if (targetI >= targetLen) // Failed to find searchI\n                            // Check for typo or exit\n                            // we go as far as possible before trying to transpose\n                            // then we transpose backwards until we reach the beginning\n                            for(;;){\n                                if (searchI <= 1) return null; // not allowed to transpose first char\n                                if (typoSimpleI === 0) {\n                                    // we haven't tried to transpose yet\n                                    --searchI;\n                                    var searchLowerCodeNew = searchLowerCodes[searchI];\n                                    if (searchLowerCode === searchLowerCodeNew) continue; // doesn't make sense to transpose a repeat char\n                                    typoSimpleI = searchI;\n                                } else {\n                                    if (typoSimpleI === 1) return null; // reached the end of the line for transposing\n                                    --typoSimpleI;\n                                    searchI = typoSimpleI;\n                                    searchLowerCode = searchLowerCodes[searchI + 1];\n                                    var searchLowerCodeNew = searchLowerCodes[searchI];\n                                    if (searchLowerCode === searchLowerCodeNew) continue; // doesn't make sense to transpose a repeat char\n                                }\n                                matchesSimpleLen = searchI;\n                                targetI = matchesSimple[matchesSimpleLen - 1] + 1;\n                                break;\n                            }\n                        }\n                        var searchI = 0;\n                        var typoStrictI = 0;\n                        var successStrict = false;\n                        var matchesStrictLen = 0;\n                        var nextBeginningIndexes = prepared._nextBeginningIndexes;\n                        if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);\n                        var firstPossibleI = targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1];\n                        // Our target string successfully matched all characters in sequence!\n                        // Let's try a more advanced and strict test to improve the score\n                        // only count it as a match if it's consecutive or a beginning character!\n                        if (targetI !== targetLen) for(;;)if (targetI >= targetLen) {\n                            // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n                            if (searchI <= 0) {\n                                // We failed to push chars forward for a better match\n                                // transpose, starting from the beginning\n                                ++typoStrictI;\n                                if (typoStrictI > searchLen - 2) break;\n                                if (searchLowerCodes[typoStrictI] === searchLowerCodes[typoStrictI + 1]) continue; // doesn't make sense to transpose a repeat char\n                                targetI = firstPossibleI;\n                                continue;\n                            }\n                            --searchI;\n                            var lastMatch = matchesStrict[--matchesStrictLen];\n                            targetI = nextBeginningIndexes[lastMatch];\n                        } else {\n                            var isMatch = searchLowerCodes[typoStrictI === 0 ? searchI : typoStrictI === searchI ? searchI + 1 : typoStrictI === searchI - 1 ? searchI - 1 : searchI] === targetLowerCodes[targetI];\n                            if (isMatch) {\n                                matchesStrict[matchesStrictLen++] = targetI;\n                                ++searchI;\n                                if (searchI === searchLen) {\n                                    successStrict = true;\n                                    break;\n                                }\n                                ++targetI;\n                            } else targetI = nextBeginningIndexes[targetI];\n                        }\n                        // tally up the score & keep track of matches for highlighting later\n                        if (successStrict) {\n                            var matchesBest = matchesStrict;\n                            var matchesBestLen = matchesStrictLen;\n                        } else {\n                            var matchesBest = matchesSimple;\n                            var matchesBestLen = matchesSimpleLen;\n                        }\n                        var score = 0;\n                        var lastTargetI = -1;\n                        for(var i = 0; i < searchLen; ++i){\n                            var targetI = matchesBest[i];\n                            // score only goes down if they're not consecutive\n                            if (lastTargetI !== targetI - 1) score -= targetI;\n                            lastTargetI = targetI;\n                        }\n                        if (!successStrict) {\n                            score *= 1000;\n                            if (typoSimpleI !== 0) score += -20; /*typoPenalty*/ \n                        } else if (typoStrictI !== 0) score += -20; /*typoPenalty*/ \n                        score -= targetLen - searchLen;\n                        prepared.score = score;\n                        prepared.indexes = new Array(matchesBestLen);\n                        for(var i = matchesBestLen - 1; i >= 0; --i)prepared.indexes[i] = matchesBest[i];\n                        return prepared;\n                    },\n                    algorithmNoTypo: function algorithmNoTypo(searchLowerCodes, prepared, searchLowerCode) {\n                        var targetLowerCodes = prepared._targetLowerCodes;\n                        var searchLen = searchLowerCodes.length;\n                        var targetLen = targetLowerCodes.length;\n                        var searchI = 0; // where we at\n                        var targetI = 0; // where you at\n                        var matchesSimpleLen = 0;\n                        // very basic fuzzy match; to remove non-matching targets ASAP!\n                        // walk through target. find sequential matches.\n                        // if all chars aren't found then exit\n                        for(;;){\n                            var isMatch = searchLowerCode === targetLowerCodes[targetI];\n                            if (isMatch) {\n                                matchesSimple[matchesSimpleLen++] = targetI;\n                                ++searchI;\n                                if (searchI === searchLen) break;\n                                searchLowerCode = searchLowerCodes[searchI];\n                            }\n                            ++targetI;\n                            if (targetI >= targetLen) return null; // Failed to find searchI\n                        }\n                        var searchI = 0;\n                        var successStrict = false;\n                        var matchesStrictLen = 0;\n                        var nextBeginningIndexes = prepared._nextBeginningIndexes;\n                        if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);\n                        targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1];\n                        // Our target string successfully matched all characters in sequence!\n                        // Let's try a more advanced and strict test to improve the score\n                        // only count it as a match if it's consecutive or a beginning character!\n                        if (targetI !== targetLen) for(;;)if (targetI >= targetLen) {\n                            // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n                            if (searchI <= 0) break; // We failed to push chars forward for a better match\n                            --searchI;\n                            var lastMatch = matchesStrict[--matchesStrictLen];\n                            targetI = nextBeginningIndexes[lastMatch];\n                        } else {\n                            var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI];\n                            if (isMatch) {\n                                matchesStrict[matchesStrictLen++] = targetI;\n                                ++searchI;\n                                if (searchI === searchLen) {\n                                    successStrict = true;\n                                    break;\n                                }\n                                ++targetI;\n                            } else targetI = nextBeginningIndexes[targetI];\n                        }\n                        // tally up the score & keep track of matches for highlighting later\n                        if (successStrict) {\n                            var matchesBest = matchesStrict;\n                            var matchesBestLen = matchesStrictLen;\n                        } else {\n                            var matchesBest = matchesSimple;\n                            var matchesBestLen = matchesSimpleLen;\n                        }\n                        var score = 0;\n                        var lastTargetI = -1;\n                        for(var i = 0; i < searchLen; ++i){\n                            var targetI = matchesBest[i];\n                            // score only goes down if they're not consecutive\n                            if (lastTargetI !== targetI - 1) score -= targetI;\n                            lastTargetI = targetI;\n                        }\n                        if (!successStrict) score *= 1000;\n                        score -= targetLen - searchLen;\n                        prepared.score = score;\n                        prepared.indexes = new Array(matchesBestLen);\n                        for(var i = matchesBestLen - 1; i >= 0; --i)prepared.indexes[i] = matchesBest[i];\n                        return prepared;\n                    },\n                    prepareLowerCodes: function prepareLowerCodes(str) {\n                        var strLen = str.length;\n                        var lowerCodes = []; // new Array(strLen)    sparse array is too slow\n                        var lower = str.toLowerCase();\n                        for(var i = 0; i < strLen; ++i)lowerCodes[i] = lower.charCodeAt(i);\n                        return lowerCodes;\n                    },\n                    prepareBeginningIndexes: function prepareBeginningIndexes(target) {\n                        var targetLen = target.length;\n                        var beginningIndexes = [];\n                        var beginningIndexesLen = 0;\n                        var wasUpper = false;\n                        var wasAlphanum = false;\n                        for(var i = 0; i < targetLen; ++i){\n                            var targetCode = target.charCodeAt(i);\n                            var isUpper = targetCode >= 65 && targetCode <= 90;\n                            var isAlphanum = isUpper || targetCode >= 97 && targetCode <= 122 || targetCode >= 48 && targetCode <= 57;\n                            var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum;\n                            wasUpper = isUpper;\n                            wasAlphanum = isAlphanum;\n                            if (isBeginning) beginningIndexes[beginningIndexesLen++] = i;\n                        }\n                        return beginningIndexes;\n                    },\n                    prepareNextBeginningIndexes: function prepareNextBeginningIndexes(target) {\n                        var targetLen = target.length;\n                        var beginningIndexes = fuzzysort.prepareBeginningIndexes(target);\n                        var nextBeginningIndexes = []; // new Array(targetLen)     sparse array is too slow\n                        var lastIsBeginning = beginningIndexes[0];\n                        var lastIsBeginningI = 0;\n                        for(var i = 0; i < targetLen; ++i)if (lastIsBeginning > i) nextBeginningIndexes[i] = lastIsBeginning;\n                        else {\n                            lastIsBeginning = beginningIndexes[++lastIsBeginningI];\n                            nextBeginningIndexes[i] = lastIsBeginning === undefined ? targetLen : lastIsBeginning;\n                        }\n                        return nextBeginningIndexes;\n                    },\n                    cleanup: cleanup,\n                    new: fuzzysortNew\n                };\n                return fuzzysort;\n            } // fuzzysortNew\n            // This stuff is outside fuzzysortNew, because it's shared with instances of fuzzysort.new()\n            var isNode = typeof commonjsRequire !== 'undefined' && typeof window === 'undefined';\n            var MyMap = typeof Map === 'function' ? Map : function() {\n                var s = Object.create(null);\n                this.get = function(k) {\n                    return s[k];\n                };\n                this.set = function(k, val) {\n                    s[k] = val;\n                    return this;\n                };\n                this.clear = function() {\n                    s = Object.create(null);\n                };\n            };\n            var preparedCache = new MyMap();\n            var preparedSearchCache = new MyMap();\n            var noResults = [];\n            noResults.total = 0;\n            var matchesSimple = [];\n            var matchesStrict = [];\n            function cleanup() {\n                preparedCache.clear();\n                preparedSearchCache.clear();\n                matchesSimple = [];\n                matchesStrict = [];\n            }\n            function defaultScoreFn(a) {\n                var max = -9007199254740991;\n                for(var i = a.length - 1; i >= 0; --i){\n                    var result = a[i];\n                    if (result === null) continue;\n                    var score = result.score;\n                    if (score > max) max = score;\n                }\n                if (max === -9007199254740991) return null;\n                return max;\n            }\n            // prop = 'key'              2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\n            // prop = 'key1.key2'        10ms\n            // prop = ['key1', 'key2']   27ms\n            function getValue(obj, prop) {\n                var tmp = obj[prop];\n                if (tmp !== undefined) return tmp;\n                var segs = prop;\n                if (!Array.isArray(prop)) segs = prop.split('.');\n                var len = segs.length;\n                var i = -1;\n                while(obj && ++i < len)obj = obj[segs[i]];\n                return obj;\n            }\n            function isObj(x) {\n                return _typeof(x) === 'object';\n            } // faster as a function\n            // Hacked version of https://github.com/lemire/FastPriorityQueue.js\n            var fastpriorityqueue = function fastpriorityqueue() {\n                var r = [], o = 0, e = {};\n                function n() {\n                    for(var e = 0, n = r[e], c = 1; c < o;){\n                        var f = c + 1;\n                        e = c, f < o && r[f].score < r[c].score && (e = f), r[e - 1 >> 1] = r[e], c = 1 + (e << 1);\n                    }\n                    for(var a = e - 1 >> 1; e > 0 && n.score < r[a].score; a = (e = a) - 1 >> 1)r[e] = r[a];\n                    r[e] = n;\n                }\n                return e.add = function(e) {\n                    var n = o;\n                    r[o++] = e;\n                    for(var c = n - 1 >> 1; n > 0 && e.score < r[c].score; c = (n = c) - 1 >> 1)r[n] = r[c];\n                    r[n] = e;\n                }, e.poll = function() {\n                    if (0 !== o) {\n                        var e = r[0];\n                        return r[0] = r[--o], n(), e;\n                    }\n                }, e.peek = function(e) {\n                    if (0 !== o) return r[0];\n                }, e.replaceTop = function(o) {\n                    r[0] = o, n();\n                }, e;\n            };\n            var q = fastpriorityqueue(); // reuse this, except for async, it needs to make its own\n            return fuzzysortNew();\n        }); // UMD\n    // TODO: (performance) wasm version!?\n    // TODO: (performance) threads?\n    // TODO: (performance) avoid cache misses\n    // TODO: (performance) preparedCache is a memory leak\n    // TODO: (like sublime) backslash === forwardslash\n    // TODO: (like sublime) spaces: \"a b\" should do 2 searches 1 for a and 1 for b\n    // TODO: (scoring) garbage in targets that allows most searches to strict match need a penality\n    // TODO: (performance) idk if allowTypo is optimized\n    })(fuzzysort$1);\n    var fuzzysort = fuzzysort$1.exports;\n    var stats = {\n        failedTests: [],\n        defined: 0,\n        completed: 0\n    };\n    (function() {\n        // Don't load the HTML Reporter on non-browser environments\n        if (!window$1 || !document) return;\n        QUnit.reporters.perf.init(QUnit);\n        var config = QUnit.config;\n        var hiddenTests = [];\n        var collapseNext = false;\n        var hasOwn = Object.prototype.hasOwnProperty;\n        var unfilteredUrl = setUrl({\n            filter: undefined,\n            module: undefined,\n            moduleId: undefined,\n            testId: undefined\n        });\n        var dropdownData = null;\n        function trim(string) {\n            if (typeof string.trim === 'function') return string.trim();\n            else return string.replace(/^\\s+|\\s+$/g, '');\n        }\n        function addEvent(elem, type, fn) {\n            elem.addEventListener(type, fn, false);\n        }\n        function removeEvent(elem, type, fn) {\n            elem.removeEventListener(type, fn, false);\n        }\n        function addEvents(elems, type, fn) {\n            var i = elems.length;\n            while(i--)addEvent(elems[i], type, fn);\n        }\n        function hasClass(elem, name) {\n            return (' ' + elem.className + ' ').indexOf(' ' + name + ' ') >= 0;\n        }\n        function addClass(elem, name) {\n            if (!hasClass(elem, name)) elem.className += (elem.className ? ' ' : '') + name;\n        }\n        function toggleClass(elem, name, force) {\n            if (force || typeof force === 'undefined' && !hasClass(elem, name)) addClass(elem, name);\n            else removeClass(elem, name);\n        }\n        function removeClass(elem, name) {\n            var set = ' ' + elem.className + ' ';\n            // Class name may appear multiple times\n            while(set.indexOf(' ' + name + ' ') >= 0)set = set.replace(' ' + name + ' ', ' ');\n            // Trim for prettiness\n            elem.className = trim(set);\n        }\n        function id(name) {\n            return document.getElementById && document.getElementById(name);\n        }\n        function abortTests() {\n            var abortButton = id('qunit-abort-tests-button');\n            if (abortButton) {\n                abortButton.disabled = true;\n                abortButton.innerHTML = 'Aborting...';\n            }\n            QUnit.config.queue.length = 0;\n            return false;\n        }\n        function interceptNavigation(ev) {\n            // Trim potential accidental whitespace so that QUnit doesn't throw an error about no tests matching the filter.\n            var filterInputElem = id('qunit-filter-input');\n            filterInputElem.value = trim(filterInputElem.value);\n            applyUrlParams();\n            if (ev && ev.preventDefault) ev.preventDefault();\n            return false;\n        }\n        function getUrlConfigHtml() {\n            var selection = false;\n            var urlConfig = config.urlConfig;\n            var urlConfigHtml = '';\n            for(var i = 0; i < urlConfig.length; i++){\n                // Options can be either strings or objects with nonempty \"id\" properties\n                var val = config.urlConfig[i];\n                if (typeof val === 'string') val = {\n                    id: val,\n                    label: val\n                };\n                var escaped = escapeText(val.id);\n                var escapedTooltip = escapeText(val.tooltip);\n                if (!val.value || typeof val.value === 'string') urlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped + \"' title='\" + escapedTooltip + \"'><input id='qunit-urlconfig-\" + escaped + \"' name='\" + escaped + \"' type='checkbox'\" + (val.value ? \" value='\" + escapeText(val.value) + \"'\" : '') + (config[val.id] ? \" checked='checked'\" : '') + \" title='\" + escapedTooltip + \"' />\" + escapeText(val.label) + '</label>';\n                else {\n                    urlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped + \"' title='\" + escapedTooltip + \"'>\" + escapeText(val.label) + \": <select id='qunit-urlconfig-\" + escaped + \"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";\n                    if (Array.isArray(val.value)) for(var j = 0; j < val.value.length; j++){\n                        escaped = escapeText(val.value[j]);\n                        urlConfigHtml += \"<option value='\" + escaped + \"'\" + (config[val.id] === val.value[j] ? (selection = true, \" selected='selected'\") : '') + '>' + escaped + '</option>';\n                    }\n                    else {\n                        for(var _j in val.value)if (hasOwn.call(val.value, _j)) urlConfigHtml += \"<option value='\" + escapeText(_j) + \"'\" + (config[val.id] === _j ? (selection = true, \" selected='selected'\") : '') + '>' + escapeText(val.value[_j]) + '</option>';\n                    }\n                    if (config[val.id] && !selection) {\n                        escaped = escapeText(config[val.id]);\n                        urlConfigHtml += \"<option value='\" + escaped + \"' selected='selected' disabled='disabled'>\" + escaped + '</option>';\n                    }\n                    urlConfigHtml += '</select></label>';\n                }\n            }\n            return urlConfigHtml;\n        }\n        // Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.\n        // Updates the URL with the new state of `config.urlConfig` values.\n        function toolbarChanged() {\n            var field = this;\n            var params = {};\n            // Detect if field is a select menu or a checkbox\n            var value;\n            if ('selectedIndex' in field) value = field.options[field.selectedIndex].value || undefined;\n            else value = field.checked ? field.defaultValue || true : undefined;\n            params[field.name] = value;\n            var updatedUrl = setUrl(params);\n            // Check if we can apply the change without a page refresh\n            if (field.name === 'hidepassed' && 'replaceState' in window$1.history) {\n                QUnit.urlParams[field.name] = value;\n                config[field.name] = value || false;\n                var tests = id('qunit-tests');\n                if (tests) {\n                    if (field.checked) {\n                        var length = tests.children.length;\n                        var children = tests.children;\n                        for(var i = 0; i < length; i++){\n                            var test = children[i];\n                            var className = test ? test.className : '';\n                            var classNameHasPass = className.indexOf('pass') > -1;\n                            var classNameHasSkipped = className.indexOf('skipped') > -1;\n                            if (classNameHasPass || classNameHasSkipped) hiddenTests.push(test);\n                        }\n                        // Optimization: Avoid `for-of` iterator overhead.\n                        for(var _i = 0; _i < hiddenTests.length; _i++)tests.removeChild(hiddenTests[_i]);\n                    } else {\n                        // Optimization: Avoid `while (arr.length) arr.shift()` which would mutate the array many times.\n                        // As of Chrome 126, HTMLElement.append(...hiddenTests) is still slower than\n                        // calling appendChild in a loop.\n                        for(var _i2 = 0; _i2 < hiddenTests.length; _i2++)tests.appendChild(hiddenTests[_i2]);\n                        hiddenTests.length = 0;\n                    }\n                }\n                window$1.history.replaceState(null, '', updatedUrl);\n            } else window$1.location = updatedUrl;\n        }\n        function setUrl(params) {\n            var querystring = '?';\n            var location = window$1.location;\n            params = extend(extend({}, QUnit.urlParams), params);\n            for(var key in params)// Skip inherited or undefined properties\n            if (hasOwn.call(params, key) && params[key] !== undefined) {\n                // Output a parameter for each value of this key\n                // (but usually just one)\n                var arrValue = [].concat(params[key]);\n                for(var i = 0; i < arrValue.length; i++){\n                    querystring += encodeURIComponent(key);\n                    if (arrValue[i] !== true) querystring += '=' + encodeURIComponent(arrValue[i]);\n                    querystring += '&';\n                }\n            }\n            return location.protocol + '//' + location.host + location.pathname + querystring.slice(0, -1);\n        }\n        function applyUrlParams() {\n            var filter = id('qunit-filter-input').value;\n            window$1.location = setUrl({\n                filter: filter === '' ? undefined : filter,\n                moduleId: _toConsumableArray(dropdownData.selectedMap.keys()),\n                // Remove module and testId filter\n                module: undefined,\n                testId: undefined\n            });\n        }\n        function toolbarUrlConfigContainer() {\n            var urlConfigContainer = document.createElement('span');\n            urlConfigContainer.innerHTML = getUrlConfigHtml();\n            addClass(urlConfigContainer, 'qunit-url-config');\n            addEvents(urlConfigContainer.getElementsByTagName('input'), 'change', toolbarChanged);\n            addEvents(urlConfigContainer.getElementsByTagName('select'), 'change', toolbarChanged);\n            return urlConfigContainer;\n        }\n        function abortTestsButton() {\n            var button = document.createElement('button');\n            button.id = 'qunit-abort-tests-button';\n            button.innerHTML = 'Abort';\n            addEvent(button, 'click', abortTests);\n            return button;\n        }\n        function toolbarLooseFilter() {\n            var filter = document.createElement('form');\n            var label = document.createElement('label');\n            var input = document.createElement('input');\n            var button = document.createElement('button');\n            addClass(filter, 'qunit-filter');\n            label.innerHTML = 'Filter: ';\n            input.type = 'text';\n            input.value = config.filter || '';\n            input.name = 'filter';\n            input.id = 'qunit-filter-input';\n            button.innerHTML = 'Go';\n            label.appendChild(input);\n            filter.appendChild(label);\n            filter.appendChild(document.createTextNode(' '));\n            filter.appendChild(button);\n            addEvent(filter, 'submit', interceptNavigation);\n            return filter;\n        }\n        function createModuleListItem(moduleId, name, checked) {\n            return '<li><label class=\"clickable' + (checked ? ' checked' : '') + '\"><input type=\"checkbox\" ' + 'value=\"' + escapeText(moduleId) + '\"' + (checked ? ' checked=\"checked\"' : '') + ' />' + escapeText(name) + '</label></li>';\n        }\n        /**\n     * @param {Array} Results from fuzzysort\n     * @return {string} HTML\n     */ function moduleListHtml(results) {\n            var html = '';\n            // Hoist the already selected items, and show them always\n            // even if not matched by the current search.\n            dropdownData.selectedMap.forEach(function(name, moduleId) {\n                html += createModuleListItem(moduleId, name, true);\n            });\n            for(var i = 0; i < results.length; i++){\n                var mod = results[i].obj;\n                if (!dropdownData.selectedMap.has(mod.moduleId)) html += createModuleListItem(mod.moduleId, mod.name, false);\n            }\n            return html;\n        }\n        function toolbarModuleFilter(beginDetails) {\n            var initialSelected = null;\n            dropdownData = {\n                options: beginDetails.modules.slice(),\n                selectedMap: new StringMap(),\n                isDirty: function isDirty() {\n                    return _toConsumableArray(dropdownData.selectedMap.keys()).sort().join(',') !== _toConsumableArray(initialSelected.keys()).sort().join(',');\n                }\n            };\n            if (config.moduleId.length) // The module dropdown is seeded with the runtime configuration of the last run.\n            //\n            // We don't reference `config.moduleId` directly after this and keep our own\n            // copy because:\n            // 1. This naturally filters out unknown moduleIds.\n            // 2. Gives us a place to manage and remember unsubmitted checkbox changes.\n            // 3. Gives us an efficient way to map a selected moduleId to module name\n            //    during rendering.\n            for(var i = 0; i < beginDetails.modules.length; i++){\n                var mod = beginDetails.modules[i];\n                if (config.moduleId.indexOf(mod.moduleId) !== -1) dropdownData.selectedMap.set(mod.moduleId, mod.name);\n            }\n            initialSelected = new StringMap(dropdownData.selectedMap);\n            var moduleSearch = document.createElement('input');\n            moduleSearch.id = 'qunit-modulefilter-search';\n            moduleSearch.autocomplete = 'off';\n            addEvent(moduleSearch, 'input', searchInput);\n            addEvent(moduleSearch, 'input', searchFocus);\n            addEvent(moduleSearch, 'focus', searchFocus);\n            addEvent(moduleSearch, 'click', searchFocus);\n            var label = document.createElement('label');\n            label.htmlFor = 'qunit-modulefilter-search';\n            label.textContent = 'Module:';\n            var searchContainer = document.createElement('span');\n            searchContainer.id = 'qunit-modulefilter-search-container';\n            searchContainer.appendChild(moduleSearch);\n            var applyButton = document.createElement('button');\n            applyButton.textContent = 'Apply';\n            applyButton.title = 'Re-run the selected test modules';\n            addEvent(applyButton, 'click', applyUrlParams);\n            var resetButton = document.createElement('button');\n            resetButton.textContent = 'Reset';\n            resetButton.type = 'reset';\n            resetButton.title = 'Restore the previous module selection';\n            var clearButton = document.createElement('button');\n            clearButton.textContent = 'Select none';\n            clearButton.type = 'button';\n            clearButton.title = 'Clear the current module selection';\n            addEvent(clearButton, 'click', function() {\n                dropdownData.selectedMap.clear();\n                selectionChange();\n                searchInput();\n            });\n            var actions = document.createElement('span');\n            actions.id = 'qunit-modulefilter-actions';\n            actions.appendChild(applyButton);\n            actions.appendChild(resetButton);\n            if (initialSelected.size) // Only show clear button if functionally different from reset\n            actions.appendChild(clearButton);\n            var dropDownList = document.createElement('ul');\n            dropDownList.id = 'qunit-modulefilter-dropdown-list';\n            var dropDown = document.createElement('div');\n            dropDown.id = 'qunit-modulefilter-dropdown';\n            dropDown.style.display = 'none';\n            dropDown.appendChild(actions);\n            dropDown.appendChild(dropDownList);\n            addEvent(dropDown, 'change', selectionChange);\n            searchContainer.appendChild(dropDown);\n            // Set initial moduleSearch.placeholder and clearButton/resetButton.\n            selectionChange();\n            var moduleFilter = document.createElement('form');\n            moduleFilter.id = 'qunit-modulefilter';\n            moduleFilter.appendChild(label);\n            moduleFilter.appendChild(document.createTextNode(' '));\n            moduleFilter.appendChild(searchContainer);\n            addEvent(moduleFilter, 'submit', interceptNavigation);\n            addEvent(moduleFilter, 'reset', function() {\n                dropdownData.selectedMap = new StringMap(initialSelected);\n                // Set moduleSearch.placeholder and reflect non-dirty state\n                selectionChange();\n                searchInput();\n            });\n            // Enables show/hide for the dropdown\n            function searchFocus() {\n                if (dropDown.style.display !== 'none') return;\n                // Optimization: Defer rendering options until focussed.\n                // https://github.com/qunitjs/qunit/issues/1664\n                searchInput();\n                dropDown.style.display = 'block';\n                // Hide on Escape keydown or on click outside the container\n                addEvent(document, 'click', hideHandler);\n                addEvent(document, 'keydown', hideHandler);\n                function hideHandler(e) {\n                    var inContainer = moduleFilter.contains(e.target);\n                    if (e.keyCode === 27 || !inContainer) {\n                        if (e.keyCode === 27 && inContainer) moduleSearch.focus();\n                        dropDown.style.display = 'none';\n                        removeEvent(document, 'click', hideHandler);\n                        removeEvent(document, 'keydown', hideHandler);\n                        moduleSearch.value = '';\n                        searchInput();\n                    }\n                }\n            }\n            /**\n       * @param {string} searchText\n       * @return {string} HTML\n       */ function filterModules(searchText) {\n                var results;\n                if (searchText === '') // Improve on-boarding experience by having an immediate display of\n                // module names, indicating how the interface works. This also makes\n                // for a quicker interaction in the common case of small projects.\n                // Don't mandate typing just to get the menu.\n                results = dropdownData.options.slice(0, 20).map(function(obj) {\n                    // Fake empty results. https://github.com/farzher/fuzzysort/issues/41\n                    return {\n                        obj: obj\n                    };\n                });\n                else results = fuzzysort.go(searchText, dropdownData.options, {\n                    limit: 20,\n                    key: 'name',\n                    allowTypo: true\n                });\n                return moduleListHtml(results);\n            }\n            // Processes module search box input\n            var searchInputTimeout;\n            function searchInput() {\n                // Use a debounce with a ~0ms timeout. This is effectively instantaneous,\n                // but is better than undebounced because it avoids an ever-growing\n                // backlog of unprocessed now-outdated input events if fuzzysearch or\n                // drodown DOM is slow (e.g. very large test suite).\n                window$1.clearTimeout(searchInputTimeout);\n                searchInputTimeout = window$1.setTimeout(function() {\n                    dropDownList.innerHTML = filterModules(moduleSearch.value);\n                });\n            }\n            // Processes checkbox change, or a generic render (initial render, or after reset event)\n            // Avoid any dropdown rendering here as this is used by toolbarModuleFilter()\n            // during the initial render, which should not delay test execution.\n            function selectionChange(evt) {\n                var checkbox = evt && evt.target || null;\n                if (checkbox) {\n                    // Update internal state\n                    if (checkbox.checked) dropdownData.selectedMap.set(checkbox.value, checkbox.parentNode.textContent);\n                    else dropdownData.selectedMap.delete(checkbox.value);\n                    // Update UI state\n                    toggleClass(checkbox.parentNode, 'checked', checkbox.checked);\n                }\n                var textForm = dropdownData.selectedMap.size ? dropdownData.selectedMap.size + ' ' + (dropdownData.selectedMap.size === 1 ? 'module' : 'modules') : 'All modules';\n                moduleSearch.placeholder = textForm;\n                moduleSearch.title = 'Type to search through and reduce the list.';\n                resetButton.disabled = !dropdownData.isDirty();\n                clearButton.style.display = dropdownData.selectedMap.size ? '' : 'none';\n            }\n            return moduleFilter;\n        }\n        function appendToolbar(beginDetails) {\n            var toolbar = id('qunit-testrunner-toolbar');\n            if (toolbar) {\n                toolbar.appendChild(toolbarUrlConfigContainer());\n                var toolbarFilters = document.createElement('span');\n                toolbarFilters.id = 'qunit-toolbar-filters';\n                toolbarFilters.appendChild(toolbarLooseFilter());\n                toolbarFilters.appendChild(toolbarModuleFilter(beginDetails));\n                var clearfix = document.createElement('div');\n                clearfix.className = 'clearfix';\n                toolbar.appendChild(toolbarFilters);\n                toolbar.appendChild(clearfix);\n            }\n        }\n        function appendHeader() {\n            var header = id('qunit-header');\n            if (header) header.innerHTML = \"<a href='\" + escapeText(unfilteredUrl) + \"'>\" + header.innerHTML + '</a> ';\n        }\n        function appendBanner() {\n            var banner = id('qunit-banner');\n            if (banner) banner.className = '';\n        }\n        function appendTestResults() {\n            var tests = id('qunit-tests');\n            var result = id('qunit-testresult');\n            var controls;\n            if (result) result.parentNode.removeChild(result);\n            if (tests) {\n                tests.innerHTML = '';\n                result = document.createElement('p');\n                result.id = 'qunit-testresult';\n                result.className = 'result';\n                tests.parentNode.insertBefore(result, tests);\n                result.innerHTML = '<div id=\"qunit-testresult-display\">Running...<br />&#160;</div><div id=\"qunit-testresult-controls\"></div><div class=\"clearfix\"></div>';\n                controls = id('qunit-testresult-controls');\n            }\n            if (controls) controls.appendChild(abortTestsButton());\n        }\n        function appendFilteredTest() {\n            var testId = QUnit.config.testId;\n            if (!testId || testId.length <= 0) return '';\n            return \"<div id='qunit-filteredTest'>Rerunning selected tests: \" + escapeText(testId.join(', ')) + \" <a id='qunit-clearFilter' href='\" + escapeText(unfilteredUrl) + \"'>Run all tests</a></div>\";\n        }\n        function appendUserAgent() {\n            var userAgent = id('qunit-userAgent');\n            if (userAgent) {\n                userAgent.innerHTML = '';\n                userAgent.appendChild(document.createTextNode('QUnit ' + QUnit.version + '; ' + navigator.userAgent));\n            }\n        }\n        function appendInterface(beginDetails) {\n            var qunit = id('qunit');\n            // For compat with QUnit 1.2, and to support fully custom theme HTML,\n            // we will use any existing elements if no id=\"qunit\" element exists.\n            //\n            // Note that we don't fail or fallback to creating it ourselves,\n            // because not having id=\"qunit\" (and not having the below elements)\n            // simply means QUnit acts headless, allowing users to use their own\n            // reporters, or for a test runner to listen for events directly without\n            // having the HTML reporter actively render anything.\n            if (qunit) {\n                qunit.setAttribute('role', 'main');\n                // Since QUnit 1.3, these are created automatically if the page\n                // contains id=\"qunit\".\n                qunit.innerHTML = \"<h1 id='qunit-header'>\" + escapeText(document.title) + '</h1>' + \"<h2 id='qunit-banner'></h2>\" + \"<div id='qunit-testrunner-toolbar' role='navigation'></div>\" + appendFilteredTest() + \"<h2 id='qunit-userAgent'></h2>\" + \"<ol id='qunit-tests'></ol>\";\n            }\n            appendHeader();\n            appendBanner();\n            appendTestResults();\n            appendUserAgent();\n            appendToolbar(beginDetails);\n        }\n        function appendTest(name, testId, moduleName) {\n            var tests = id('qunit-tests');\n            if (!tests) return;\n            var title = document.createElement('strong');\n            title.className = 'qunit-test-name';\n            title.innerHTML = getNameHtml(name, moduleName);\n            var testBlock = document.createElement('li');\n            testBlock.appendChild(title);\n            // No ID or rerun link for \"global failure\" blocks\n            if (testId !== undefined) {\n                var rerunTrigger = document.createElement('a');\n                rerunTrigger.innerHTML = 'Rerun';\n                rerunTrigger.href = setUrl({\n                    testId: testId\n                });\n                testBlock.id = 'qunit-test-output-' + testId;\n                testBlock.appendChild(rerunTrigger);\n            }\n            var assertList = document.createElement('ol');\n            assertList.className = 'qunit-assert-list';\n            testBlock.appendChild(assertList);\n            tests.appendChild(testBlock);\n            return testBlock;\n        }\n        // HTML Reporter initialization and load\n        QUnit.on('runStart', function(runStart) {\n            stats.defined = runStart.testCounts.total;\n        });\n        QUnit.begin(function(beginDetails) {\n            // Initialize QUnit elements\n            // This is done from begin() instead of runStart, because\n            // urlparams.js uses begin(), which we need to wait for.\n            // urlparams.js in turn uses begin() to allow plugins to\n            // add entries to QUnit.config.urlConfig, which may be done\n            // asynchronously.\n            // <https://github.com/qunitjs/qunit/issues/1657>\n            appendInterface(beginDetails);\n        });\n        function getRerunFailedHtml(failedTests) {\n            if (failedTests.length === 0) return '';\n            var href = setUrl({\n                testId: failedTests\n            });\n            return [\n                \"<br /><a href='\" + escapeText(href) + \"'>\",\n                failedTests.length === 1 ? 'Rerun 1 failed test' : 'Rerun ' + failedTests.length + ' failed tests',\n                '</a>'\n            ].join('');\n        }\n        QUnit.on('runEnd', function(runEnd) {\n            var banner = id('qunit-banner');\n            var tests = id('qunit-tests');\n            var abortButton = id('qunit-abort-tests-button');\n            var assertPassed = config.stats.all - config.stats.bad;\n            var html = [\n                runEnd.testCounts.total,\n                ' tests completed in ',\n                runEnd.runtime,\n                ' milliseconds, with ',\n                runEnd.testCounts.failed,\n                ' failed, ',\n                runEnd.testCounts.skipped,\n                ' skipped, and ',\n                runEnd.testCounts.todo,\n                ' todo.<br />',\n                \"<span class='passed'>\",\n                assertPassed,\n                \"</span> assertions of <span class='total'>\",\n                config.stats.all,\n                \"</span> passed, <span class='failed'>\",\n                config.stats.bad,\n                '</span> failed.',\n                getRerunFailedHtml(stats.failedTests)\n            ].join('');\n            var test;\n            var assertLi;\n            var assertList;\n            // Update remaining tests to aborted\n            if (abortButton && abortButton.disabled) {\n                html = 'Tests aborted after ' + runEnd.runtime + ' milliseconds.';\n                for(var i = 0; i < tests.children.length; i++){\n                    test = tests.children[i];\n                    if (test.className === '' || test.className === 'running') {\n                        test.className = 'aborted';\n                        assertList = test.getElementsByTagName('ol')[0];\n                        assertLi = document.createElement('li');\n                        assertLi.className = 'fail';\n                        assertLi.innerHTML = 'Test aborted.';\n                        assertList.appendChild(assertLi);\n                    }\n                }\n            }\n            if (banner && (!abortButton || abortButton.disabled === false)) banner.className = runEnd.status === 'failed' ? 'qunit-fail' : 'qunit-pass';\n            if (abortButton) abortButton.parentNode.removeChild(abortButton);\n            if (tests) id('qunit-testresult-display').innerHTML = html;\n            if (config.altertitle && document.title) // Show  for good,  for bad suite result in title\n            // use escape sequences in case file gets loaded with non-utf-8\n            // charset\n            document.title = [\n                runEnd.status === 'failed' ? \"\\u2716\" : \"\\u2714\",\n                document.title.replace(/^[\\u2714\\u2716] /i, '')\n            ].join(' ');\n            // Scroll back to top to show results\n            if (config.scrolltop && window$1.scrollTo) window$1.scrollTo(0, 0);\n        });\n        function getNameHtml(name, module1) {\n            var nameHtml = '';\n            if (module1) nameHtml = \"<span class='module-name'>\" + escapeText(module1) + '</span>: ';\n            nameHtml += \"<span class='test-name'>\" + escapeText(name) + '</span>';\n            return nameHtml;\n        }\n        function getProgressHtml(stats) {\n            return [\n                stats.completed,\n                ' / ',\n                stats.defined,\n                ' tests completed.<br />'\n            ].join('');\n        }\n        QUnit.testStart(function(details) {\n            var running, bad;\n            appendTest(details.name, details.testId, details.module);\n            running = id('qunit-testresult-display');\n            if (running) {\n                addClass(running, 'running');\n                bad = QUnit.config.reorder && details.previousFailure;\n                running.innerHTML = [\n                    getProgressHtml(stats),\n                    bad ? 'Rerunning previously failed test: <br />' : 'Running: ',\n                    getNameHtml(details.name, details.module),\n                    getRerunFailedHtml(stats.failedTests)\n                ].join('');\n            }\n        });\n        function stripHtml(string) {\n            // Strip tags, html entity and whitespaces\n            return string.replace(/<\\/?[^>]+(>|$)/g, '').replace(/&quot;/g, '').replace(/\\s+/g, '');\n        }\n        QUnit.log(function(details) {\n            var testItem = id('qunit-test-output-' + details.testId);\n            if (!testItem) return;\n            var message = escapeText(details.message) || (details.result ? 'okay' : 'failed');\n            message = \"<span class='test-message'>\" + message + '</span>';\n            message += \"<span class='runtime'>@ \" + details.runtime + ' ms</span>';\n            var expected;\n            var actual;\n            var diff;\n            var showDiff = false;\n            // When pushFailure() is called, it is implied that no expected value\n            // or diff should be shown, because both expected and actual as undefined.\n            //\n            // This must check details.expected existence. If it exists as undefined,\n            // that's a regular assertion for which to render actual/expected and a diff.\n            var showAnyValues = !details.result && (details.expected !== undefined || details.actual !== undefined);\n            if (showAnyValues) {\n                if (details.negative) expected = 'NOT ' + QUnit.dump.parse(details.expected);\n                else expected = QUnit.dump.parse(details.expected);\n                actual = QUnit.dump.parse(details.actual);\n                message += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" + escapeText(expected) + '</pre></td></tr>';\n                if (actual !== expected) {\n                    message += \"<tr class='test-actual'><th>Result: </th><td><pre>\" + escapeText(actual) + '</pre></td></tr>';\n                    if (typeof details.actual === 'number' && typeof details.expected === 'number') {\n                        if (!isNaN(details.actual) && !isNaN(details.expected)) {\n                            showDiff = true;\n                            diff = details.actual - details.expected;\n                            diff = (diff > 0 ? '+' : '') + diff;\n                        }\n                    } else if (typeof details.actual !== 'boolean' && typeof details.expected !== 'boolean') {\n                        diff = QUnit.diff(expected, actual);\n                        // don't show diff if there is zero overlap\n                        showDiff = stripHtml(diff).length !== stripHtml(expected).length + stripHtml(actual).length;\n                    }\n                    if (showDiff) message += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" + diff + '</pre></td></tr>';\n                } else if (expected.indexOf('[object Array]') !== -1 || expected.indexOf('[object Object]') !== -1) message += \"<tr class='test-message'><th>Message: </th><td>Diff suppressed as the depth of object is more than current max depth (\" + QUnit.dump.maxDepth + ').<p>Hint: Use <code>QUnit.dump.maxDepth</code> to ' + \" run with a higher max depth or <a href='\" + escapeText(setUrl({\n                    maxDepth: 0\n                })) + \"'>\" + 'Rerun without max depth</a>.</p></td></tr>';\n                else message += \"<tr class='test-message'><th>Message: </th><td>Diff suppressed as the expected and actual results have an equivalent serialization</td></tr>\";\n                if (details.source) message += \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText(details.source) + '</pre></td></tr>';\n                message += '</table>';\n            // This occurs when pushFailure is set and we have an extracted stack trace\n            } else if (!details.result && details.source) message += \"<table><tr class='test-source'><th>Source: </th><td><pre>\" + escapeText(details.source) + '</pre></td></tr>' + '</table>';\n            var assertList = testItem.getElementsByTagName('ol')[0];\n            var assertLi = document.createElement('li');\n            assertLi.className = details.result ? 'pass' : 'fail';\n            assertLi.innerHTML = message;\n            assertList.appendChild(assertLi);\n        });\n        QUnit.testDone(function(details) {\n            var tests = id('qunit-tests');\n            var testItem = id('qunit-test-output-' + details.testId);\n            if (!tests || !testItem) return;\n            removeClass(testItem, 'running');\n            var status;\n            if (details.failed > 0) status = 'failed';\n            else if (details.todo) status = 'todo';\n            else status = details.skipped ? 'skipped' : 'passed';\n            var assertList = testItem.getElementsByTagName('ol')[0];\n            var good = details.passed;\n            var bad = details.failed;\n            // This test passed if it has no unexpected failed assertions\n            var testPassed = details.failed > 0 ? details.todo : !details.todo;\n            if (testPassed) // Collapse the passing tests\n            addClass(assertList, 'qunit-collapsed');\n            else {\n                stats.failedTests.push(details.testId);\n                if (config.collapse) {\n                    if (!collapseNext) // Skip collapsing the first failing test\n                    collapseNext = true;\n                    else // Collapse remaining tests\n                    addClass(assertList, 'qunit-collapsed');\n                }\n            }\n            // The testItem.firstChild is the test name\n            var testTitle = testItem.firstChild;\n            var testCounts = bad ? \"<b class='failed'>\" + bad + '</b>, ' + \"<b class='passed'>\" + good + '</b>, ' : '';\n            testTitle.innerHTML += \" <b class='counts'>(\" + testCounts + details.assertions.length + ')</b>';\n            stats.completed++;\n            if (details.skipped) {\n                testItem.className = 'skipped';\n                var skipped = document.createElement('em');\n                skipped.className = 'qunit-skipped-label';\n                skipped.innerHTML = 'skipped';\n                testItem.insertBefore(skipped, testTitle);\n            } else {\n                addEvent(testTitle, 'click', function() {\n                    toggleClass(assertList, 'qunit-collapsed');\n                });\n                testItem.className = testPassed ? 'pass' : 'fail';\n                if (details.todo) {\n                    var todoLabel = document.createElement('em');\n                    todoLabel.className = 'qunit-todo-label';\n                    todoLabel.innerHTML = 'todo';\n                    testItem.className += ' todo';\n                    testItem.insertBefore(todoLabel, testTitle);\n                }\n                var time = document.createElement('span');\n                time.className = 'runtime';\n                time.innerHTML = details.runtime + ' ms';\n                testItem.insertBefore(time, assertList);\n            }\n            // Show the source of the test when showing assertions\n            if (details.source) {\n                var sourceName = document.createElement('p');\n                sourceName.innerHTML = '<strong>Source: </strong>' + escapeText(details.source);\n                addClass(sourceName, 'qunit-source');\n                if (testPassed) addClass(sourceName, 'qunit-collapsed');\n                addEvent(testTitle, 'click', function() {\n                    toggleClass(sourceName, 'qunit-collapsed');\n                });\n                testItem.appendChild(sourceName);\n            }\n            if (config.hidepassed && (status === 'passed' || details.skipped)) {\n                // use removeChild instead of remove because of support\n                hiddenTests.push(testItem);\n                tests.removeChild(testItem);\n            }\n        });\n        QUnit.on('error', function(error) {\n            var testItem = appendTest('global failure');\n            if (!testItem) // HTML Reporter is probably disabled or not yet initialized.\n            return;\n            // Render similar to a failed assertion (see above QUnit.log callback)\n            var message = escapeText(errorString(error));\n            message = \"<span class='test-message'>\" + message + '</span>';\n            if (error && error.stack) message += \"<table><tr class='test-source'><th>Source: </th><td><pre>\" + escapeText(error.stack) + '</pre></td></tr>' + '</table>';\n            var assertList = testItem.getElementsByTagName('ol')[0];\n            var assertLi = document.createElement('li');\n            assertLi.className = 'fail';\n            assertLi.innerHTML = message;\n            assertList.appendChild(assertLi);\n            // Make it visible\n            testItem.className = 'fail';\n        });\n        // Avoid readyState issue with phantomjs\n        // Ref: #818\n        var usingPhantom = function(p) {\n            return p && p.version && p.version.major > 0;\n        }(window$1.phantom);\n        if (usingPhantom) console$1.warn('Support for PhantomJS is deprecated and will be removed in QUnit 3.0.');\n        if (!usingPhantom && document.readyState === 'complete') QUnit.autostart();\n        else addEvent(window$1, 'load', QUnit.autostart);\n        // Wrap window.onerror. We will call the original window.onerror to see if\n        // the existing handler fully handles the error; if not, we will call the\n        // QUnit.onError function.\n        var originalWindowOnError = window$1.onerror;\n        // Cover uncaught exceptions\n        // Returning true will suppress the default browser handler,\n        // returning false will let it run.\n        window$1.onerror = function(message, fileName, lineNumber, columnNumber, errorObj) {\n            var ret = false;\n            if (originalWindowOnError) {\n                for(var _len = arguments.length, args = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++)args[_key - 5] = arguments[_key];\n                ret = originalWindowOnError.call.apply(originalWindowOnError, [\n                    this,\n                    message,\n                    fileName,\n                    lineNumber,\n                    columnNumber,\n                    errorObj\n                ].concat(args));\n            }\n            // Treat return value as window.onerror itself does,\n            // Only do our handling if not suppressed.\n            if (ret !== true) {\n                // If there is a current test that sets the internal `ignoreGlobalErrors` field\n                // (such as during `assert.throws()`), then the error is ignored and native\n                // error reporting is suppressed as well. This is because in browsers, an error\n                // can sometimes end up in `window.onerror` instead of in the local try/catch.\n                // This ignoring of errors does not apply to our general onUncaughtException\n                // method, nor to our `unhandledRejection` handlers, as those are not meant\n                // to receive an \"expected\" error during `assert.throws()`.\n                if (config.current && config.current.ignoreGlobalErrors) return true;\n                // According to\n                // https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror,\n                // most modern browsers support an errorObj argument; use that to\n                // get a full stack trace if it's available.\n                var error = errorObj || new Error(message);\n                if (!error.stack && fileName && lineNumber) error.stack = \"\".concat(fileName, \":\").concat(lineNumber);\n                QUnit.onUncaughtException(error);\n            }\n            return ret;\n        };\n        window$1.addEventListener('unhandledrejection', function(event) {\n            QUnit.onUncaughtException(event.reason);\n        });\n    })();\n})();\n\n});\n\n/* eslint-disable array-element-newline */ \nvar $6KOho = parcelRequire(\"6KOho\");\n\nvar $132Nu = parcelRequire(\"132Nu\");\n\nvar $jkzyX = parcelRequire(\"jkzyX\");\n\nvar $3Bnob = parcelRequire(\"3Bnob\");\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).config.autostart = false;\n(0, $3Bnob.initConverter)(()=>{\n    (0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).start();\n});\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).module('Convert singles lines');\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).test('convertBanquePostale', (assert)=>{\n    let line;\n    line = (0, $jkzyX.convertBanquePostale)([\n        '25/01/2015',\n        'TRANSACTION',\n        '-500,00',\n        ''\n    ]);\n    assert.deepEqual(line, '01-25-15;;;;TRANSACTION;-500,00;;', 'Amount with a comma.');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '25/01/2015',\n        'TRANSACTION',\n        '1000.59',\n        ''\n    ]);\n    assert.deepEqual(line, '01-25-15;;;;TRANSACTION;1000.59;;', 'Amount with a dot.');\n});\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).test('convertBanquePostale - pay modes', (assert)=>{\n    let line;\n    line = (0, $jkzyX.convertBanquePostale)([\n        '15/12/2014',\n        'CHEQUE N 2224444',\n        '-100,99',\n        ''\n    ]);\n    assert.deepEqual(line, '12-15-14;2;;;CHEQUE N 2224444;-100,99;;', 'Cheque - CHEQUE N');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '11/10/2014',\n        'VIREMENT DE JEAN DUPONT REFERENCE : 123456789',\n        '11,70',\n        '85,27'\n    ]);\n    assert.deepEqual(line, '10-11-14;4;;;VIREMENT DE JEAN DUPONT REFERENCE : 123456789;11,70;;', 'Transfer - VIREMENT DE');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '25/10/2014',\n        'VIREMENT EMIS PAR JEAN DUPONT',\n        '101,70',\n        '85,27'\n    ]);\n    assert.deepEqual(line, '10-25-14;4;;;VIREMENT EMIS PAR JEAN DUPONT;101,70;;', 'Transfer - VIREMENT EMIS');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '25/10/1999',\n        'VIREMENT POUR BINNETTE',\n        '45,20',\n        '85,27'\n    ]);\n    assert.deepEqual(line, '10-25-99;4;;;VIREMENT POUR BINNETTE;45,20;;', 'Transfer - VIREMENT POUR');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '27/07/2013',\n        'ACHAT CB GEANT CASINO     26.07.13 CARTE NUMERO                XYZ  ',\n        '-18,26',\n        '-23,54'\n    ]);\n    assert.deepEqual(line, '07-27-13;6;;;ACHAT CB GEANT CASINO 26.07.13 CARTE NUMERO XYZ;-18,26;;', 'Debit card - ACHAT CB');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '27/07/2013',\n        'COMMISSION PAIEMENT PAR CARTE USA SELLER',\n        '-18,26',\n        '-23,54'\n    ]);\n    assert.deepEqual(line, '07-27-13;6;;;COMMISSION PAIEMENT PAR CARTE USA SELLER;-18,26;;', 'Debit card - COMMISSION PAIEMENT PAR CARTE');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '27/07/2013',\n        'COMMISSION RETRAIT PAR CARTE DAB PARIS FRANCE',\n        '-18,26',\n        '-23,54'\n    ]);\n    assert.deepEqual(line, '07-27-13;6;;;COMMISSION RETRAIT PAR CARTE DAB PARIS FRANCE;-18,26;;', 'Debit card - COMMISSION RETRAIT PAR CARTE');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '12/10/2014',\n        'CARTE X1234    12/10/14 A 12H21 RETRAIT DAB LA BANQUE POSTALE  ',\n        '-150,00',\n        '-700,15'\n    ]);\n    assert.deepEqual(line, '10-12-14;6;;;CARTE X1234 12/10/14 A 12H21 RETRAIT DAB LA BANQUE POSTALE;-150,00;;', 'Debit card - RETRAIT DAB');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '21/11/2014',\n        'TELEREGLEMENT DE REGLEMENT IMPOT 1234',\n        '-253,00',\n        '-49,12'\n    ]);\n    assert.deepEqual(line, '11-21-14;6;;;TELEREGLEMENT DE REGLEMENT IMPOT 1234;-253,00;;', 'Debit card - TELEREGLEMENT DE REGLEMENT IMPOT');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '21/11/2014',\n        'CREDIT CARTE BANCAIRE CARREFOUR',\n        '11,59',\n        '-49,12'\n    ]);\n    assert.deepEqual(line, '11-21-14;6;;;CREDIT CARTE BANCAIRE CARREFOUR;11,59;;', 'Debit card - CREDIT CARTE BANCAIRE');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '04/11/2018',\n        'RETRAIT THISBANK 04.11.18 EUR 20,00 CARTE NO 666',\n        '20,00',\n        ''\n    ]);\n    assert.deepEqual(line, '11-04-18;6;;;RETRAIT THISBANK 04.11.18 EUR 20,00 CARTE NO 666;20,00;;', 'Debit card - RETRAIT ');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '04/11/2018',\n        'COMMISSION PAIEMENT PAR CARTE 04.11.18 EUR 0,99 CARTE NO 777',\n        '0,99',\n        ''\n    ]);\n    assert.deepEqual(line, '11-04-18;6;;;COMMISSION PAIEMENT PAR CARTE 04.11.18 EUR 0,99 CARTE NO 777;0,99;;', 'Debit card - COMMISSION PAIEMENT PAR CARTE[space]');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '04/11/2018',\n        'COMMISSION PAIEMENT PAR CARTE',\n        '0,99',\n        ''\n    ]);\n    assert.deepEqual(line, '11-04-18;6;;;COMMISSION PAIEMENT PAR CARTE;0,99;;', 'Debit card - COMMISSION PAIEMENT PAR CARTE');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '04/11/2014',\n        'PRELEVEMENT DE OPERATEUR TELEPHONE MOBILE',\n        '-10,00',\n        '-22,44'\n    ]);\n    assert.deepEqual(line, '11-04-14;7;;;PRELEVEMENT DE OPERATEUR TELEPHONE MOBILE;-10,00;;', 'Standing order - PRELEVEMENT');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '18/11/2014',\n        'REMISE DE CHEQUE N  1114444 DE MR JEAN DUPONT',\n        '100,00',\n        ''\n    ]);\n    assert.deepEqual(line, '11-18-14;9;;;REMISE DE CHEQUE N 1114444 DE MR JEAN DUPONT;100,00;;', 'Deposit - REMISE DE CHEQUE N');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '18/11/2014',\n        'REMISE DE CHEQUES DE MR JEAN DUPONT',\n        '100,00',\n        ''\n    ]);\n    assert.deepEqual(line, '11-18-14;9;;;REMISE DE CHEQUES DE MR JEAN DUPONT;100,00;;', 'Deposit - REMISE DE CHEQUE N');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '18/11/2014',\n        'VERSEMENT EFFECTUE DE MR JEAN DUPONT',\n        '100,00',\n        ''\n    ]);\n    assert.deepEqual(line, '11-18-14;9;;;VERSEMENT EFFECTUE DE MR JEAN DUPONT;100,00;;', 'Deposit - REMISE DE CHEQUE N');\n    line = (0, $jkzyX.convertBanquePostale)([\n        '18/11/2014',\n        'COTISATION TRIMESTRIELLE DE VOTRE FORMULE DE COMPTE',\n        '1,00',\n        ''\n    ]);\n    assert.deepEqual(line, '11-18-14;10;;;COTISATION TRIMESTRIELLE DE VOTRE FORMULE DE COMPTE;1,00;;', 'FI fee - COTISATION TRIMESTRIELLE DE VOTRE FORMULE DE COMPTE');\n});\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).test('convertBoobank', (assert)=>{\n    let line;\n    line = (0, $jkzyX.convertBoobank)([\n        '',\n        '2014-08-29',\n        '',\n        '',\n        '',\n        '',\n        '',\n        'memo1',\n        '-11,20'\n    ]);\n    assert.deepEqual(line, '08-29-14;;;;memo1;-11,20;;', 'Amount with a comma.');\n    line = (0, $jkzyX.convertBoobank)([\n        '',\n        '2014-08-29',\n        '',\n        '',\n        '',\n        '',\n        '',\n        'memo1',\n        '12.20'\n    ]);\n    assert.deepEqual(line, '08-29-14;;;;memo1;12.20;;', 'Amount with a dot.');\n});\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).test('convertPaypal', (assert)=>{\n    let line;\n    line = (0, $jkzyX.convertPaypal)([\n        '25/01/2015',\n        '',\n        '',\n        'memo3',\n        'memo2',\n        '',\n        'memo5',\n        '',\n        '',\n        '-200,39',\n        '',\n        '',\n        'memo4',\n        '',\n        '',\n        'memo1',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        ''\n    ]);\n    assert.deepEqual(line, '01-25-15;;;;memo1, memo2, memo3, memo4, memo5;-200,39;;', 'Amount with a comma.');\n    line = (0, $jkzyX.convertPaypal)([\n        '25/01/2015',\n        '',\n        '',\n        'memo3',\n        'memo2',\n        '',\n        'memo5',\n        '',\n        '',\n        '1099.99',\n        '',\n        '',\n        'memo4',\n        '',\n        '',\n        'memo1',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        ''\n    ]);\n    assert.deepEqual(line, '01-25-15;;;;memo1, memo2, memo3, memo4, memo5;1099.99;;', 'Amount with a dot.');\n});\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).module('Convert single lines with errors');\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).test('convertBanquePostale', (assert)=>{\n    assert.throws(()=>{\n        (0, $jkzyX.convertBanquePostale)([\n            '25/13/2015',\n            'TRANSACTION',\n            '-500,00',\n            ''\n        ]);\n    }, new Error('Invalid date: 25/13/2015'), 'Wrong date 25/13/2015.');\n});\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).test('convertBoobank', (assert)=>{\n    assert.throws(()=>{\n        (0, $jkzyX.convertBoobank)([\n            '',\n            '2015-13-20',\n            '',\n            '',\n            'memo2',\n            '',\n            '',\n            'memo1',\n            '-10,20'\n        ]);\n    }, new Error('Invalid date: 2015-13-20'), 'Wrong date 2015-13-20.');\n});\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).test('convertPaypal', (assert)=>{\n    assert.throws(()=>{\n        (0, $jkzyX.convertPaypal)([\n            '30/13/2015',\n            '',\n            '',\n            'memo3',\n            'memo2',\n            '',\n            'memo5',\n            '',\n            '',\n            '-200,39',\n            '',\n            '',\n            'memo4',\n            '',\n            '',\n            'memo1',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            '',\n            ''\n        ]);\n    }, new Error('Invalid date: 30/13/2015'), 'Wrong date 30/13/2015.');\n});\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).module('Convert whole files');\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).test('Banque Postale - csv file', (assert)=>{\n    const done = assert.async();\n    const inputFilename = 'banquePostale.csv';\n    const expectedFilename = 'banquePostale_converted.csv';\n    let converted;\n    let expected;\n    (0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).when((0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).get('data/tests/' + inputFilename, (data)=>{\n        const index = (0, $jkzyX.getBankIndexByName)('Banque Postale');\n        converted = (0, $3Bnob.convertData)(index, data, inputFilename);\n    }), (0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).get('data/tests/' + expectedFilename, (data)=>{\n        expected = {\n            status: true,\n            data: data,\n            message: '',\n            errors: []\n        };\n    })).then(()=>{\n        assert.deepEqual(converted.data.split('\\n').length, 100, 'converted.length = 100');\n        assert.deepEqual(converted.status, expected.status, 'Status is true');\n        assert.deepEqual(converted.data.replaceAll('\\r\\n', '\\n').split('\\n'), expected.data.replaceAll('\\r\\n', '\\n').split('\\n'), 'Same data');\n        assert.deepEqual(converted.message, expected.message, 'Message is empty');\n        assert.deepEqual(converted.errors, expected.errors, 'No errors');\n        done();\n    });\n});\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).test('Banque Postale - tsv file', (assert)=>{\n    const done = assert.async();\n    const inputFilename = 'banquePostale.tsv';\n    const expectedFilename = 'banquePostale_converted.csv';\n    let converted;\n    let expected;\n    (0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).when((0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).get('data/tests/' + inputFilename, (data)=>{\n        const index = (0, $jkzyX.getBankIndexByName)('Banque Postale');\n        converted = (0, $3Bnob.convertData)(index, data, inputFilename);\n    }), (0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).get('data/tests/' + expectedFilename, (data)=>{\n        expected = {\n            status: true,\n            data: data,\n            message: '',\n            errors: []\n        };\n    })).then(()=>{\n        assert.deepEqual(converted.data.split('\\n').length, 100, 'converted.length = 100');\n        assert.deepEqual(converted.status, expected.status, 'Status is true');\n        assert.deepEqual(converted.data.replaceAll('\\r\\n', '\\n').split('\\n'), expected.data.replaceAll('\\r\\n', '\\n').split('\\n'), 'Same data');\n        assert.deepEqual(converted.message, expected.message, 'Message is empty');\n        assert.deepEqual(converted.errors, expected.errors, 'No errors');\n        done();\n    });\n});\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).test('BNP Paribas Fortis - csv file', (assert)=>{\n    const done = assert.async();\n    const inputFilename = 'bnpParibasFortis.csv';\n    const expectedFilename = 'bnpParibasFortis_converted.csv';\n    let converted;\n    let expected;\n    (0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).when((0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).get('data/tests/' + inputFilename, (data)=>{\n        const index = (0, $jkzyX.getBankIndexByName)('BNP Paribas Fortis');\n        converted = (0, $3Bnob.convertData)(index, data, inputFilename);\n    }), (0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).get('data/tests/' + expectedFilename, (data)=>{\n        expected = {\n            status: true,\n            data: data,\n            message: '',\n            errors: []\n        };\n    })).then(()=>{\n        assert.deepEqual(converted.data.split('\\n').length, 17, 'converted.length = 17');\n        assert.deepEqual(converted.status, expected.status, 'Status is true');\n        assert.deepEqual(converted.data.replaceAll('\\r\\n', '\\n').split('\\n'), expected.data.replaceAll('\\r\\n', '\\n').split('\\n'), 'Same data');\n        assert.deepEqual(converted.message, expected.message, 'Message is empty');\n        assert.deepEqual(converted.errors, expected.errors, 'No errors');\n        done();\n    });\n});\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).test('Boobank - csv file', (assert)=>{\n    const done = assert.async();\n    const inputFilename = 'boobank.csv';\n    const expectedFilename = 'boobank_converted.csv';\n    let converted;\n    let expected;\n    (0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).when((0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).get('data/tests/' + inputFilename, (data)=>{\n        const index = (0, $jkzyX.getBankIndexByName)('Boobank');\n        converted = (0, $3Bnob.convertData)(index, data, inputFilename);\n    }), (0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).get('data/tests/' + expectedFilename, (data)=>{\n        expected = {\n            status: true,\n            data: data,\n            message: '',\n            errors: []\n        };\n    })).then(()=>{\n        assert.deepEqual(converted.data.split('\\n').length, 50, 'converted.length = 50');\n        assert.deepEqual(converted.status, expected.status, 'Status is true');\n        assert.deepEqual(converted.data.replaceAll('\\r\\n', '\\n').split('\\n'), expected.data.replaceAll('\\r\\n', '\\n').split('\\n'), 'Same data');\n        assert.deepEqual(converted.message, expected.message, 'Message is empty');\n        assert.deepEqual(converted.errors, expected.errors, 'No errors');\n        done();\n    });\n});\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).test('Paypal - csv file', (assert)=>{\n    const done = assert.async();\n    const inputFilename = 'paypal.csv';\n    const expectedFilename = 'paypal_converted.csv';\n    let converted;\n    let expected;\n    (0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).when((0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).get('data/tests/' + inputFilename, (data)=>{\n        const index = (0, $jkzyX.getBankIndexByName)('PayPal');\n        converted = (0, $3Bnob.convertData)(index, data, inputFilename);\n    }), (0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).get('data/tests/' + expectedFilename, (data)=>{\n        expected = {\n            status: true,\n            data: data,\n            message: '',\n            errors: []\n        };\n    })).then(()=>{\n        assert.deepEqual(converted.data.split('\\n').length, 30, 'converted.length = 30');\n        assert.deepEqual(converted.status, expected.status, 'Status is true');\n        assert.deepEqual(converted.data.replaceAll('\\r\\n', '\\n').split('\\n'), expected.data.replaceAll('\\r\\n', '\\n').split('\\n'), 'Same data');\n        assert.deepEqual(converted.message, expected.message, 'Message is empty');\n        assert.deepEqual(converted.errors, expected.errors, 'No errors');\n        done();\n    });\n});\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).test('Paypal - txt file', (assert)=>{\n    const done = assert.async();\n    const inputFilename = 'paypal.txt';\n    const expectedFilename = 'paypal_converted.csv';\n    let converted;\n    let expected;\n    (0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).when((0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).get('data/tests/' + inputFilename, (data)=>{\n        const index = (0, $jkzyX.getBankIndexByName)('PayPal');\n        converted = (0, $3Bnob.convertData)(index, data, inputFilename);\n    }), (0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).get('data/tests/' + expectedFilename, (data)=>{\n        expected = {\n            status: true,\n            data: data,\n            message: '',\n            errors: []\n        };\n    })).then(()=>{\n        assert.deepEqual(converted.data.split('\\n').length, 30, 'converted.length = 30');\n        assert.deepEqual(converted.status, expected.status, 'Status is true');\n        assert.deepEqual(converted.data.replaceAll('\\r\\n', '\\n').split('\\n'), expected.data.replaceAll('\\r\\n', '\\n').split('\\n'), 'Same data');\n        assert.deepEqual(converted.message, expected.message, 'Message is empty');\n        assert.deepEqual(converted.errors, expected.errors, 'No errors');\n        done();\n    });\n});\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).module('Convert whole files with errors');\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).test('Banque Postale - csv file', (assert)=>{\n    const done = assert.async();\n    const inputFilename = 'banquePostaleWithErrors.csv';\n    const expectedFilename = 'banquePostaleWithErrors_converted.csv';\n    let converted;\n    let expected;\n    (0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).when((0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).get('data/tests/' + inputFilename, (data)=>{\n        const index = (0, $jkzyX.getBankIndexByName)('Banque Postale');\n        converted = (0, $3Bnob.convertData)(index, data, inputFilename);\n    }), (0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).get('data/tests/' + expectedFilename, (data)=>{\n        expected = {\n            status: true,\n            data: data,\n            message: '',\n            errors: [\n                'Error on line: 38. Error: Invalid date:            \"SANS DATE NI COMA    \"',\n                'Error on line: 58. Error: Line does not have enough fields. Found: 2. Minimum: 3.',\n                'Error on line: 65. Error: Line does not have enough fields. Found: 1. Minimum: 3.',\n                'Error on line: 80. Error: Invalid date:           ',\n                'Error on line: 98. Error: Invalid date: 29/02/2003'\n            ]\n        };\n    })).then(()=>{\n        assert.deepEqual(converted.data.split('\\n').length, 100, 'converted.length = 100');\n        assert.deepEqual(converted.status, expected.status, 'Status is true');\n        assert.deepEqual(converted.data.replaceAll('\\r\\n', '\\n').split('\\n'), expected.data.replaceAll('\\r\\n', '\\n').split('\\n'), 'Same data');\n        assert.deepEqual(converted.message, expected.message, 'Message is empty');\n        assert.deepEqual(converted.errors, expected.errors, 'No errors');\n        done();\n    });\n});\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).module('Optimize XHB');\n(0, (/*@__PURE__*/$parcel$interopDefault($132Nu))).test('Example - XHB file', (assert)=>{\n    const done = assert.async();\n    const inputFilename = 'example.xhb';\n    const expectedFilename = 'example_optimized.xhb';\n    let optimized;\n    let expected;\n    (0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).when((0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).get('data/tests/' + inputFilename, (data)=>{\n        optimized = (0, $3Bnob.optimizeData)(data);\n    }), (0, (/*@__PURE__*/$parcel$interopDefault($6KOho))).get('data/tests/' + expectedFilename, (data)=>{\n        expected = data;\n    })).then(()=>{\n        assert.deepEqual(optimized.split('\\n').length, expected.split('\\n').length, 'Same length');\n        assert.deepEqual(optimized.replaceAll('\\r\\n', '\\n').split('\\n'), expected.replaceAll('\\r\\n', '\\n').split('\\n'), 'Same data');\n        done();\n    });\n});\n\n\n//# sourceMappingURL=tests.4586ab75.js.map\n","/*!\n * QUnit 2.24.3\n * https://qunitjs.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n */\n(function () {\n  'use strict';\n\n  function _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n    return n;\n  }\n  function _arrayWithHoles(r) {\n    if (Array.isArray(r)) return r;\n  }\n  function _arrayWithoutHoles(r) {\n    if (Array.isArray(r)) return _arrayLikeToArray(r);\n  }\n  function _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n  function _defineProperties(e, r) {\n    for (var t = 0; t < r.length; t++) {\n      var o = r[t];\n      o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n  }\n  function _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n      writable: !1\n    }), e;\n  }\n  function _iterableToArray(r) {\n    if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n  }\n  function _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n      var e,\n        n,\n        i,\n        u,\n        a = [],\n        f = !0,\n        o = !1;\n      try {\n        if (i = (t = t.call(r)).next, 0 === l) {\n          if (Object(t) !== t) return;\n          f = !1;\n        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n      } catch (r) {\n        o = !0, n = r;\n      } finally {\n        try {\n          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n        } finally {\n          if (o) throw n;\n        }\n      }\n      return a;\n    }\n  }\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  function _slicedToArray(r, e) {\n    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n  }\n  function _toConsumableArray(r) {\n    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n  }\n  function _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n      var i = e.call(t, r || \"default\");\n      if (\"object\" != typeof i) return i;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n  }\n  function _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n  }\n  function _typeof(o) {\n    \"@babel/helpers - typeof\";\n\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n      return typeof o;\n    } : function (o) {\n      return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n  }\n  function _unsupportedIterableToArray(r, a) {\n    if (r) {\n      if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n      var t = {}.toString.call(r).slice(8, -1);\n      return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n    }\n  }\n\n  // We don't use global-this-polyfill [1], because it modifies\n  // the globals scope by default. QUnit must not affect the host context\n  // as developers may test their project may be such a polyfill, and/or\n  // they may intentionally test their project with and without certain\n  // polyfills and we must not affect that. It also uses an obscure\n  // mechanism that seems to sometimes causes a runtime error in older\n  // browsers (specifically Safari and IE versions that support\n  // Object.defineProperty but then report _T_ as undefined).\n  // [1] https://github.com/ungap/global-this/blob/v0.4.4/esm/index.js\n  //\n  // Another way is `Function('return this')()`, but doing so relies\n  // on eval which will cause a CSP error on some servers.\n  //\n  // Instead, simply check the four options that already exist\n  // in all supported environments.\n  function getGlobalThis() {\n    if (typeof globalThis !== 'undefined') {\n      // For SpiderMonkey, modern browsers, and recent Node.js\n      // eslint-disable-next-line no-undef\n      return globalThis;\n    }\n    if (typeof self !== 'undefined') {\n      // For web workers\n      // eslint-disable-next-line no-undef\n      return self;\n    }\n    if (typeof window$1 !== 'undefined') {\n      // For document context in browsers\n      return window$1;\n    }\n    if (typeof global !== 'undefined') {\n      // For Node.js\n      // eslint-disable-next-line no-undef\n      return global;\n    }\n    throw new Error('Unable to locate global object');\n  }\n\n  // This avoids a simple `export const` assignment as that would lead Rollup\n  // to change getGlobalThis and use the same (generated) variable name there.\n  var g = getGlobalThis();\n\n  // These optional globals are undefined in one or more environments:\n  // modern browser, old browser, Node.js, SpiderMonkey.\n  // Calling code must check these for truthy-ness before use.\n  var console$1 = g.console;\n  var setTimeout$1 = g.setTimeout;\n  var clearTimeout = g.clearTimeout;\n  var process$1 = g.process;\n  var window$1 = g.window;\n  var document = window$1 && window$1.document;\n  var navigator = window$1 && window$1.navigator;\n  var localSessionStorage = function () {\n    var x = 'qunit-test-string';\n    try {\n      g.sessionStorage.setItem(x, x);\n      g.sessionStorage.removeItem(x);\n      return g.sessionStorage;\n    } catch (e) {\n      return undefined;\n    }\n  }();\n\n  // Basic fallback for ES6 Map\n  // Support: IE 9-10, Safari 7, PhantomJS; Map is undefined\n  // Support: iOS 8; `new Map(iterable)` is not supported\n  //\n  // Fallback for ES7 Map#keys\n  // Support: IE 11; Map#keys is undefined\n  var StringMap = typeof g.Map === 'function' && typeof g.Map.prototype.keys === 'function' && typeof g.Symbol === 'function' && _typeof(g.Symbol.iterator) === 'symbol' ? g.Map : function StringMap(input) {\n    var _this = this;\n    var store = Object.create(null);\n    var hasOwn = Object.prototype.hasOwnProperty;\n    this.has = function (strKey) {\n      return hasOwn.call(store, strKey);\n    };\n    this.get = function (strKey) {\n      return store[strKey];\n    };\n    this.set = function (strKey, val) {\n      if (!hasOwn.call(store, strKey)) {\n        this.size++;\n      }\n      store[strKey] = val;\n      return this;\n    };\n    this.delete = function (strKey) {\n      if (hasOwn.call(store, strKey)) {\n        delete store[strKey];\n        this.size--;\n      }\n    };\n    this.forEach = function (callback) {\n      for (var strKey in store) {\n        callback(store[strKey], strKey);\n      }\n    };\n    this.keys = function () {\n      return Object.keys(store);\n    };\n    this.clear = function () {\n      store = Object.create(null);\n      this.size = 0;\n    };\n    this.size = 0;\n    if (input) {\n      input.forEach(function (val, strKey) {\n        _this.set(strKey, val);\n      });\n    }\n  };\n\n  // Basic fallback for ES6 Set\n  // Support: IE 11, `new Set(iterable)` parameter not yet implemented\n  // Test for Set#values() which came after Set(iterable).\n  var StringSet = typeof g.Set === 'function' && typeof g.Set.prototype.values === 'function' ? g.Set : function (input) {\n    var set = Object.create(null);\n    if (Array.isArray(input)) {\n      input.forEach(function (item) {\n        set[item] = true;\n      });\n    }\n    return {\n      add: function add(value) {\n        set[value] = true;\n      },\n      has: function has(value) {\n        return value in set;\n      },\n      get size() {\n        return Object.keys(set).length;\n      }\n    };\n  };\n\n  var toString = Object.prototype.toString;\n  var hasOwn$1 = Object.prototype.hasOwnProperty;\n  var performance = {\n    // eslint-disable-next-line compat/compat -- Checked\n    now: window$1 && window$1.performance && window$1.performance.now ? window$1.performance.now.bind(window$1.performance) : Date.now\n  };\n\n  // Returns a new Array with the elements that are in a but not in b\n  function diff$1(a, b) {\n    return a.filter(function (a) {\n      return b.indexOf(a) === -1;\n    });\n  }\n\n  /**\n   * Determines whether an element exists in a given array or not.\n   *\n   * @method inArray\n   * @param {any} elem\n   * @param {Array} array\n   * @return {boolean}\n   */\n  var inArray = Array.prototype.includes ? function (elem, array) {\n    return array.includes(elem);\n  } : function (elem, array) {\n    return array.indexOf(elem) !== -1;\n  };\n\n  /**\n   * Recursively clone an object into a plain array or object, taking only the\n   * own enumerable properties.\n   *\n   * @param {any} obj\n   * @param {bool} [allowArray=true]\n   * @return {Object|Array}\n   */\n  function objectValues(obj) {\n    var allowArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var vals = allowArray && is('array', obj) ? [] : {};\n    for (var key in obj) {\n      if (hasOwn$1.call(obj, key)) {\n        var val = obj[key];\n        vals[key] = val === Object(val) ? objectValues(val, allowArray) : val;\n      }\n    }\n    return vals;\n  }\n\n  /**\n   * Recursively clone an object into a plain object, taking only the\n   * subset of own enumerable properties that exist a given model.\n   *\n   * @param {any} obj\n   * @param {any} model\n   * @return {Object}\n   */\n  function objectValuesSubset(obj, model) {\n    // Return primitive values unchanged to avoid false positives or confusing\n    // results from assert.propContains().\n    // E.g. an actual null or false wrongly equaling an empty object,\n    // or an actual string being reported as object not matching a partial object.\n    if (obj !== Object(obj)) {\n      return obj;\n    }\n\n    // Unlike objectValues(), subset arrays to a plain objects as well.\n    // This enables subsetting [20, 30] with {1: 30}.\n    var subset = {};\n    for (var key in model) {\n      if (hasOwn$1.call(model, key) && hasOwn$1.call(obj, key)) {\n        subset[key] = objectValuesSubset(obj[key], model[key]);\n      }\n    }\n    return subset;\n  }\n  function extend(a, b, undefOnly) {\n    for (var prop in b) {\n      if (hasOwn$1.call(b, prop)) {\n        if (b[prop] === undefined) {\n          delete a[prop];\n        } else if (!(undefOnly && typeof a[prop] !== 'undefined')) {\n          a[prop] = b[prop];\n        }\n      }\n    }\n    return a;\n  }\n  function objectType(obj) {\n    if (typeof obj === 'undefined') {\n      return 'undefined';\n    }\n\n    // Consider: typeof null === object\n    if (obj === null) {\n      return 'null';\n    }\n    var match = toString.call(obj).match(/^\\[object\\s(.*)\\]$/);\n    var type = match && match[1];\n    switch (type) {\n      case 'Number':\n        if (isNaN(obj)) {\n          return 'nan';\n        }\n        return 'number';\n      case 'String':\n      case 'Boolean':\n      case 'Array':\n      case 'Set':\n      case 'Map':\n      case 'Date':\n      case 'RegExp':\n      case 'Function':\n      case 'Symbol':\n        return type.toLowerCase();\n      default:\n        return _typeof(obj);\n    }\n  }\n\n  // Safe object type checking\n  function is(type, obj) {\n    return objectType(obj) === type;\n  }\n\n  // Based on Java's String.hashCode, a simple but not\n  // rigorously collision resistant hashing function\n  function generateHash(module, testName) {\n    var str = module + '\\x1C' + testName;\n    var hash = 0;\n    for (var i = 0; i < str.length; i++) {\n      hash = (hash << 5) - hash + str.charCodeAt(i);\n      hash |= 0;\n    }\n\n    // Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n    // strictly necessary but increases user understanding that the id is a SHA-like hash\n    var hex = (0x100000000 + hash).toString(16);\n    if (hex.length < 8) {\n      hex = '0000000' + hex;\n    }\n    return hex.slice(-8);\n  }\n\n  /**\n   * Converts an error into a simple string for comparisons.\n   *\n   * @param {Error|any} error\n   * @return {string}\n   */\n  function errorString(error) {\n    // Use String() instead of toString() to handle non-object values like undefined or null.\n    var resultErrorString = String(error);\n\n    // If the error wasn't a subclass of Error but something like\n    // an object literal with name and message properties...\n    if (resultErrorString.slice(0, 7) === '[object') {\n      // Based on https://es5.github.io/#x15.11.4.4\n      return (error.name || 'Error') + (error.message ? \": \".concat(error.message) : '');\n    } else {\n      return resultErrorString;\n    }\n  }\n  function escapeText(str) {\n    if (!str) {\n      return '';\n    }\n\n    // Both single quotes and double quotes (for attributes)\n    return ('' + str).replace(/['\"<>&]/g, function (s) {\n      switch (s) {\n        case \"'\":\n          return '&#039;';\n        case '\"':\n          return '&quot;';\n        case '<':\n          return '&lt;';\n        case '>':\n          return '&gt;';\n        case '&':\n          return '&amp;';\n      }\n    });\n  }\n\n  var BOXABLE_TYPES = new StringSet(['boolean', 'number', 'string']);\n\n  // Memory for previously seen containers (object, array, map, set).\n  // Used for recursion detection, and to avoid repeated comparison.\n  //\n  // Elements are { a: val, b: val }.\n  var memory = [];\n  function useStrictEquality(a, b) {\n    return a === b;\n  }\n  function useObjectValueEquality(a, b) {\n    return a === b || a.valueOf() === b.valueOf();\n  }\n  function compareConstructors(a, b) {\n    // Comparing constructors is more strict than using `instanceof`\n    return getConstructor(a) === getConstructor(b);\n  }\n  function getConstructor(obj) {\n    var proto = Object.getPrototypeOf(obj);\n\n    // If the obj prototype descends from a null constructor, treat it\n    // as a null prototype.\n    // Ref https://github.com/qunitjs/qunit/issues/851\n    //\n    // Allow objects with no prototype, from Object.create(null), to be equivalent to\n    // plain objects that have Object as their constructor.\n    return !proto || proto.constructor === null ? Object : obj.constructor;\n  }\n  function getRegExpFlags(regexp) {\n    return 'flags' in regexp ? regexp.flags : regexp.toString().match(/[gimuy]*$/)[0];\n  }\n\n  // Specialised comparisons after entryTypeCallbacks.object, based on `objectType()`\n  var objTypeCallbacks = {\n    undefined: useStrictEquality,\n    null: useStrictEquality,\n    // Handle boxed boolean\n    boolean: useObjectValueEquality,\n    number: function number(a, b) {\n      // Handle NaN and boxed number\n      return a === b || a.valueOf() === b.valueOf() || isNaN(a.valueOf()) && isNaN(b.valueOf());\n    },\n    // Handle boxed string\n    string: useObjectValueEquality,\n    symbol: useStrictEquality,\n    date: useObjectValueEquality,\n    nan: function nan() {\n      return true;\n    },\n    regexp: function regexp(a, b) {\n      return a.source === b.source &&\n      // Include flags in the comparison\n      getRegExpFlags(a) === getRegExpFlags(b);\n    },\n    // identical reference only\n    function: useStrictEquality,\n    array: function array(a, b) {\n      if (a.length !== b.length) {\n        // Safe and faster\n        return false;\n      }\n      for (var i = 0; i < a.length; i++) {\n        if (!typeEquiv(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    },\n    // Define sets a and b to be equivalent if for each element aVal in a, there\n    // is some element bVal in b such that aVal and bVal are equivalent. Element\n    // repetitions are not counted, so these are equivalent:\n    // a = new Set( [ X={}, Y=[], Y ] );\n    // b = new Set( [ Y, X, X ] );\n    set: function set(a, b) {\n      if (a.size !== b.size) {\n        // This optimization has certain quirks because of the lack of\n        // repetition counting. For instance, adding the same\n        // (reference-identical) element to two equivalent sets can\n        // make them non-equivalent.\n        return false;\n      }\n      var outerEq = true;\n      a.forEach(function (aVal) {\n        // Short-circuit if the result is already known. (Using for...of\n        // with a break clause would be cleaner here, but it would cause\n        // a syntax error on older JavaScript implementations even if\n        // Set is unused)\n        if (!outerEq) {\n          return;\n        }\n        var innerEq = false;\n        b.forEach(function (bVal) {\n          // Likewise, short-circuit if the result is already known\n          if (innerEq) {\n            return;\n          }\n\n          // Swap out the global memory, as nested typeEquiv() would clobber it\n          var originalMemory = memory;\n          memory = [];\n          if (typeEquiv(bVal, aVal)) {\n            innerEq = true;\n          }\n          // Restore\n          memory = originalMemory;\n        });\n        if (!innerEq) {\n          outerEq = false;\n        }\n      });\n      return outerEq;\n    },\n    // Define maps a and b to be equivalent if for each key-value pair (aKey, aVal)\n    // in a, there is some key-value pair (bKey, bVal) in b such that\n    // [ aKey, aVal ] and [ bKey, bVal ] are equivalent. Key repetitions are not\n    // counted, so these are equivalent:\n    // a = new Map( [ [ {}, 1 ], [ {}, 1 ], [ [], 1 ] ] );\n    // b = new Map( [ [ {}, 1 ], [ [], 1 ], [ [], 1 ] ] );\n    map: function map(a, b) {\n      if (a.size !== b.size) {\n        // This optimization has certain quirks because of the lack of\n        // repetition counting. For instance, adding the same\n        // (reference-identical) key-value pair to two equivalent maps\n        // can make them non-equivalent.\n        return false;\n      }\n      var outerEq = true;\n      a.forEach(function (aVal, aKey) {\n        // Short-circuit if the result is already known. (Using for...of\n        // with a break clause would be cleaner here, but it would cause\n        // a syntax error on older JavaScript implementations even if\n        // Map is unused)\n        if (!outerEq) {\n          return;\n        }\n        var innerEq = false;\n        b.forEach(function (bVal, bKey) {\n          // Likewise, short-circuit if the result is already known\n          if (innerEq) {\n            return;\n          }\n\n          // Swap out the global memory, as nested typeEquiv() would clobber it\n          var originalMemory = memory;\n          memory = [];\n          if (objTypeCallbacks.array([bVal, bKey], [aVal, aKey])) {\n            innerEq = true;\n          }\n          // Restore\n          memory = originalMemory;\n        });\n        if (!innerEq) {\n          outerEq = false;\n        }\n      });\n      return outerEq;\n    }\n  };\n\n  // Entry points from typeEquiv, based on `typeof`\n  var entryTypeCallbacks = {\n    undefined: useStrictEquality,\n    null: useStrictEquality,\n    boolean: useStrictEquality,\n    number: function number(a, b) {\n      // Handle NaN\n      return a === b || isNaN(a) && isNaN(b);\n    },\n    string: useStrictEquality,\n    symbol: useStrictEquality,\n    function: useStrictEquality,\n    object: function object(a, b) {\n      // Handle memory (skip recursion)\n      if (memory.some(function (pair) {\n        return pair.a === a && pair.b === b;\n      })) {\n        return true;\n      }\n      memory.push({\n        a: a,\n        b: b\n      });\n      var aObjType = objectType(a);\n      var bObjType = objectType(b);\n      if (aObjType !== 'object' || bObjType !== 'object') {\n        // Handle literal `null`\n        // Handle: Array, Map/Set, Date, Regxp/Function, boxed primitives\n        return aObjType === bObjType && objTypeCallbacks[aObjType](a, b);\n      }\n\n      // NOTE: Literal null must not make it here as it would throw\n      if (compareConstructors(a, b) === false) {\n        return false;\n      }\n      var aProperties = [];\n      var bProperties = [];\n\n      // Be strict and go deep, no filtering with hasOwnProperty.\n      for (var i in a) {\n        // Collect a's properties\n        aProperties.push(i);\n\n        // Skip OOP methods that look the same\n        if (a.constructor !== Object && typeof a.constructor !== 'undefined' && typeof a[i] === 'function' && typeof b[i] === 'function' && a[i].toString() === b[i].toString()) {\n          continue;\n        }\n        if (!typeEquiv(a[i], b[i])) {\n          return false;\n        }\n      }\n      for (var _i in b) {\n        // Collect b's properties\n        bProperties.push(_i);\n      }\n      return objTypeCallbacks.array(aProperties.sort(), bProperties.sort());\n    }\n  };\n  function typeEquiv(a, b) {\n    // Optimization: Only perform type-specific comparison when pairs are not strictly equal.\n    if (a === b) {\n      return true;\n    }\n    var aType = _typeof(a);\n    var bType = _typeof(b);\n    if (aType !== bType) {\n      // Support comparing primitive to boxed primitives\n      // Try again after possibly unwrapping one\n      return (aType === 'object' && BOXABLE_TYPES.has(objectType(a)) ? a.valueOf() : a) === (bType === 'object' && BOXABLE_TYPES.has(objectType(b)) ? b.valueOf() : b);\n    }\n    return entryTypeCallbacks[aType](a, b);\n  }\n  function innerEquiv(a, b) {\n    var res = typeEquiv(a, b);\n    // Release any retained objects and reset recursion detection for next call\n    memory = [];\n    return res;\n  }\n\n  /**\n   * Test any two types of JavaScript values for equality.\n   *\n   * @author Philippe Rath <prathe@gmail.com>\n   * @author David Chan <david@troi.org>\n   */\n  function equiv(a, b) {\n    if (arguments.length === 2) {\n      return a === b || innerEquiv(a, b);\n    }\n\n    // Given 0 or 1 arguments, just return true (nothing to compare).\n    // Given (A,B,C,D) compare C,D then B,C then A,B.\n    var i = arguments.length - 1;\n    while (i > 0) {\n      if (!innerEquiv(arguments[i - 1], arguments[i])) {\n        return false;\n      }\n      i--;\n    }\n    return true;\n  }\n\n  /**\n   * Config object: Maintain internal state\n   * Later exposed as QUnit.config\n   * `config` initialized at top of scope\n   */\n  var config = {\n    // HTML Reporter: Modify document.title when suite is done\n    altertitle: true,\n    // TODO: Move here from /src/core.js in QUnit 3.\n    // autostart: true,\n\n    // HTML Reporter: collapse every test except the first failing test\n    // If false, all failing tests will be expanded\n    collapse: true,\n    countStepsAsOne: false,\n    // TODO: Make explicit in QUnit 3.\n    // current: undefined,\n\n    // whether or not to fail when there are zero tests\n    // defaults to `true`\n    failOnZeroTests: true,\n    // Select by pattern or case-insensitive substring match against \"moduleName: testName\"\n    filter: undefined,\n    // TODO: Make explicit in QUnit 3.\n    // fixture: undefined,\n\n    // Depth up-to which object will be dumped\n    maxDepth: 5,\n    // Select case-insensitive match of the module name\n    module: undefined,\n    // HTML Reporter: Select module/test by array of internal IDs\n    moduleId: undefined,\n    // By default, run previously failed tests first\n    // very useful in combination with \"Hide passed tests\" checked\n    reorder: true,\n    reporters: {},\n    // When enabled, all tests must call expect()\n    requireExpects: false,\n    // By default, scroll to top of the page when suite is done\n    scrolltop: true,\n    // TODO: Make explicit in QUnit 3.\n    // seed: undefined,\n\n    // The storage module to use for reordering tests\n    storage: localSessionStorage,\n    testId: undefined,\n    // The updateRate controls how often QUnit will yield the main thread\n    // between tests. This is mainly for the benefit of the HTML Reporter,\n    // so that the browser can visually paint DOM changes with test results.\n    // This also helps avoid causing browsers to prompt a warning about\n    // long-running scripts.\n    // TODO: Move here from /src/core.js in QUnit 3.\n    // updateRate: 1000,\n\n    // HTML Reporter: List of URL parameters that are given visual controls\n    urlConfig: [],\n    // Internal: The first unnamed module\n    //\n    // By being defined as the intial value for currentModule, it is the\n    // receptacle and implied parent for any global tests. It is as if we\n    // called `QUnit.module( \"\" );` before any other tests were defined.\n    //\n    // If we reach begin() and no tests were put in it, we dequeue it as if it\n    // never existed, and in that case never expose it to the events and\n    // callbacks API.\n    //\n    // When global tests are defined, then this unnamed module will execute\n    // as any other module, including moduleStart/moduleDone events etc.\n    //\n    // Since this module isn't explicitly created by the user, they have no\n    // access to add hooks for it. The hooks object is defined to comply\n    // with internal expectations of test.js, but they will be empty.\n    // To apply hooks, place tests explicitly in a QUnit.module(), and use\n    // its hooks accordingly.\n    //\n    // For global hooks that apply to all tests and all modules, use QUnit.hooks.\n    //\n    // NOTE: This is *not* a \"global module\". It is not an ancestor of all modules\n    // and tests. It is merely the parent for any tests defined globally,\n    // before the first QUnit.module(). As such, the events for this unnamed\n    // module will fire as normal, right after its last test, and *not* at\n    // the end of the test run.\n    //\n    // NOTE: This also should probably also not become a global module, unless\n    // we keep it out of the public API. For example, it would likely not\n    // improve the user interface and plugin behaviour if all modules became\n    // wrapped between the start and end events of this module, and thus\n    // needlessly add indentation, indirection, or other visible noise.\n    // Unit tests for the callbacks API would detect that as a regression.\n    currentModule: {\n      name: '',\n      tests: [],\n      childModules: [],\n      testsRun: 0,\n      testsIgnored: 0,\n      hooks: {\n        before: [],\n        beforeEach: [],\n        afterEach: [],\n        after: []\n      }\n    },\n    // Internal: Exposed to make resets easier\n    // Ref https://github.com/qunitjs/qunit/pull/1598\n    globalHooks: {},\n    // Internal: ProcessingQueue singleton, created in /src/core.js\n    pq: null,\n    // Internal: Created in /src/core.js\n    // TODO: Move definitions here in QUnit 3.0.\n    // started: 0,\n\n    // Internal state\n    _event_listeners: Object.create(null),\n    _event_memory: {},\n    _deprecated_timeout_shown: false,\n    _deprecated_countEachStep_shown: false,\n    blocking: true,\n    callbacks: {},\n    modules: [],\n    queue: [],\n    stats: {\n      all: 0,\n      bad: 0,\n      testCount: 0\n    }\n  };\n  function readFlatPreconfigBoolean(val, dest) {\n    if (typeof val === 'boolean' || typeof val === 'string' && val !== '') {\n      config[dest] = val === true || val === 'true';\n    }\n  }\n  function readFlatPreconfigNumber(val, dest) {\n    if (typeof val === 'number' || typeof val === 'string' && /^[0-9]+$/.test(val)) {\n      config[dest] = +val;\n    }\n  }\n  function readFlatPreconfigString(val, dest) {\n    if (typeof val === 'string' && val !== '') {\n      config[dest] = val;\n    }\n  }\n  function readFlatPreconfigStringOrBoolean(val, dest) {\n    if (typeof val === 'boolean' || typeof val === 'string' && val !== '') {\n      config[dest] = val;\n    }\n  }\n  function readFlatPreconfigStringArray(val, dest) {\n    if (typeof val === 'string' && val !== '') {\n      config[dest] = [val];\n    }\n  }\n  function readFlatPreconfig(obj) {\n    readFlatPreconfigBoolean(obj.qunit_config_altertitle, 'altertitle');\n    readFlatPreconfigBoolean(obj.qunit_config_autostart, 'autostart');\n    readFlatPreconfigBoolean(obj.qunit_config_collapse, 'collapse');\n    readFlatPreconfigBoolean(obj.qunit_config_failonzerotests, 'failOnZeroTests');\n    readFlatPreconfigString(obj.qunit_config_filter, 'filter');\n    readFlatPreconfigString(obj.qunit_config_fixture, 'fixture');\n    readFlatPreconfigBoolean(obj.qunit_config_hidepassed, 'hidepassed');\n    readFlatPreconfigNumber(obj.qunit_config_maxdepth, 'maxDepth');\n    readFlatPreconfigString(obj.qunit_config_module, 'module');\n    readFlatPreconfigStringArray(obj.qunit_config_moduleid, 'moduleId');\n    readFlatPreconfigBoolean(obj.qunit_config_noglobals, 'noglobals');\n    readFlatPreconfigBoolean(obj.qunit_config_notrycatch, 'notrycatch');\n    readFlatPreconfigBoolean(obj.qunit_config_reorder, 'reorder');\n    readFlatPreconfigBoolean(obj.qunit_config_requireexpects, 'requireExpects');\n    readFlatPreconfigBoolean(obj.qunit_config_scrolltop, 'scrolltop');\n    readFlatPreconfigStringOrBoolean(obj.qunit_config_seed, 'seed');\n    readFlatPreconfigStringArray(obj.qunit_config_testid, 'testId');\n    readFlatPreconfigNumber(obj.qunit_config_testtimeout, 'testTimeout');\n    var reporterKeys = {\n      qunit_config_reporters_console: 'console',\n      qunit_config_reporters_tap: 'tap'\n    };\n    for (var key in reporterKeys) {\n      var val = obj[key];\n      // Based on readFlatPreconfigBoolean\n      if (typeof val === 'boolean' || typeof val === 'string' && val !== '') {\n        var dest = reporterKeys[key];\n        config.reporters[dest] = val === true || val === 'true' || val === '1';\n      }\n    }\n  }\n  if (process$1 && 'env' in process$1) {\n    readFlatPreconfig(process$1.env);\n  }\n  readFlatPreconfig(g);\n\n  // Apply a predefined QUnit.config object\n  //\n  // Ignore QUnit.config if it is a QUnit distribution instead of preconfig.\n  // That means QUnit was loaded twice! (Use the same approach as export.js)\n  var preConfig = g && g.QUnit && !g.QUnit.version && g.QUnit.config;\n  if (preConfig) {\n    extend(config, preConfig);\n  }\n\n  // Push a loose unnamed module to the modules collection\n  config.modules.push(config.currentModule);\n  if (config.seed === 'true' || config.seed === true) {\n    // Generate a random seed\n    // Length of `Math.random()` fraction, in base 36, may vary from 6-14.\n    // Pad and take slice to a consistent 10-digit value.\n    config.seed = (Math.random().toString(36) + '0000000000').slice(2, 12);\n  }\n\n  var dump = (function () {\n    function quote(str) {\n      return '\"' + str.toString().replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"') + '\"';\n    }\n    function literal(o) {\n      return o + '';\n    }\n    function join(pre, arr, post) {\n      var s = dump.separator();\n      var inner = dump.indent(1);\n      if (arr.join) {\n        arr = arr.join(',' + s + inner);\n      }\n      if (!arr) {\n        return pre + post;\n      }\n      var base = dump.indent();\n      return [pre, inner + arr, base + post].join(s);\n    }\n    function array(arr, stack) {\n      if (dump.maxDepth && dump.depth > dump.maxDepth) {\n        return '[object Array]';\n      }\n      this.up();\n      var i = arr.length;\n      var ret = new Array(i);\n      while (i--) {\n        ret[i] = this.parse(arr[i], undefined, stack);\n      }\n      this.down();\n      return join('[', ret, ']');\n    }\n    function isArray(obj) {\n      return (\n        // Native Arrays\n        toString.call(obj) === '[object Array]' ||\n        // NodeList objects\n        typeof obj.length === 'number' && obj.item !== undefined && (obj.length ? obj.item(0) === obj[0] : obj.item(0) === null && obj[0] === undefined)\n      );\n    }\n    var reName = /^function (\\w+)/;\n    var dump = {\n      // The objType is used mostly internally, you can fix a (custom) type in advance\n      parse: function parse(obj, objType, stack) {\n        stack = stack || [];\n        var objIndex = stack.indexOf(obj);\n        if (objIndex !== -1) {\n          return \"recursion(\".concat(objIndex - stack.length, \")\");\n        }\n        objType = objType || this.typeOf(obj);\n        var parser = this.parsers[objType];\n        var parserType = _typeof(parser);\n        if (parserType === 'function') {\n          stack.push(obj);\n          var res = parser.call(this, obj, stack);\n          stack.pop();\n          return res;\n        }\n        if (parserType === 'string') {\n          return parser;\n        }\n        return '[ERROR: Missing QUnit.dump formatter for type ' + objType + ']';\n      },\n      typeOf: function typeOf(obj) {\n        var type;\n        if (obj === null) {\n          type = 'null';\n        } else if (typeof obj === 'undefined') {\n          type = 'undefined';\n        } else if (is('regexp', obj)) {\n          type = 'regexp';\n        } else if (is('date', obj)) {\n          type = 'date';\n        } else if (is('function', obj)) {\n          type = 'function';\n        } else if (obj.setInterval !== undefined && obj.document !== undefined && obj.nodeType === undefined) {\n          type = 'window';\n        } else if (obj.nodeType === 9) {\n          type = 'document';\n        } else if (obj.nodeType) {\n          type = 'node';\n        } else if (isArray(obj)) {\n          type = 'array';\n        } else if (obj.constructor === Error.prototype.constructor) {\n          type = 'error';\n        } else {\n          type = _typeof(obj);\n        }\n        return type;\n      },\n      separator: function separator() {\n        if (this.multiline) {\n          return this.HTML ? '<br />' : '\\n';\n        } else {\n          return this.HTML ? '&#160;' : ' ';\n        }\n      },\n      // Extra can be a number, shortcut for increasing-calling-decreasing\n      indent: function indent(extra) {\n        if (!this.multiline) {\n          return '';\n        }\n        var chr = this.indentChar;\n        if (this.HTML) {\n          chr = chr.replace(/\\t/g, '   ').replace(/ /g, '&#160;');\n        }\n        return new Array(this.depth + (extra || 0)).join(chr);\n      },\n      up: function up(a) {\n        this.depth += a || 1;\n      },\n      down: function down(a) {\n        this.depth -= a || 1;\n      },\n      setParser: function setParser(name, parser) {\n        this.parsers[name] = parser;\n      },\n      // The next 3 are exposed so you can use them\n      quote: quote,\n      literal: literal,\n      join: join,\n      depth: 1,\n      maxDepth: config.maxDepth,\n      // This is the list of parsers, to modify them, use dump.setParser\n      parsers: {\n        window: '[Window]',\n        document: '[Document]',\n        error: function error(_error) {\n          return 'Error(\"' + _error.message + '\")';\n        },\n        // This has been unused since QUnit 1.0.0.\n        // @todo Deprecate and remove.\n        unknown: '[Unknown]',\n        null: 'null',\n        undefined: 'undefined',\n        function: function _function(fn) {\n          var ret = 'function';\n\n          // Functions never have name in IE\n          var name = 'name' in fn ? fn.name : (reName.exec(fn) || [])[1];\n          if (name) {\n            ret += ' ' + name;\n          }\n          ret += '(';\n          ret = [ret, dump.parse(fn, 'functionArgs'), '){'].join('');\n          return join(ret, dump.parse(fn, 'functionCode'), '}');\n        },\n        array: array,\n        nodelist: array,\n        arguments: array,\n        object: function object(map, stack) {\n          var ret = [];\n          if (dump.maxDepth && dump.depth > dump.maxDepth) {\n            return '[object Object]';\n          }\n          dump.up();\n          var keys = [];\n          for (var key in map) {\n            keys.push(key);\n          }\n\n          // Some properties are not always enumerable on Error objects.\n          var nonEnumerableProperties = ['message', 'name'];\n          for (var i in nonEnumerableProperties) {\n            var _key = nonEnumerableProperties[i];\n            if (_key in map && !inArray(_key, keys)) {\n              keys.push(_key);\n            }\n          }\n          keys.sort();\n          for (var _i = 0; _i < keys.length; _i++) {\n            var _key2 = keys[_i];\n            var val = map[_key2];\n            ret.push(dump.parse(_key2, 'key') + ': ' + dump.parse(val, undefined, stack));\n          }\n          dump.down();\n          return join('{', ret, '}');\n        },\n        node: function node(_node) {\n          var open = dump.HTML ? '&lt;' : '<';\n          var close = dump.HTML ? '&gt;' : '>';\n          var tag = _node.nodeName.toLowerCase();\n          var ret = open + tag;\n          var attrs = _node.attributes;\n          if (attrs) {\n            for (var i = 0; i < attrs.length; i++) {\n              var val = attrs[i].nodeValue;\n\n              // IE6 includes all attributes in .attributes, even ones not explicitly\n              // set. Those have values like undefined, null, 0, false, \"\" or\n              // \"inherit\".\n              if (val && val !== 'inherit') {\n                ret += ' ' + attrs[i].nodeName + '=' + dump.parse(val, 'attribute');\n              }\n            }\n          }\n          ret += close;\n\n          // Show content of TextNode or CDATASection\n          if (_node.nodeType === 3 || _node.nodeType === 4) {\n            ret += _node.nodeValue;\n          }\n          return ret + open + '/' + tag + close;\n        },\n        // Function calls it internally, it's the arguments part of the function\n        functionArgs: function functionArgs(fn) {\n          var l = fn.length;\n          if (!l) {\n            return '';\n          }\n          var args = new Array(l);\n          while (l--) {\n            // 97 is 'a'\n            args[l] = String.fromCharCode(97 + l);\n          }\n          return ' ' + args.join(', ') + ' ';\n        },\n        // Object calls it internally, the key part of an item in a map\n        key: quote,\n        // Function calls it internally, it's the content of the function\n        functionCode: '[code]',\n        // Node calls it internally, it's a html attribute value\n        attribute: quote,\n        string: quote,\n        date: quote,\n        regexp: literal,\n        number: literal,\n        boolean: literal,\n        symbol: function symbol(sym) {\n          return sym.toString();\n        }\n      },\n      // If true, entities are escaped ( <, >, \\t, space and \\n )\n      HTML: false,\n      // Indentation unit\n      indentChar: '  ',\n      // If true, items in a collection, are separated by a \\n, else just a space.\n      multiline: true\n    };\n    return dump;\n  })();\n\n  // Support: IE 9\n  // Detect if the console object exists and no-op otherwise.\n  // This allows support for IE 9, which doesn't have a console\n  // object if the developer tools are not open.\n\n  // Support: IE 9\n  // Function#bind is supported, but no console.log.bind().\n\n  // Support: SpiderMonkey (mozjs 68+)\n  // The console object has a log method, but no warn method.\n\n  var Logger = {\n    warn: console$1 ? Function.prototype.bind.call(console$1.warn || console$1.log, console$1) : function () {}\n  };\n\n  var SuiteReport = /*#__PURE__*/function () {\n    function SuiteReport(name, parentSuite) {\n      _classCallCheck(this, SuiteReport);\n      this.name = name;\n      this.fullName = parentSuite ? parentSuite.fullName.concat(name) : [];\n\n      // When an \"error\" event is emitted from onUncaughtException(), the\n      // \"runEnd\" event should report the status as failed. The \"runEnd\" event data\n      // is tracked through this property (via the \"runSuite\" instance).\n      this.globalFailureCount = 0;\n      this.tests = [];\n      this.childSuites = [];\n      if (parentSuite) {\n        parentSuite.pushChildSuite(this);\n      }\n    }\n    return _createClass(SuiteReport, [{\n      key: \"start\",\n      value: function start(recordTime) {\n        if (recordTime) {\n          this._startTime = performance.now();\n        }\n        return {\n          name: this.name,\n          fullName: this.fullName.slice(),\n          tests: this.tests.map(function (test) {\n            return test.start();\n          }),\n          childSuites: this.childSuites.map(function (suite) {\n            return suite.start();\n          }),\n          testCounts: {\n            total: this.getTestCounts().total\n          }\n        };\n      }\n    }, {\n      key: \"end\",\n      value: function end(recordTime) {\n        if (recordTime) {\n          this._endTime = performance.now();\n        }\n        return {\n          name: this.name,\n          fullName: this.fullName.slice(),\n          tests: this.tests.map(function (test) {\n            return test.end();\n          }),\n          childSuites: this.childSuites.map(function (suite) {\n            return suite.end();\n          }),\n          testCounts: this.getTestCounts(),\n          runtime: this.getRuntime(),\n          status: this.getStatus()\n        };\n      }\n    }, {\n      key: \"pushChildSuite\",\n      value: function pushChildSuite(suite) {\n        this.childSuites.push(suite);\n      }\n    }, {\n      key: \"pushTest\",\n      value: function pushTest(test) {\n        this.tests.push(test);\n      }\n    }, {\n      key: \"getRuntime\",\n      value: function getRuntime() {\n        return Math.round(this._endTime - this._startTime);\n      }\n    }, {\n      key: \"getTestCounts\",\n      value: function getTestCounts() {\n        var counts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n          passed: 0,\n          failed: 0,\n          skipped: 0,\n          todo: 0,\n          total: 0\n        };\n        counts.failed += this.globalFailureCount;\n        counts.total += this.globalFailureCount;\n        counts = this.tests.reduce(function (counts, test) {\n          if (test.valid) {\n            counts[test.getStatus()]++;\n            counts.total++;\n          }\n          return counts;\n        }, counts);\n        return this.childSuites.reduce(function (counts, suite) {\n          return suite.getTestCounts(counts);\n        }, counts);\n      }\n    }, {\n      key: \"getStatus\",\n      value: function getStatus() {\n        var _this$getTestCounts = this.getTestCounts(),\n          total = _this$getTestCounts.total,\n          failed = _this$getTestCounts.failed,\n          skipped = _this$getTestCounts.skipped,\n          todo = _this$getTestCounts.todo;\n        if (failed) {\n          return 'failed';\n        } else {\n          if (skipped === total) {\n            return 'skipped';\n          } else if (todo === total) {\n            return 'todo';\n          } else {\n            return 'passed';\n          }\n        }\n      }\n    }]);\n  }();\n\n  var moduleStack = [];\n  var runSuite = new SuiteReport();\n  function isParentModuleInQueue() {\n    var modulesInQueue = config.modules.filter(function (module) {\n      return !module.ignored;\n    }).map(function (module) {\n      return module.moduleId;\n    });\n    return moduleStack.some(function (module) {\n      return modulesInQueue.includes(module.moduleId);\n    });\n  }\n  function createModule(name, testEnvironment, modifiers) {\n    var parentModule = moduleStack.length ? moduleStack.slice(-1)[0] : null;\n    var moduleName = parentModule !== null ? [parentModule.name, name].join(' > ') : name;\n    var parentSuite = parentModule ? parentModule.suiteReport : runSuite;\n    var skip = parentModule !== null && parentModule.skip || modifiers.skip;\n    var todo = parentModule !== null && parentModule.todo || modifiers.todo;\n    var env = {};\n    if (parentModule) {\n      extend(env, parentModule.testEnvironment);\n    }\n    extend(env, testEnvironment);\n    var module = {\n      name: moduleName,\n      parentModule: parentModule,\n      hooks: {\n        before: [],\n        beforeEach: [],\n        afterEach: [],\n        after: []\n      },\n      testEnvironment: env,\n      tests: [],\n      moduleId: generateHash(moduleName),\n      testsRun: 0,\n      testsIgnored: 0,\n      childModules: [],\n      suiteReport: new SuiteReport(name, parentSuite),\n      // Initialised by test.js when the module start executing,\n      // i.e. before the first test in this module (or a child).\n      stats: null,\n      // Pass along `skip` and `todo` properties from parent module, in case\n      // there is one, to childs. And use own otherwise.\n      // This property will be used to mark own tests and tests of child suites\n      // as either `skipped` or `todo`.\n      skip: skip,\n      todo: skip ? false : todo,\n      ignored: modifiers.ignored || false\n    };\n    if (parentModule) {\n      parentModule.childModules.push(module);\n    }\n    config.modules.push(module);\n    return module;\n  }\n  function setHookFromEnvironment(hooks, environment, name) {\n    var potentialHook = environment[name];\n    if (typeof potentialHook === 'function') {\n      hooks[name].push(potentialHook);\n    }\n    delete environment[name];\n  }\n  function makeSetHook(module, hookName) {\n    return function setHook(callback) {\n      if (config.currentModule !== module) {\n        Logger.warn('The `' + hookName + '` hook was called inside the wrong module (`' + config.currentModule.name + '`). ' + 'Instead, use hooks provided by the callback to the containing module (`' + module.name + '`). ' + 'This will become an error in QUnit 3.0.');\n      }\n      module.hooks[hookName].push(callback);\n    };\n  }\n  function processModule(name, options, scope) {\n    var modifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    if (typeof options === 'function') {\n      scope = options;\n      options = undefined;\n    }\n    var module = createModule(name, options, modifiers);\n\n    // Transfer any initial hooks from the options object to the 'hooks' object\n    var testEnvironment = module.testEnvironment;\n    var hooks = module.hooks;\n    setHookFromEnvironment(hooks, testEnvironment, 'before');\n    setHookFromEnvironment(hooks, testEnvironment, 'beforeEach');\n    setHookFromEnvironment(hooks, testEnvironment, 'afterEach');\n    setHookFromEnvironment(hooks, testEnvironment, 'after');\n    var moduleFns = {\n      before: makeSetHook(module, 'before'),\n      beforeEach: makeSetHook(module, 'beforeEach'),\n      afterEach: makeSetHook(module, 'afterEach'),\n      after: makeSetHook(module, 'after')\n    };\n    var prevModule = config.currentModule;\n    config.currentModule = module;\n    if (typeof scope === 'function') {\n      moduleStack.push(module);\n      try {\n        var cbReturnValue = scope.call(module.testEnvironment, moduleFns);\n        if (cbReturnValue && typeof cbReturnValue.then === 'function') {\n          Logger.warn('Returning a promise from a module callback is not supported. ' + 'Instead, use hooks for async behavior. ' + 'This will become an error in QUnit 3.0.');\n        }\n      } finally {\n        // If the module closure threw an uncaught error during the load phase,\n        // we let this bubble up to global error handlers. But, not until after\n        // we teardown internal state to ensure correct module nesting.\n        // Ref https://github.com/qunitjs/qunit/issues/1478.\n        moduleStack.pop();\n        config.currentModule = module.parentModule || prevModule;\n      }\n    }\n  }\n\n  /**\n   * Clear the SuiteReport tree of all tests and leave only current module as child suite\n   *\n   * This should be called before defining the first module.only() or test.only()\n   * because otherwise:\n   * - `runEnd.testCounts` is too high.\n   * - UI (HtmlReporter) and TAP (TapReporter) display totals too high.\n   * - Test runners like QTap might timeout because the TAP plan\n   *   would be printed as \"1..9\" even if only 2 tests are run,\n   *   which means tap-finished will wait for 3-9.\n   */\n  function clearSuiteReports(currentModule) {\n    var childSuite = null;\n    var suiteReport = currentModule.suiteReport;\n    while (suiteReport) {\n      suiteReport.tests.length = 0;\n      var i = suiteReport.childSuites.indexOf(childSuite);\n      if (i === -1) {\n        suiteReport.childSuites.length = 0;\n      } else {\n        // Reduce in-place to just currentModule.suiteReport or its intermediary\n        suiteReport.childSuites.splice(0, i);\n        suiteReport.childSuites.splice(1);\n      }\n      if (suiteReport === runSuite) {\n        suiteReport = null;\n      } else {\n        childSuite = suiteReport;\n        currentModule = currentModule.parentModule;\n        suiteReport = currentModule && currentModule.suiteReport || runSuite;\n      }\n    }\n  }\n  var focused$1 = false; // indicates that the \"only\" filter was used\n\n  function module$1(name, options, scope) {\n    var ignored = focused$1 && !isParentModuleInQueue();\n    processModule(name, options, scope, {\n      ignored: ignored\n    });\n  }\n  module$1.only = function () {\n    if (!focused$1) {\n      // Upon the first module.only() call,\n      // delete any and all previously registered modules and tests.\n      config.modules.length = 0;\n      config.queue.length = 0;\n      clearSuiteReports(config.currentModule);\n\n      // Ignore any tests declared after this block within the same\n      // module parent. https://github.com/qunitjs/qunit/issues/1645\n      config.currentModule.ignored = true;\n    }\n    focused$1 = true;\n    processModule.apply(void 0, arguments);\n  };\n  module$1.skip = function (name, options, scope) {\n    if (focused$1) {\n      return;\n    }\n    processModule(name, options, scope, {\n      skip: true\n    });\n  };\n  module$1.if = function (name, condition, options, scope) {\n    if (focused$1) {\n      return;\n    }\n    processModule(name, options, scope, {\n      skip: !condition\n    });\n  };\n  module$1.todo = function (name, options, scope) {\n    if (focused$1) {\n      return;\n    }\n    processModule(name, options, scope, {\n      todo: true\n    });\n  };\n\n  // Stacktrace cleaner to focus on the path from error source to test suite.\n  //\n  // This should reduce a raw stack trace like this:\n  //\n  // > foo.broken()@/example/foo.js\n  // > Bar@/example/bar.js\n  // > @/test/bar.test.js\n  // > @/lib/qunit.js:500:12\n  // > @/lib/qunit.js:100:28\n  // > @/lib/qunit.js:200:56\n  // > setTimeout@\n  // > @/dist/vendor.js\n  //\n  // and shorten it to show up until the end of the user's bar.test.js code.\n  //\n  // > foo.broken()@/example/foo.js\n  // > Bar@/example/bar.js\n  // > @/test/bar.test.js\n  //\n  // QUnit will obtain one example trace (once per process/pageload suffices),\n  // strip off any :<line> and :<line>:<column>, and use that as match needle,\n  // to the first QUnit-internal frames, and then stop at that point.\n  // Any later frames, including those that are outside QUnit again, will be ommitted\n  // as being uninteresting to the test, since QUnit will have either started or\n  // resumed the test. This we also clean away browser built-ins, or other\n  // vendor/bundler that may be higher up the stack.\n  //\n  // Stripping :<line>:<column> is not for prettyness, it is essential for the\n  // match needle to work, since this sample trace will by definitin not be the\n  // same line as e.g. the QUnit.test() call we're trying to identify.\n  //\n  // See also:\n  // - https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\n\n  function qunitFileName() {\n    var error = new Error();\n    if (!error.stack) {\n      // Copy of sourceFromStacktrace() to avoid circular dependency\n      // Support: IE 9-11\n      try {\n        throw error;\n      } catch (err) {\n        error = err;\n      }\n    }\n    return (error.stack || ''\n    // Copy of extractStacktrace() to avoid circular dependency\n    // Support: V8/Chrome\n    ).replace(/^error$\\n/im, '').split('\\n')[0]\n    // Global replace, because a frame like localhost:4000/lib/qunit.js:1234:50,\n    // would otherwise (harmlessly, but uselessly) remove only the port (first match).\n    // https://github.com/qunitjs/qunit/issues/1769\n    .replace(/(:\\d+)+\\)?/g, '')\n    // Remove anything prior to the last slash (Unix/Windows) from the last frame,\n    // leaving only \"qunit.js\".\n    .replace(/.+[/\\\\]/, '');\n  }\n  var fileName = qunitFileName();\n\n  /**\n   * Responsibilities:\n   * - For internal errors from QUnit itself, remove the first qunit.js frames.\n   * - For errors in Node.js, format any remaining qunit.js and node:internal\n   *   frames as internal (i.e. grey out).\n   *\n   * @param {string} stack Error#stack\n   * @param {Function} formatInternal Format a string in an \"internal\" color\n   * @param {string|null} [eToString] Error#toString() to help remove\n   *  noise from Node.js/V8 stack traces.\n   */\n  function annotateStacktrace(stack, formatInternal) {\n    var eToString = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var frames = stack.split('\\n');\n    var annotated = [];\n    if (eToString && eToString.indexOf(frames[0]) !== -1) {\n      // In Firefox and Safari e.stack starts with frame 0, but in V8 (Chrome/Node.js),\n      // e.stack starts first stringified message. Preserve this separately,\n      // so that, below, we can distinguish between internal frames on top\n      // (to remove) vs later internal frames (to format differently).\n      annotated.push(frames.shift());\n    }\n    var initialInternal = true;\n    for (var i = 0; i < frames.length; i++) {\n      var frame = frames[i];\n      var isInternal = fileName && frame.indexOf(fileName) !== -1 ||\n      // Support Node 16+: ESM-style\n      // \"at wrap (node:internal/modules/cjs/loader:1)\"\n      frame.indexOf('node:internal/') !== -1 ||\n      // Support Node 12-14 (CJS-style)\n      // \"at load (internal/modules/cjs/loader.js:7)\"\n      frame.match(/^\\s+at .+\\(internal[^)]*\\)$/) ||\n      // Support Node 10\n      // \"at listOnTimeout (timers.js:263)\"\n      // Avoid matching \"(C:)\" on Windows\n      // Avoid matching \"(http:)\"\n      frame.match(/^\\s+at .+\\([a-z]+\\.js[:\\d]*\\)$/);\n      if (!isInternal) {\n        initialInternal = false;\n      }\n      // Remove initial internal frames entirely.\n      if (!initialInternal) {\n        annotated.push(isInternal ? formatInternal(frame) : frame);\n      }\n    }\n    return annotated.join('\\n');\n  }\n  function extractStacktrace(e, offset) {\n    offset = offset === undefined ? 4 : offset;\n\n    // Support: IE9, e.stack is not supported, we will return undefined\n    if (e && e.stack) {\n      var stack = e.stack.split('\\n');\n      // In Firefox and Safari, e.stack starts immediately with the first frame.\n      //\n      // In V8 (Chrome/Node.js), the stack starts first with a stringified error message,\n      // and the real stack starting on line 2.\n      if (/^error$/i.test(stack[0])) {\n        stack.shift();\n      }\n      if (fileName) {\n        var include = [];\n        for (var i = offset; i < stack.length; i++) {\n          if (stack[i].indexOf(fileName) !== -1) {\n            break;\n          }\n          include.push(stack[i]);\n        }\n        if (include.length) {\n          return include.join('\\n');\n        }\n      }\n      return stack[offset];\n    }\n  }\n  function sourceFromStacktrace(offset) {\n    var error = new Error();\n\n    // Support: IE 9-11, iOS 7\n    // Not all browsers generate the `stack` property for `new Error()`\n    // See also https://github.com/qunitjs/qunit/issues/636\n    if (!error.stack) {\n      try {\n        throw error;\n      } catch (err) {\n        error = err;\n      }\n    }\n    return extractStacktrace(error, offset);\n  }\n\n  var Assert = /*#__PURE__*/function () {\n    function Assert(testContext) {\n      _classCallCheck(this, Assert);\n      this.test = testContext;\n    }\n    return _createClass(Assert, [{\n      key: \"timeout\",\n      value: function timeout(duration) {\n        if (typeof duration !== 'number') {\n          throw new Error('You must pass a number as the duration to assert.timeout');\n        }\n        this.test.timeout = duration;\n\n        // If a timeout has been set, clear it and reset with the new duration\n        if (config.timeout) {\n          clearTimeout(config.timeout);\n          config.timeout = null;\n          if (config.timeoutHandler && this.test.timeout > 0) {\n            this.test.internalResetTimeout(this.test.timeout);\n          }\n        }\n      }\n\n      // Documents a \"step\", which is a string value, in a test as a passing assertion\n    }, {\n      key: \"step\",\n      value: function step(message) {\n        var assertionMessage = message;\n        var result = !!message;\n        this.test.steps.push(message);\n        if (typeof message === 'undefined' || message === '') {\n          assertionMessage = 'You must provide a message to assert.step';\n        } else if (typeof message !== 'string') {\n          assertionMessage = 'You must provide a string value to assert.step';\n          result = false;\n        }\n        this.pushResult({\n          result: result,\n          message: assertionMessage\n        });\n      }\n\n      // Verifies the steps in a test match a given array of string values\n    }, {\n      key: \"verifySteps\",\n      value: function verifySteps(steps, message) {\n        // Since the steps array is just string values, we can clone with slice\n        var actualStepsClone = this.test.steps.slice();\n        this.deepEqual(actualStepsClone, steps, message);\n        this.test.stepsCount += this.test.steps.length;\n        this.test.steps.length = 0;\n      }\n    }, {\n      key: \"expect\",\n      value: function expect(asserts) {\n        if (arguments.length === 1) {\n          this.test.expected = asserts;\n        } else {\n          return this.test.expected;\n        }\n      }\n\n      // Create a new async pause and return a new function that can release the pause.\n    }, {\n      key: \"async\",\n      value: function async(count) {\n        if (count === undefined) {\n          count = 1;\n        } else if (typeof count !== 'number') {\n          throw new TypeError('async takes number as an input');\n        }\n        var requiredCalls = count;\n        return this.test.internalStop(requiredCalls);\n      }\n    }, {\n      key: \"closeTo\",\n      value: function closeTo(actual, expected, delta, message) {\n        if (typeof delta !== 'number') {\n          throw new TypeError('closeTo() requires a delta argument');\n        }\n        this.pushResult({\n          result: Math.abs(actual - expected) <= delta,\n          actual: actual,\n          expected: expected,\n          message: message || \"value should be within \".concat(delta, \" inclusive\")\n        });\n      }\n\n      // Alias of pushResult.\n    }, {\n      key: \"push\",\n      value: function push(result, actual, expected, message, negative) {\n        var currentAssert = this instanceof Assert ? this : config.current.assert;\n        return currentAssert.pushResult({\n          result: result,\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: negative\n        });\n      }\n\n      // Public API to internal test.pushResult()\n    }, {\n      key: \"pushResult\",\n      value: function pushResult(resultInfo) {\n        // Destructure of resultInfo = { result, actual, expected, message, negative }\n        var assert = this;\n        var currentTest = assert instanceof Assert && assert.test || config.current;\n\n        // Backwards compatibility fix.\n        // Allows the direct use of global exported assertions and QUnit.assert.*\n        // Although, it's use is not recommended as it can leak assertions\n        // to other tests from async tests, because we only get a reference to the current test,\n        // not exactly the test where assertion were intended to be called.\n        if (!currentTest) {\n          throw new Error('assertion outside test context, in ' + sourceFromStacktrace(2));\n        }\n        if (!(assert instanceof Assert)) {\n          assert = currentTest.assert;\n        }\n        return assert.test.pushResult(resultInfo);\n      }\n    }, {\n      key: \"ok\",\n      value: function ok(result, message) {\n        if (!message) {\n          message = result ? 'okay' : \"failed, expected argument to be truthy, was: \".concat(dump.parse(result));\n        }\n        this.pushResult({\n          result: !!result,\n          actual: result,\n          expected: true,\n          message: message\n        });\n      }\n    }, {\n      key: \"notOk\",\n      value: function notOk(result, message) {\n        if (!message) {\n          message = !result ? 'okay' : \"failed, expected argument to be falsy, was: \".concat(dump.parse(result));\n        }\n        this.pushResult({\n          result: !result,\n          actual: result,\n          expected: false,\n          message: message\n        });\n      }\n    }, {\n      key: \"true\",\n      value: function _true(result, message) {\n        this.pushResult({\n          result: result === true,\n          actual: result,\n          expected: true,\n          message: message\n        });\n      }\n    }, {\n      key: \"false\",\n      value: function _false(result, message) {\n        this.pushResult({\n          result: result === false,\n          actual: result,\n          expected: false,\n          message: message\n        });\n      }\n    }, {\n      key: \"equal\",\n      value: function equal(actual, expected, message) {\n        this.pushResult({\n          // eslint-disable-next-line eqeqeq\n          result: expected == actual,\n          actual: actual,\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: \"notEqual\",\n      value: function notEqual(actual, expected, message) {\n        this.pushResult({\n          // eslint-disable-next-line eqeqeq\n          result: expected != actual,\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: true\n        });\n      }\n    }, {\n      key: \"propEqual\",\n      value: function propEqual(actual, expected, message) {\n        actual = objectValues(actual);\n        expected = objectValues(expected);\n        this.pushResult({\n          result: equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: \"notPropEqual\",\n      value: function notPropEqual(actual, expected, message) {\n        actual = objectValues(actual);\n        expected = objectValues(expected);\n        this.pushResult({\n          result: !equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: true\n        });\n      }\n    }, {\n      key: \"propContains\",\n      value: function propContains(actual, expected, message) {\n        actual = objectValuesSubset(actual, expected);\n\n        // The expected parameter is usually a plain object, but clone it for\n        // consistency with propEqual(), and to make it easy to explain that\n        // inheritence is not considered (on either side), and to support\n        // recursively checking subsets of nested objects.\n        expected = objectValues(expected, false);\n        this.pushResult({\n          result: equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: \"notPropContains\",\n      value: function notPropContains(actual, expected, message) {\n        actual = objectValuesSubset(actual, expected);\n        expected = objectValues(expected);\n        this.pushResult({\n          result: !equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: true\n        });\n      }\n    }, {\n      key: \"deepEqual\",\n      value: function deepEqual(actual, expected, message) {\n        this.pushResult({\n          result: equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: \"notDeepEqual\",\n      value: function notDeepEqual(actual, expected, message) {\n        this.pushResult({\n          result: !equiv(actual, expected),\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: true\n        });\n      }\n    }, {\n      key: \"strictEqual\",\n      value: function strictEqual(actual, expected, message) {\n        this.pushResult({\n          result: expected === actual,\n          actual: actual,\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: \"notStrictEqual\",\n      value: function notStrictEqual(actual, expected, message) {\n        this.pushResult({\n          result: expected !== actual,\n          actual: actual,\n          expected: expected,\n          message: message,\n          negative: true\n        });\n      }\n    }, {\n      key: 'throws',\n      value: function throws(block, expected, message) {\n        var _validateExpectedExce = validateExpectedExceptionArgs(expected, message, 'throws');\n        var _validateExpectedExce2 = _slicedToArray(_validateExpectedExce, 2);\n        expected = _validateExpectedExce2[0];\n        message = _validateExpectedExce2[1];\n        var currentTest = this instanceof Assert && this.test || config.current;\n        if (typeof block !== 'function') {\n          currentTest.assert.pushResult({\n            result: false,\n            actual: block,\n            message: 'The value provided to `assert.throws` in ' + '\"' + currentTest.testName + '\" was not a function.'\n          });\n          return;\n        }\n        var actual;\n        var result = false;\n        currentTest.ignoreGlobalErrors = true;\n        try {\n          block.call(currentTest.testEnvironment);\n        } catch (e) {\n          actual = e;\n        }\n        currentTest.ignoreGlobalErrors = false;\n        if (actual) {\n          var _validateException = validateException(actual, expected, message);\n          var _validateException2 = _slicedToArray(_validateException, 3);\n          result = _validateException2[0];\n          expected = _validateException2[1];\n          message = _validateException2[2];\n        }\n        currentTest.assert.pushResult({\n          result: result,\n          // undefined if it didn't throw\n          actual: actual && errorString(actual),\n          expected: expected,\n          message: message\n        });\n      }\n    }, {\n      key: \"rejects\",\n      value: function rejects(promise, expected, message) {\n        var _validateExpectedExce3 = validateExpectedExceptionArgs(expected, message, 'rejects');\n        var _validateExpectedExce4 = _slicedToArray(_validateExpectedExce3, 2);\n        expected = _validateExpectedExce4[0];\n        message = _validateExpectedExce4[1];\n        var currentTest = this instanceof Assert && this.test || config.current;\n        var then = promise && promise.then;\n        if (typeof then !== 'function') {\n          currentTest.assert.pushResult({\n            result: false,\n            message: 'The value provided to `assert.rejects` in ' + '\"' + currentTest.testName + '\" was not a promise.',\n            actual: promise\n          });\n          return;\n        }\n        var done = this.async();\n        return then.call(promise, function handleFulfillment() {\n          currentTest.assert.pushResult({\n            result: false,\n            message: 'The promise returned by the `assert.rejects` callback in ' + '\"' + currentTest.testName + '\" did not reject.',\n            actual: promise\n          });\n          done();\n        }, function handleRejection(actual) {\n          var result;\n          var _validateException3 = validateException(actual, expected, message);\n          var _validateException4 = _slicedToArray(_validateException3, 3);\n          result = _validateException4[0];\n          expected = _validateException4[1];\n          message = _validateException4[2];\n          currentTest.assert.pushResult({\n            result: result,\n            // leave rejection value of undefined as-is\n            actual: actual && errorString(actual),\n            expected: expected,\n            message: message\n          });\n          done();\n        });\n      }\n    }]);\n  }();\n  function validateExpectedExceptionArgs(expected, message, assertionMethod) {\n    var expectedType = objectType(expected);\n\n    // 'expected' is optional unless doing string comparison\n    if (expectedType === 'string') {\n      if (message === undefined) {\n        message = expected;\n        expected = undefined;\n        return [expected, message];\n      } else {\n        throw new Error('assert.' + assertionMethod + ' does not accept a string value for the expected argument.\\n' + 'Use a non-string object value (e.g. RegExp or validator function) ' + 'instead if necessary.');\n      }\n    }\n    var valid = !expected ||\n    // TODO: be more explicit here\n    expectedType === 'regexp' || expectedType === 'function' || expectedType === 'object';\n    if (!valid) {\n      throw new Error('Invalid expected value type (' + expectedType + ') ' + 'provided to assert.' + assertionMethod + '.');\n    }\n    return [expected, message];\n  }\n  function validateException(actual, expected, message) {\n    var result = false;\n    var expectedType = objectType(expected);\n\n    // These branches should be exhaustive, based on validation done in validateExpectedException\n\n    // We don't want to validate\n    if (!expected) {\n      result = true;\n\n      // Expected is a regexp\n    } else if (expectedType === 'regexp') {\n      result = expected.test(errorString(actual));\n\n      // Log the string form of the regexp\n      expected = String(expected);\n\n      // Expected is a constructor, maybe an Error constructor.\n      // Note the extra check on its prototype - this is an implicit\n      // requirement of \"instanceof\", else it will throw a TypeError.\n    } else if (expectedType === 'function' && expected.prototype !== undefined && actual instanceof expected) {\n      result = true;\n\n      // Expected is an Error object\n    } else if (expectedType === 'object') {\n      result = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message;\n\n      // Log the string form of the Error object\n      expected = errorString(expected);\n\n      // Expected is a validation function which returns true if validation passed\n    } else if (expectedType === 'function') {\n      // protect against accidental semantics which could hard error in the test\n      try {\n        result = expected.call({}, actual) === true;\n        expected = null;\n      } catch (e) {\n        // assign the \"expected\" to a nice error string to communicate the local failure to the user\n        expected = errorString(e);\n      }\n    }\n    return [result, expected, message];\n  }\n\n  // Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n  // Known to us are: Closure Compiler, Narwhal\n  // eslint-disable-next-line dot-notation\n  Assert.prototype.raises = Assert.prototype['throws'];\n\n  var SUPPORTED_EVENTS = ['error', 'runStart', 'suiteStart', 'testStart', 'assertion', 'testEnd', 'suiteEnd', 'runEnd'];\n  var MEMORY_EVENTS = ['error', 'runEnd'];\n\n  /**\n   * Emits an event with the specified data to all currently registered listeners.\n   * Callbacks will fire in the order in which they are registered (FIFO). This\n   * function is not exposed publicly; it is used by QUnit internals to emit\n   * logging events.\n   *\n   * @private\n   * @method emit\n   * @param {string} eventName\n   * @param {Object} data\n   * @return {void}\n   */\n  function emit(eventName, data) {\n    if (typeof eventName !== 'string') {\n      throw new TypeError('eventName must be a string when emitting an event');\n    }\n\n    // Clone the callbacks in case one of them registers a new callback\n    var originalCallbacks = config._event_listeners[eventName];\n    var callbacks = originalCallbacks ? _toConsumableArray(originalCallbacks) : [];\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](data);\n    }\n    if (inArray(eventName, MEMORY_EVENTS)) {\n      config._event_memory[eventName] = data;\n    }\n  }\n\n  /**\n   * Registers a callback as a listener to the specified event.\n   *\n   * @public\n   * @method on\n   * @param {string} eventName\n   * @param {Function} callback\n   * @return {void}\n   */\n  function on(eventName, callback) {\n    if (typeof eventName !== 'string') {\n      throw new TypeError('eventName must be a string when registering a listener');\n    } else if (!inArray(eventName, SUPPORTED_EVENTS)) {\n      var events = SUPPORTED_EVENTS.join(', ');\n      throw new Error(\"\\\"\".concat(eventName, \"\\\" is not a valid event; must be one of: \").concat(events, \".\"));\n    } else if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function when registering a listener');\n    }\n    var listeners = config._event_listeners[eventName] || (config._event_listeners[eventName] = []);\n\n    // Don't register the same callback more than once\n    if (!inArray(callback, listeners)) {\n      listeners.push(callback);\n      if (config._event_memory[eventName] !== undefined) {\n        callback(config._event_memory[eventName]);\n      }\n    }\n  }\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function commonjsRequire (path) {\n  \tthrow new Error('Could not dynamically require \"' + path + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n  }\n\n  var promisePolyfill = {exports: {}};\n\n  (function () {\n\n    /** @suppress {undefinedVars} */\n    var globalNS = function () {\n      // the only reliable means to get the global object is\n      // `Function('return this')()`\n      // However, this causes CSP violations in Chrome apps.\n      if (typeof globalThis !== 'undefined') {\n        return globalThis;\n      }\n      if (typeof self !== 'undefined') {\n        return self;\n      }\n      if (typeof window !== 'undefined') {\n        return window;\n      }\n      if (typeof commonjsGlobal !== 'undefined') {\n        return commonjsGlobal;\n      }\n      throw new Error('unable to locate global object');\n    }();\n\n    // Expose the polyfill if Promise is undefined or set to a\n    // non-function value. The latter can be due to a named HTMLElement\n    // being exposed by browsers for legacy reasons.\n    // https://github.com/taylorhakes/promise-polyfill/issues/114\n    if (typeof globalNS['Promise'] === 'function') {\n      promisePolyfill.exports = globalNS['Promise'];\n      return;\n    }\n\n    /**\n     * @this {Promise}\n     */\n    function finallyConstructor(callback) {\n      var constructor = this.constructor;\n      return this.then(function (value) {\n        // @ts-ignore\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        // @ts-ignore\n        return constructor.resolve(callback()).then(function () {\n          // @ts-ignore\n          return constructor.reject(reason);\n        });\n      });\n    }\n    function allSettled(arr) {\n      var P = this;\n      return new P(function (resolve, reject) {\n        if (!(arr && typeof arr.length !== 'undefined')) {\n          return reject(new TypeError(_typeof(arr) + ' ' + arr + ' is not iterable(cannot read property Symbol(Symbol.iterator))'));\n        }\n        var args = Array.prototype.slice.call(arr);\n        if (args.length === 0) return resolve([]);\n        var remaining = args.length;\n        function res(i, val) {\n          if (val && (_typeof(val) === 'object' || typeof val === 'function')) {\n            var then = val.then;\n            if (typeof then === 'function') {\n              then.call(val, function (val) {\n                res(i, val);\n              }, function (e) {\n                args[i] = {\n                  status: 'rejected',\n                  reason: e\n                };\n                if (--remaining === 0) {\n                  resolve(args);\n                }\n              });\n              return;\n            }\n          }\n          args[i] = {\n            status: 'fulfilled',\n            value: val\n          };\n          if (--remaining === 0) {\n            resolve(args);\n          }\n        }\n        for (var i = 0; i < args.length; i++) {\n          res(i, args[i]);\n        }\n      });\n    }\n\n    // Store setTimeout reference so promise-polyfill will be unaffected by\n    // other code modifying setTimeout (like sinon.useFakeTimers())\n    var setTimeoutFunc = setTimeout;\n    function isArray(x) {\n      return Boolean(x && typeof x.length !== 'undefined');\n    }\n    function noop() {}\n\n    // Polyfill for Function.prototype.bind\n    function bind(fn, thisArg) {\n      return function () {\n        fn.apply(thisArg, arguments);\n      };\n    }\n\n    /**\n     * @constructor\n     * @param {Function} fn\n     */\n    function Promise(fn) {\n      if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');\n      if (typeof fn !== 'function') throw new TypeError('not a function');\n      /** @type {!number} */\n      this._state = 0;\n      /** @type {!boolean} */\n      this._handled = false;\n      /** @type {Promise|undefined} */\n      this._value = undefined;\n      /** @type {!Array<!Function>} */\n      this._deferreds = [];\n      doResolve(fn, this);\n    }\n    function handle(self, deferred) {\n      while (self._state === 3) {\n        self = self._value;\n      }\n      if (self._state === 0) {\n        self._deferreds.push(deferred);\n        return;\n      }\n      self._handled = true;\n      Promise._immediateFn(function () {\n        var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n        if (cb === null) {\n          (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n          return;\n        }\n        var ret;\n        try {\n          ret = cb(self._value);\n        } catch (e) {\n          reject(deferred.promise, e);\n          return;\n        }\n        resolve(deferred.promise, ret);\n      });\n    }\n    function resolve(self, newValue) {\n      try {\n        // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n        if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n        if (newValue && (_typeof(newValue) === 'object' || typeof newValue === 'function')) {\n          var then = newValue.then;\n          if (newValue instanceof Promise) {\n            self._state = 3;\n            self._value = newValue;\n            finale(self);\n            return;\n          } else if (typeof then === 'function') {\n            doResolve(bind(then, newValue), self);\n            return;\n          }\n        }\n        self._state = 1;\n        self._value = newValue;\n        finale(self);\n      } catch (e) {\n        reject(self, e);\n      }\n    }\n    function reject(self, newValue) {\n      self._state = 2;\n      self._value = newValue;\n      finale(self);\n    }\n    function finale(self) {\n      if (self._state === 2 && self._deferreds.length === 0) {\n        Promise._immediateFn(function () {\n          if (!self._handled) {\n            Promise._unhandledRejectionFn(self._value);\n          }\n        });\n      }\n      for (var i = 0, len = self._deferreds.length; i < len; i++) {\n        handle(self, self._deferreds[i]);\n      }\n      self._deferreds = null;\n    }\n\n    /**\n     * @constructor\n     */\n    function Handler(onFulfilled, onRejected, promise) {\n      this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n      this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n      this.promise = promise;\n    }\n\n    /**\n     * Take a potentially misbehaving resolver function and make sure\n     * onFulfilled and onRejected are only called once.\n     *\n     * Makes no guarantees about asynchrony.\n     */\n    function doResolve(fn, self) {\n      var done = false;\n      try {\n        fn(function (value) {\n          if (done) return;\n          done = true;\n          resolve(self, value);\n        }, function (reason) {\n          if (done) return;\n          done = true;\n          reject(self, reason);\n        });\n      } catch (ex) {\n        if (done) return;\n        done = true;\n        reject(self, ex);\n      }\n    }\n    Promise.prototype['catch'] = function (onRejected) {\n      return this.then(null, onRejected);\n    };\n    Promise.prototype.then = function (onFulfilled, onRejected) {\n      // @ts-ignore\n      var prom = new this.constructor(noop);\n      handle(this, new Handler(onFulfilled, onRejected, prom));\n      return prom;\n    };\n    Promise.prototype['finally'] = finallyConstructor;\n    Promise.all = function (arr) {\n      return new Promise(function (resolve, reject) {\n        if (!isArray(arr)) {\n          return reject(new TypeError('Promise.all accepts an array'));\n        }\n        var args = Array.prototype.slice.call(arr);\n        if (args.length === 0) return resolve([]);\n        var remaining = args.length;\n        function res(i, val) {\n          try {\n            if (val && (_typeof(val) === 'object' || typeof val === 'function')) {\n              var then = val.then;\n              if (typeof then === 'function') {\n                then.call(val, function (val) {\n                  res(i, val);\n                }, reject);\n                return;\n              }\n            }\n            args[i] = val;\n            if (--remaining === 0) {\n              resolve(args);\n            }\n          } catch (ex) {\n            reject(ex);\n          }\n        }\n        for (var i = 0; i < args.length; i++) {\n          res(i, args[i]);\n        }\n      });\n    };\n    Promise.allSettled = allSettled;\n    Promise.resolve = function (value) {\n      if (value && _typeof(value) === 'object' && value.constructor === Promise) {\n        return value;\n      }\n      return new Promise(function (resolve) {\n        resolve(value);\n      });\n    };\n    Promise.reject = function (value) {\n      return new Promise(function (resolve, reject) {\n        reject(value);\n      });\n    };\n    Promise.race = function (arr) {\n      return new Promise(function (resolve, reject) {\n        if (!isArray(arr)) {\n          return reject(new TypeError('Promise.race accepts an array'));\n        }\n        for (var i = 0, len = arr.length; i < len; i++) {\n          Promise.resolve(arr[i]).then(resolve, reject);\n        }\n      });\n    };\n\n    // Use polyfill for setImmediate for performance gains\n    // @ts-ignore\n    if (typeof setImmediate === 'function') {\n      // @ts-ignore\n      var setImmediateFunc = setImmediate;\n      Promise._immediateFn = function (fn) {\n        setImmediateFunc(fn);\n      };\n    } else {\n      Promise._immediateFn = function (fn) {\n        setTimeoutFunc(fn, 0);\n      };\n    }\n    Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n      if (typeof console !== 'undefined' && console) {\n        console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n      }\n    };\n    promisePolyfill.exports = Promise;\n  })();\n  var _Promise = promisePolyfill.exports;\n\n  // Register logging callbacks\n  function registerLoggingCallbacks(obj) {\n    var callbackNames = ['begin', 'done', 'log', 'testStart', 'testDone', 'moduleStart', 'moduleDone'];\n    function registerLoggingCallback(key) {\n      return function loggingCallback(callback) {\n        if (typeof callback !== 'function') {\n          throw new Error('Callback parameter must be a function');\n        }\n        config.callbacks[key].push(callback);\n      };\n    }\n    for (var i = 0; i < callbackNames.length; i++) {\n      var key = callbackNames[i];\n\n      // Initialize key collection of logging callback\n      if (typeof config.callbacks[key] === 'undefined') {\n        config.callbacks[key] = [];\n      }\n      obj[key] = registerLoggingCallback(key);\n    }\n  }\n  function runLoggingCallbacks(key, args) {\n    var callbacks = config.callbacks[key];\n\n    // Handling 'log' callbacks separately. Unlike the other callbacks,\n    // the log callback is not controlled by the processing queue,\n    // but rather used by asserts. Hence to promisfy the 'log' callback\n    // would mean promisfying each step of a test\n    if (key === 'log') {\n      callbacks.map(function (callback) {\n        return callback(args);\n      });\n      return;\n    }\n\n    // ensure that each callback is executed serially\n    var promiseChain = _Promise.resolve();\n    callbacks.forEach(function (callback) {\n      promiseChain = promiseChain.then(function () {\n        return _Promise.resolve(callback(args));\n      });\n    });\n    return promiseChain;\n  }\n\n  var TestReport = /*#__PURE__*/function () {\n    function TestReport(name, suite, options) {\n      _classCallCheck(this, TestReport);\n      this.name = name;\n      this.suiteName = suite.name;\n      this.fullName = suite.fullName.concat(name);\n      this.runtime = 0;\n      this.assertions = [];\n      this.skipped = !!options.skip;\n      this.todo = !!options.todo;\n      this.valid = options.valid;\n      this._startTime = 0;\n      this._endTime = 0;\n      suite.pushTest(this);\n    }\n    return _createClass(TestReport, [{\n      key: \"start\",\n      value: function start(recordTime) {\n        if (recordTime) {\n          this._startTime = performance.now();\n        }\n        return {\n          name: this.name,\n          suiteName: this.suiteName,\n          fullName: this.fullName.slice()\n        };\n      }\n    }, {\n      key: \"end\",\n      value: function end(recordTime) {\n        if (recordTime) {\n          this._endTime = performance.now();\n        }\n        return extend(this.start(), {\n          runtime: this.getRuntime(),\n          status: this.getStatus(),\n          errors: this.getFailedAssertions(),\n          assertions: this.getAssertions()\n        });\n      }\n    }, {\n      key: \"pushAssertion\",\n      value: function pushAssertion(assertion) {\n        this.assertions.push(assertion);\n      }\n    }, {\n      key: \"getRuntime\",\n      value: function getRuntime() {\n        return Math.round(this._endTime - this._startTime);\n      }\n    }, {\n      key: \"getStatus\",\n      value: function getStatus() {\n        if (this.skipped) {\n          return 'skipped';\n        }\n        var testPassed = this.getFailedAssertions().length > 0 ? this.todo : !this.todo;\n        if (!testPassed) {\n          return 'failed';\n        } else if (this.todo) {\n          return 'todo';\n        } else {\n          return 'passed';\n        }\n      }\n    }, {\n      key: \"getFailedAssertions\",\n      value: function getFailedAssertions() {\n        return this.assertions.filter(function (assertion) {\n          return !assertion.passed;\n        });\n      }\n    }, {\n      key: \"getAssertions\",\n      value: function getAssertions() {\n        return this.assertions.slice();\n      }\n\n      // Remove actual and expected values from assertions. This is to prevent\n      // leaking memory throughout a test suite.\n    }, {\n      key: \"slimAssertions\",\n      value: function slimAssertions() {\n        this.assertions = this.assertions.map(function (assertion) {\n          delete assertion.actual;\n          delete assertion.expected;\n          return assertion;\n        });\n      }\n    }]);\n  }();\n\n  function Test(settings) {\n    this.expected = null;\n    this.assertions = [];\n    this.module = config.currentModule;\n    this.steps = [];\n    // This powers the QUnit.config.countStepsAsOne feature.\n    // https://github.com/qunitjs/qunit/pull/1775\n    this.stepsCount = 0;\n    this.timeout = undefined;\n    this.data = undefined;\n    this.withData = false;\n    this.pauses = new StringMap();\n    this.nextPauseId = 1;\n\n    // For the most common case, we have:\n    // - 0: new Test\n    // - 1: addTest\n    // - 2: QUnit.test\n    // - 3: user file\n    //\n    // This needs is customised by test.each()\n    this.stackOffset = 3;\n    extend(this, settings);\n\n    // If a module is skipped, all its tests and the tests of the child suites\n    // should be treated as skipped even if they are defined as `only` or `todo`.\n    // As for `todo` module, all its tests will be treated as `todo` except for\n    // tests defined as `skip` which will be left intact.\n    //\n    // So, if a test is defined as `todo` and is inside a skipped module, we should\n    // then treat that test as if was defined as `skip`.\n    if (this.module.skip) {\n      this.skip = true;\n      this.todo = false;\n\n      // Skipped tests should be left intact\n    } else if (this.module.todo && !this.skip) {\n      this.todo = true;\n    }\n\n    // Queuing a late test after the run has ended is not allowed.\n    // This was once supported for internal use by QUnit.onError().\n    // Ref https://github.com/qunitjs/qunit/issues/1377\n    if (config.pq.finished) {\n      // Using this for anything other than onError(), such as testing in QUnit.done(),\n      // is unstable and will likely result in the added tests being ignored by CI.\n      // (Meaning the CI passes irregardless of the added tests).\n      //\n      // TODO: Make this an error in QUnit 3.0\n      // throw new Error( \"Unexpected test after runEnd\" );\n      Logger.warn('Unexpected test after runEnd. This is unstable and will fail in QUnit 3.0.');\n      return;\n    }\n    if (!this.skip && typeof this.callback !== 'function') {\n      var method = this.todo ? 'QUnit.todo' : 'QUnit.test';\n      throw new TypeError(\"You must provide a callback to \".concat(method, \"(\\\"\").concat(this.testName, \"\\\")\"));\n    }\n\n    // Register unique strings\n    for (var i = 0, l = this.module.tests; i < l.length; i++) {\n      if (this.module.tests[i].name === this.testName) {\n        this.testName += ' ';\n      }\n    }\n    this.testId = generateHash(this.module.name, this.testName);\n\n    // No validation after this. Beyond this point, failures must be recorded as\n    // a completed test with errors, instead of early bail out.\n    // Otherwise, internals may be left in an inconsistent state.\n    // Ref https://github.com/qunitjs/qunit/issues/1514\n\n    ++Test.count;\n    this.errorForStack = new Error();\n    if (this.callback && this.callback.validTest) {\n      // Omit the test-level trace for the internal \"No tests\" test failure,\n      // There is already an assertion-level trace, and that's noisy enough\n      // as it is.\n      this.errorForStack.stack = undefined;\n    }\n    this.testReport = new TestReport(this.testName, this.module.suiteReport, {\n      todo: this.todo,\n      skip: this.skip,\n      valid: this.valid()\n    });\n    this.module.tests.push({\n      name: this.testName,\n      testId: this.testId,\n      skip: !!this.skip\n    });\n    if (this.skip) {\n      // Skipped tests will fully ignore (and dereference for garbage collect) any sent callback\n      this.callback = function () {};\n      this.async = false;\n      this.expected = 0;\n    } else {\n      this.assert = new Assert(this);\n    }\n  }\n  Test.count = 0;\n  function getNotStartedModules(startModule) {\n    var module = startModule;\n    var modules = [];\n    while (module && module.testsRun === 0) {\n      modules.push(module);\n      module = module.parentModule;\n    }\n\n    // The above push modules from the child to the parent\n    // return a reversed order with the top being the top most parent module\n    return modules.reverse();\n  }\n  Test.prototype = {\n    // Use a getter to avoid computing a stack trace (which can be expensive),\n    // This is displayed by the HTML Reporter, but most other integrations do\n    // not access it.\n    get stack() {\n      return extractStacktrace(this.errorForStack, this.stackOffset);\n    },\n    before: function before() {\n      var _this = this;\n      var module = this.module;\n      var notStartedModules = getNotStartedModules(module);\n\n      // ensure the callbacks are executed serially for each module\n      var moduleStartChain = _Promise.resolve();\n      notStartedModules.forEach(function (startModule) {\n        moduleStartChain = moduleStartChain.then(function () {\n          startModule.stats = {\n            all: 0,\n            bad: 0,\n            started: performance.now()\n          };\n          emit('suiteStart', startModule.suiteReport.start(true));\n          return runLoggingCallbacks('moduleStart', {\n            name: startModule.name,\n            tests: startModule.tests\n          });\n        });\n      });\n      return moduleStartChain.then(function () {\n        config.current = _this;\n        _this.testEnvironment = extend({}, module.testEnvironment);\n        _this.started = performance.now();\n        emit('testStart', _this.testReport.start(true));\n        return runLoggingCallbacks('testStart', {\n          name: _this.testName,\n          module: module.name,\n          testId: _this.testId,\n          previousFailure: _this.previousFailure\n        }).then(function () {\n          if (!config.pollution) {\n            saveGlobal();\n          }\n        });\n      });\n    },\n    run: function run() {\n      config.current = this;\n      if (config.notrycatch) {\n        runTest(this);\n        return;\n      }\n      try {\n        runTest(this);\n      } catch (e) {\n        this.pushFailure('Died on test #' + (this.assertions.length + 1) + ': ' + (e.message || e) + '\\n' + this.stack, extractStacktrace(e, 0));\n\n        // Else next test will carry the responsibility\n        saveGlobal();\n\n        // Restart the tests if they're blocking\n        if (config.blocking) {\n          internalRecover(this);\n        }\n      }\n      function runTest(test) {\n        var promise;\n        if (test.withData) {\n          promise = test.callback.call(test.testEnvironment, test.assert, test.data);\n        } else {\n          promise = test.callback.call(test.testEnvironment, test.assert);\n        }\n        test.resolvePromise(promise);\n\n        // If the test has an async \"pause\" on it, but the timeout is 0, then we push a\n        // failure as the test should be synchronous.\n        if (test.timeout === 0 && test.pauses.size > 0) {\n          pushFailure('Test did not finish synchronously even though assert.timeout( 0 ) was used.', sourceFromStacktrace(2));\n        }\n      }\n    },\n    after: function after() {\n      checkPollution();\n    },\n    queueGlobalHook: function queueGlobalHook(hook, hookName) {\n      var _this2 = this;\n      var runHook = function runHook() {\n        config.current = _this2;\n        var promise;\n        if (config.notrycatch) {\n          promise = hook.call(_this2.testEnvironment, _this2.assert);\n        } else {\n          try {\n            promise = hook.call(_this2.testEnvironment, _this2.assert);\n          } catch (error) {\n            _this2.pushFailure('Global ' + hookName + ' failed on ' + _this2.testName + ': ' + errorString(error), extractStacktrace(error, 0));\n            return;\n          }\n        }\n        _this2.resolvePromise(promise, hookName);\n      };\n      return runHook;\n    },\n    queueHook: function queueHook(hook, hookName, hookOwner) {\n      var _this3 = this;\n      var callHook = function callHook() {\n        var promise = hook.call(_this3.testEnvironment, _this3.assert);\n        _this3.resolvePromise(promise, hookName);\n      };\n      var runHook = function runHook() {\n        if (hookName === 'before') {\n          if (hookOwner.testsRun !== 0) {\n            return;\n          }\n          _this3.preserveEnvironment = true;\n        }\n\n        // The 'after' hook should only execute when there are not tests left and\n        // when the 'after' and 'finish' tasks are the only tasks left to process\n        if (hookName === 'after' && !lastTestWithinModuleExecuted(hookOwner) && (config.queue.length > 0 || config.pq.taskCount() > 2)) {\n          return;\n        }\n        config.current = _this3;\n        if (config.notrycatch) {\n          callHook();\n          return;\n        }\n        try {\n          // This try-block includes the indirect call to resolvePromise, which shouldn't\n          // have to be inside try-catch. But, since we support any user-provided thenable\n          // object, the thenable might throw in some unexpected way.\n          // This subtle behaviour is undocumented. To avoid new failures in minor releases\n          // we will not change this until QUnit 3.\n          // TODO: In QUnit 3, reduce this try-block to just hook.call(), matching\n          // the simplicity of queueGlobalHook.\n          callHook();\n        } catch (error) {\n          _this3.pushFailure(hookName + ' failed on ' + _this3.testName + ': ' + (error.message || error), extractStacktrace(error, 0));\n        }\n      };\n      return runHook;\n    },\n    // Currently only used for module level hooks, can be used to add global level ones\n    hooks: function hooks(handler) {\n      var hooks = [];\n      function processGlobalhooks(test) {\n        if ((handler === 'beforeEach' || handler === 'afterEach') && config.globalHooks[handler]) {\n          for (var i = 0; i < config.globalHooks[handler].length; i++) {\n            hooks.push(test.queueGlobalHook(config.globalHooks[handler][i], handler));\n          }\n        }\n      }\n      function processHooks(test, module) {\n        if (module.parentModule) {\n          processHooks(test, module.parentModule);\n        }\n        if (module.hooks[handler].length) {\n          for (var i = 0; i < module.hooks[handler].length; i++) {\n            hooks.push(test.queueHook(module.hooks[handler][i], handler, module));\n          }\n        }\n      }\n\n      // Hooks are ignored on skipped tests\n      if (!this.skip) {\n        processGlobalhooks(this);\n        processHooks(this, this.module);\n      }\n      return hooks;\n    },\n    finish: function finish() {\n      config.current = this;\n\n      // Release the timeout and timeout callback references to be garbage collected.\n      // https://github.com/qunitjs/qunit/pull/1708\n      if (setTimeout$1) {\n        clearTimeout(this.timeout);\n        config.timeoutHandler = null;\n      }\n\n      // Release the test callback to ensure that anything referenced has been\n      // released to be garbage collected.\n      this.callback = undefined;\n      if (this.steps.length) {\n        var stepsList = this.steps.join(', ');\n        this.pushFailure('Expected assert.verifySteps() to be called before end of test ' + \"after using assert.step(). Unverified steps: \".concat(stepsList), this.stack);\n      }\n      if (!config._deprecated_countEachStep_shown && !config.countStepsAsOne && this.expected !== null && this.stepsCount) {\n        config._deprecated_countEachStep_shown = true;\n        if (config.requireExpects) {\n          Logger.warn('Counting each assert.step() for assert.expect() is changing in QUnit 3.0. You can enable QUnit.config.countStepsAsOne to prepare for the upgrade. https://qunitjs.com/api/assert/expect/');\n        } else {\n          Logger.warn('Counting each assert.step() for assert.expect() is changing in QUnit 3.0. Omit assert.expect() from tests that use assert.step(), or enable QUnit.config.countStepsAsOne to prepare for the upgrade. https://qunitjs.com/api/assert/expect/');\n        }\n      }\n      var actualCountForExpect = config.countStepsAsOne ? this.assertions.length - this.stepsCount : this.assertions.length;\n      if (config.requireExpects && this.expected === null) {\n        this.pushFailure('Expected number of assertions to be defined, but expect() was ' + 'not called.', this.stack);\n      } else if (this.expected !== null && this.expected !== actualCountForExpect && this.stepsCount && this.expected === this.assertions.length - this.stepsCount && !config.countStepsAsOne) {\n        this.pushFailure('Expected ' + this.expected + ' assertions, but ' + actualCountForExpect + ' were run\\nIt looks like you might prefer to enable QUnit.config.countStepsAsOne, which will become the default in QUnit 3.0. https://qunitjs.com/api/assert/expect/', this.stack);\n      } else if (this.expected !== null && this.expected !== actualCountForExpect && this.stepsCount && this.expected === this.assertions.length && config.countStepsAsOne) {\n        this.pushFailure('Expected ' + this.expected + ' assertions, but ' + actualCountForExpect + ' were run\\nRemember that with QUnit.config.countStepsAsOne and in QUnit 3.0, steps no longer count as separate assertions. https://qunitjs.com/api/assert/expect/', this.stack);\n      } else if (this.expected !== null && this.expected !== actualCountForExpect) {\n        this.pushFailure('Expected ' + this.expected + ' assertions, but ' + actualCountForExpect + ' were run', this.stack);\n      } else if (this.expected === null && !actualCountForExpect) {\n        this.pushFailure('Expected at least one assertion, but none were run - call ' + 'expect(0) to accept zero assertions.', this.stack);\n      }\n      var module = this.module;\n      var moduleName = module.name;\n      var testName = this.testName;\n      var skipped = !!this.skip;\n      var todo = !!this.todo;\n      var bad = 0;\n      var storage = config.storage;\n      this.runtime = Math.round(performance.now() - this.started);\n      config.stats.all += this.assertions.length;\n      config.stats.testCount += 1;\n      module.stats.all += this.assertions.length;\n      for (var i = 0; i < this.assertions.length; i++) {\n        // A failing assertion will counts toward the HTML Reporter's\n        // \"X assertions, Y failed\" line even if it was inside a todo.\n        // Inverting this would be similarly confusing since all but the last\n        // passing assertion inside a todo test should be considered as good.\n        // These stats don't decide the outcome of anything, so counting them\n        // as failing seems the most intuitive.\n        if (!this.assertions[i].result) {\n          bad++;\n          config.stats.bad++;\n          module.stats.bad++;\n        }\n      }\n      if (skipped) {\n        incrementTestsIgnored(module);\n      } else {\n        incrementTestsRun(module);\n      }\n\n      // Store result when possible.\n      // Note that this also marks todo tests as bad, thus they get hoisted,\n      // and always run first on refresh.\n      if (storage) {\n        if (bad) {\n          storage.setItem('qunit-test-' + moduleName + '-' + testName, bad);\n        } else {\n          storage.removeItem('qunit-test-' + moduleName + '-' + testName);\n        }\n      }\n\n      // After emitting the js-reporters event we cleanup the assertion data to\n      // avoid leaking it. It is not used by the legacy testDone callbacks.\n      emit('testEnd', this.testReport.end(true));\n      this.testReport.slimAssertions();\n      var test = this;\n      return runLoggingCallbacks('testDone', {\n        name: testName,\n        module: moduleName,\n        skipped: skipped,\n        todo: todo,\n        failed: bad,\n        passed: this.assertions.length - bad,\n        total: this.assertions.length,\n        runtime: skipped ? 0 : this.runtime,\n        // HTML Reporter use\n        assertions: this.assertions,\n        testId: this.testId,\n        // Source of Test\n        // generating stack trace is expensive, so using a getter will help defer this until we need it\n        get source() {\n          return test.stack;\n        }\n      }).then(function () {\n        if (allTestsExecuted(module)) {\n          var completedModules = [module];\n\n          // Check if the parent modules, iteratively, are done. If that the case,\n          // we emit the `suiteEnd` event and trigger `moduleDone` callback.\n          var parent = module.parentModule;\n          while (parent && allTestsExecuted(parent)) {\n            completedModules.push(parent);\n            parent = parent.parentModule;\n          }\n          var moduleDoneChain = _Promise.resolve();\n          completedModules.forEach(function (completedModule) {\n            moduleDoneChain = moduleDoneChain.then(function () {\n              return logSuiteEnd(completedModule);\n            });\n          });\n          return moduleDoneChain;\n        }\n      }).then(function () {\n        config.current = undefined;\n      });\n      function logSuiteEnd(module) {\n        // Reset `module.hooks` to ensure that anything referenced in these hooks\n        // has been released to be garbage collected. Descendant modules that were\n        // entirely skipped, e.g. due to filtering, will never have this method\n        // called for them, but might have hooks with references pinning data in\n        // memory (even if the hooks weren't actually executed), so we reset the\n        // hooks on all descendant modules here as well. This is safe because we\n        // will never call this as long as any descendant modules still have tests\n        // to run. This also means that in multi-tiered nesting scenarios we might\n        // reset the hooks multiple times on some modules, but that's harmless.\n        var modules = [module];\n        while (modules.length) {\n          var nextModule = modules.shift();\n          nextModule.hooks = {};\n          modules.push.apply(modules, _toConsumableArray(nextModule.childModules));\n        }\n        emit('suiteEnd', module.suiteReport.end(true));\n        return runLoggingCallbacks('moduleDone', {\n          name: module.name,\n          tests: module.tests,\n          failed: module.stats.bad,\n          passed: module.stats.all - module.stats.bad,\n          total: module.stats.all,\n          runtime: Math.round(performance.now() - module.stats.started)\n        });\n      }\n    },\n    preserveTestEnvironment: function preserveTestEnvironment() {\n      if (this.preserveEnvironment) {\n        this.module.testEnvironment = this.testEnvironment;\n        this.testEnvironment = extend({}, this.module.testEnvironment);\n      }\n    },\n    queue: function queue() {\n      var test = this;\n      if (!this.valid()) {\n        incrementTestsIgnored(this.module);\n        return;\n      }\n      function runTest() {\n        return [function () {\n          return test.before();\n        }].concat(_toConsumableArray(test.hooks('before')), [function () {\n          test.preserveTestEnvironment();\n        }], _toConsumableArray(test.hooks('beforeEach')), [function () {\n          test.run();\n        }], _toConsumableArray(test.hooks('afterEach').reverse()), _toConsumableArray(test.hooks('after').reverse()), [function () {\n          test.after();\n        }, function () {\n          return test.finish();\n        }]);\n      }\n      var previousFailCount = config.storage && +config.storage.getItem('qunit-test-' + this.module.name + '-' + this.testName);\n\n      // Prioritize previously failed tests, detected from storage\n      var prioritize = config.reorder && !!previousFailCount;\n      this.previousFailure = !!previousFailCount;\n      config.pq.add(runTest, prioritize);\n    },\n    pushResult: function pushResult(resultInfo) {\n      if (this !== config.current) {\n        var message = resultInfo && resultInfo.message || '';\n        var testName = this && this.testName || '';\n        var error = 'Assertion occurred after test finished.\\n' + '> Test: ' + testName + '\\n' + '> Message: ' + message + '\\n';\n        throw new Error(error);\n      }\n\n      // Destructure of resultInfo = { result, actual, expected, message, negative }\n      var details = {\n        module: this.module.name,\n        name: this.testName,\n        result: resultInfo.result,\n        message: resultInfo.message,\n        actual: resultInfo.actual,\n        testId: this.testId,\n        negative: resultInfo.negative || false,\n        runtime: Math.round(performance.now() - this.started),\n        todo: !!this.todo\n      };\n      if (hasOwn$1.call(resultInfo, 'expected')) {\n        details.expected = resultInfo.expected;\n      }\n      if (!resultInfo.result) {\n        var source = resultInfo.source || sourceFromStacktrace();\n        if (source) {\n          details.source = source;\n        }\n      }\n      this.logAssertion(details);\n      this.assertions.push({\n        result: !!resultInfo.result,\n        message: resultInfo.message\n      });\n    },\n    pushFailure: function pushFailure(message, source) {\n      if (!(this instanceof Test)) {\n        throw new Error('pushFailure() assertion outside test context, was ' + sourceFromStacktrace(2));\n      }\n      this.pushResult({\n        result: false,\n        message: message || 'error',\n        source: source\n      });\n    },\n    /**\n     * Log assertion details using both the old QUnit.log interface and\n     * QUnit.on( \"assertion\" ) interface.\n     *\n     * @private\n     */\n    logAssertion: function logAssertion(details) {\n      runLoggingCallbacks('log', details);\n      var assertion = {\n        passed: details.result,\n        actual: details.actual,\n        expected: details.expected,\n        message: details.message,\n        stack: details.source,\n        todo: details.todo\n      };\n      this.testReport.pushAssertion(assertion);\n      emit('assertion', assertion);\n    },\n    /**\n     * Reset config.timeout with a new timeout duration.\n     *\n     * @param {number} timeoutDuration\n     */\n    internalResetTimeout: function internalResetTimeout(timeoutDuration) {\n      clearTimeout(config.timeout);\n      config.timeout = setTimeout$1(config.timeoutHandler(timeoutDuration), timeoutDuration);\n    },\n    /**\n     * Create a new async pause and return a new function that can release the pause.\n     *\n     * This mechanism is internally used by:\n     *\n     * - explicit async pauses, created by calling `assert.async()`,\n     * - implicit async pauses, created when `QUnit.test()` or module hook callbacks\n     *   use async-await or otherwise return a Promise.\n     *\n     * Happy scenario:\n     *\n     * - Pause is created by calling internalStop().\n     *\n     *   Pause is released normally by invoking release() during the same test.\n     *\n     *   The release() callback lets internal processing resume.\n     *\n     * Failure scenarios:\n     *\n     * - The test fails due to an uncaught exception.\n     *\n     *   In this case, Test.run() will call internalRecover() which empties the clears all\n     *   async pauses and sets the cancelled flag, which means we silently ignore any\n     *   late calls to the resume() callback, as we will have moved on to a different\n     *   test by then, and we don't want to cause an extra \"release during a different test\"\n     *   errors that the developer isn't really responsible for. This can happen when a test\n     *   correctly schedules a call to release(), but also causes an uncaught error. The\n     *   uncaught error means we will no longer wait for the release (as it might not arrive).\n     *\n     * - Pause is never released, or called an insufficient number of times.\n     *\n     *   Our timeout handler will kill the pause and resume test processing, basically\n     *   like internalRecover(), but for one pause instead of any/all.\n     *\n     *   Here, too, any late calls to resume() will be silently ignored to avoid\n     *   extra errors. We tolerate this since the original test will have already been\n     *   marked as failure.\n     *\n     *   TODO: QUnit 3 will enable timeouts by default <https://github.com/qunitjs/qunit/issues/1483>,\n     *   but right now a test will hang indefinitely if async pauses are not released,\n     *   unless QUnit.config.testTimeout or assert.timeout() is used.\n     *\n     * - Pause is spontaneously released during a different test,\n     *   or when no test is currently running.\n     *\n     *   This is close to impossible because this error only happens if the original test\n     *   succesfully finished first (since other failure scenarios kill pauses and ignore\n     *   late calls). It can happen if a test ended exactly as expected, but has some\n     *   external or shared state continuing to hold a reference to the release callback,\n     *   and either the same test scheduled another call to it in the future, or a later test\n     *   causes it to be called through some shared state.\n     *\n     * - Pause release() is called too often, during the same test.\n     *\n     *   This simply throws an error, after which uncaught error handling picks it up\n     *   and processing resumes.\n     *\n     * @param {number} [requiredCalls=1]\n     */\n    internalStop: function internalStop() {\n      var requiredCalls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      config.blocking = true;\n      var test = this;\n      var pauseId = this.nextPauseId++;\n      var pause = {\n        cancelled: false,\n        remaining: requiredCalls\n      };\n      test.pauses.set(pauseId, pause);\n      function release() {\n        if (pause.cancelled) {\n          return;\n        }\n        if (config.current === undefined) {\n          throw new Error('Unexpected release of async pause after tests finished.\\n' + \"> Test: \".concat(test.testName, \" [async #\").concat(pauseId, \"]\"));\n        }\n        if (config.current !== test) {\n          throw new Error('Unexpected release of async pause during a different test.\\n' + \"> Test: \".concat(test.testName, \" [async #\").concat(pauseId, \"]\"));\n        }\n        if (pause.remaining <= 0) {\n          throw new Error('Tried to release async pause that was already released.\\n' + \"> Test: \".concat(test.testName, \" [async #\").concat(pauseId, \"]\"));\n        }\n\n        // The `requiredCalls` parameter exists to support `assert.async(count)`\n        pause.remaining--;\n        if (pause.remaining === 0) {\n          test.pauses.delete(pauseId);\n        }\n        internalStart(test);\n      }\n\n      // Set a recovery timeout, if so configured.\n      if (setTimeout$1) {\n        var timeoutDuration;\n        if (typeof test.timeout === 'number') {\n          timeoutDuration = test.timeout;\n        } else if (typeof config.testTimeout === 'number') {\n          timeoutDuration = config.testTimeout;\n        }\n        if (typeof timeoutDuration === 'number' && timeoutDuration > 0) {\n          config.timeoutHandler = function (timeout) {\n            return function () {\n              config.timeout = null;\n              pause.cancelled = true;\n              test.pauses.delete(pauseId);\n              test.pushFailure(\"Test took longer than \".concat(timeout, \"ms; test timed out.\"), sourceFromStacktrace(2));\n              internalRecover(test);\n            };\n          };\n          clearTimeout(config.timeout);\n          config.timeout = setTimeout$1(config.timeoutHandler(timeoutDuration), timeoutDuration);\n        } else {\n          clearTimeout(config.timeout);\n          config.timeout = setTimeout$1(function () {\n            config.timeout = null;\n            if (!config._deprecated_timeout_shown) {\n              config._deprecated_timeout_shown = true;\n              Logger.warn(\"Test \\\"\".concat(test.testName, \"\\\" took longer than 3000ms, but no timeout was set. Set QUnit.config.testTimeout or call assert.timeout() to avoid a timeout in QUnit 3. https://qunitjs.com/api/config/testTimeout/\"));\n            }\n          }, 3000);\n        }\n      }\n      return release;\n    },\n    resolvePromise: function resolvePromise(promise, phase) {\n      if (promise != null) {\n        var _test = this;\n        var then = promise.then;\n        if (typeof then === 'function') {\n          var resume = _test.internalStop();\n          var resolve = function resolve() {\n            resume();\n          };\n          if (config.notrycatch) {\n            then.call(promise, resolve);\n          } else {\n            var reject = function reject(error) {\n              var message = 'Promise rejected ' + (!phase ? 'during' : phase.replace(/Each$/, '')) + ' \"' + _test.testName + '\": ' + (error && error.message || error);\n              _test.pushFailure(message, extractStacktrace(error, 0));\n\n              // Else next test will carry the responsibility\n              saveGlobal();\n\n              // Unblock\n              internalRecover(_test);\n            };\n            then.call(promise, resolve, reject);\n          }\n        }\n      }\n    },\n    valid: function valid() {\n      // Internally-generated tests are always valid\n      if (this.callback && this.callback.validTest) {\n        return true;\n      }\n      function moduleChainIdMatch(testModule, selectedId) {\n        return (\n          // undefined or empty array\n          !selectedId || !selectedId.length || inArray(testModule.moduleId, selectedId) || testModule.parentModule && moduleChainIdMatch(testModule.parentModule, selectedId)\n        );\n      }\n      if (!moduleChainIdMatch(this.module, config.moduleId)) {\n        return false;\n      }\n      if (config.testId && config.testId.length && !inArray(this.testId, config.testId)) {\n        return false;\n      }\n      function moduleChainNameMatch(testModule, selectedModule) {\n        if (!selectedModule) {\n          // undefined or empty string\n          return true;\n        }\n        var testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n        if (testModuleName === selectedModule) {\n          return true;\n        } else if (testModule.parentModule) {\n          return moduleChainNameMatch(testModule.parentModule, selectedModule);\n        } else {\n          return false;\n        }\n      }\n      var selectedModule = config.module && config.module.toLowerCase();\n      if (!moduleChainNameMatch(this.module, selectedModule)) {\n        return false;\n      }\n      var filter = config.filter;\n      if (!filter) {\n        return true;\n      }\n      var regexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec(filter);\n      var fullName = this.module.name + ': ' + this.testName;\n      return regexFilter ? this.regexFilter(!!regexFilter[1], regexFilter[2], regexFilter[3], fullName) : this.stringFilter(filter, fullName);\n    },\n    regexFilter: function regexFilter(exclude, pattern, flags, fullName) {\n      var regex = new RegExp(pattern, flags);\n      var match = regex.test(fullName);\n      return match !== exclude;\n    },\n    stringFilter: function stringFilter(filter, fullName) {\n      filter = filter.toLowerCase();\n      fullName = fullName.toLowerCase();\n      var include = filter.charAt(0) !== '!';\n      if (!include) {\n        filter = filter.slice(1);\n      }\n\n      // If the filter matches, we need to honour include\n      if (fullName.indexOf(filter) !== -1) {\n        return include;\n      }\n\n      // Otherwise, do the opposite\n      return !include;\n    }\n  };\n  function pushFailure() {\n    if (!config.current) {\n      throw new Error('pushFailure() assertion outside test context, in ' + sourceFromStacktrace(2));\n    }\n\n    // Gets current test obj\n    var currentTest = config.current;\n    return currentTest.pushFailure.apply(currentTest, arguments);\n  }\n  function saveGlobal() {\n    config.pollution = [];\n    if (config.noglobals) {\n      for (var key in g) {\n        if (hasOwn$1.call(g, key)) {\n          // In Opera sometimes DOM element ids show up here, ignore them\n          if (/^qunit-test-output/.test(key)) {\n            continue;\n          }\n          config.pollution.push(key);\n        }\n      }\n    }\n  }\n  function checkPollution() {\n    var old = config.pollution;\n    saveGlobal();\n    var newGlobals = diff$1(config.pollution, old);\n    if (newGlobals.length > 0) {\n      pushFailure('Introduced global variable(s): ' + newGlobals.join(', '));\n    }\n    var deletedGlobals = diff$1(old, config.pollution);\n    if (deletedGlobals.length > 0) {\n      pushFailure('Deleted global variable(s): ' + deletedGlobals.join(', '));\n    }\n  }\n  var focused = false; // indicates that the \"only\" filter was used\n\n  function addTest(settings) {\n    if (focused || config.currentModule.ignored) {\n      return;\n    }\n    var newTest = new Test(settings);\n    newTest.queue();\n  }\n  function addOnlyTest(settings) {\n    if (config.currentModule.ignored) {\n      return;\n    }\n    if (!focused) {\n      config.queue.length = 0;\n      clearSuiteReports(config.currentModule);\n      focused = true;\n    }\n    var newTest = new Test(settings);\n    newTest.queue();\n  }\n\n  // Will be exposed as QUnit.test\n  function test(testName, callback) {\n    addTest({\n      testName: testName,\n      callback: callback\n    });\n  }\n  function makeEachTestName(testName, argument) {\n    return \"\".concat(testName, \" [\").concat(argument, \"]\");\n  }\n\n  // Characters to avoid in test names especially CLI/AP output:\n  // * x00-1F: e.g. NULL, backspace (\\b), line breaks (\\r\\n), ESC.\n  // * x74: DEL.\n  // * xA0: non-breaking space.\n  //\n  // See https://en.wikipedia.org/wiki/ASCII#Character_order\n  //\n  // eslint-disable-next-line no-control-regex\n  var rNonObviousStr = /[\\x00-\\x1F\\x7F\\xA0]/;\n  function runEach(data, eachFn) {\n    if (Array.isArray(data)) {\n      for (var i = 0; i < data.length; i++) {\n        var value = data[i];\n\n        // Create automatic labels for primitive data in arrays passed to test.each().\n        // We want to avoid the default \"example [0], example [1]\" where possible since\n        // these are not self-explanatory in results, and are also tedious to locate\n        // the source of since the numerical key of an array isn't literally in the\n        // code (you have to count).\n        //\n        // Design requirements:\n        // * Unique. Each label must be unique and correspond 1:1 with a data value.\n        //   This way each test name will hash to a unique testId with Rerun link,\n        //   without having to rely on Test class enforcing uniqueness with invisible\n        //   space hack.\n        // * Unambigious. While technical uniqueness is a hard requirement above,\n        //   we also want the labels to be obvious and unambiguous to humans.\n        //   For example, abbrebating \"foobar\" and \"foobaz\" to \"f\" and \"fo\" is\n        //   technically unique, but ambigious to humans which one is which.\n        // * Short and readable. Where possible we omit the array index numbers\n        //   so that in most cases, the value is simply shown as-is.\n        //   We prefer \"example [foo], example [bar]\"\n        //   over \"example [0: foo], example [2: bar]\".\n        //   This also has the benefit of being stable and robust against e.g.\n        //   re-ordering data or adding new items during development, without\n        //   invalidating a previous filter or rerun link immediately.\n        var valueType = _typeof(value);\n        var testKey = i;\n        if (valueType === 'string' && value.length <= 40 && !rNonObviousStr.test(value) && !/\\s*\\d+: /.test(value)) {\n          testKey = value;\n        } else if (valueType === 'string' || valueType === 'number' || valueType === 'boolean' || valueType === 'undefined' || value === null) {\n          var valueForName = String(value);\n          if (!rNonObviousStr.test(valueForName)) {\n            testKey = i + ': ' + (valueForName.length <= 30 ? valueForName : valueForName.slice(0, 29) + '');\n          }\n        }\n        eachFn(value, testKey);\n      }\n    } else if (_typeof(data) === 'object' && data !== null) {\n      for (var key in data) {\n        eachFn(data[key], key);\n      }\n    } else {\n      throw new Error(\"test.each() expects an array or object as input, but\\nfound \".concat(_typeof(data), \" instead.\"));\n    }\n  }\n  extend(test, {\n    todo: function todo(testName, callback) {\n      addTest({\n        testName: testName,\n        callback: callback,\n        todo: true\n      });\n    },\n    skip: function skip(testName) {\n      addTest({\n        testName: testName,\n        skip: true\n      });\n    },\n    if: function _if(testName, condition, callback) {\n      addTest({\n        testName: testName,\n        callback: callback,\n        skip: !condition\n      });\n    },\n    only: function only(testName, callback) {\n      addOnlyTest({\n        testName: testName,\n        callback: callback\n      });\n    },\n    each: function each(testName, dataset, callback) {\n      runEach(dataset, function (data, testKey) {\n        addTest({\n          testName: makeEachTestName(testName, testKey),\n          callback: callback,\n          withData: true,\n          stackOffset: 5,\n          data: data\n        });\n      });\n    }\n  });\n  test.todo.each = function (testName, dataset, callback) {\n    runEach(dataset, function (data, testKey) {\n      addTest({\n        testName: makeEachTestName(testName, testKey),\n        callback: callback,\n        todo: true,\n        withData: true,\n        stackOffset: 5,\n        data: data\n      });\n    });\n  };\n  test.skip.each = function (testName, dataset) {\n    runEach(dataset, function (_, testKey) {\n      addTest({\n        testName: makeEachTestName(testName, testKey),\n        stackOffset: 5,\n        skip: true\n      });\n    });\n  };\n  test.if.each = function (testName, condition, dataset, callback) {\n    runEach(dataset, function (data, testKey) {\n      addTest({\n        testName: makeEachTestName(testName, testKey),\n        callback: callback,\n        withData: true,\n        stackOffset: 5,\n        skip: !condition,\n        data: condition ? data : undefined\n      });\n    });\n  };\n  test.only.each = function (testName, dataset, callback) {\n    runEach(dataset, function (data, testKey) {\n      addOnlyTest({\n        testName: makeEachTestName(testName, testKey),\n        callback: callback,\n        withData: true,\n        stackOffset: 5,\n        data: data\n      });\n    });\n  };\n\n  // Forcefully release all processing holds.\n  function internalRecover(test) {\n    test.pauses.forEach(function (pause) {\n      pause.cancelled = true;\n    });\n    test.pauses.clear();\n    internalStart(test);\n  }\n\n  // Release a processing hold, scheduling a resumption attempt if no holds remain.\n  function internalStart(test) {\n    // Ignore if other async pauses still exist.\n    if (test.pauses.size > 0) {\n      return;\n    }\n\n    // Add a slight delay to allow more assertions etc.\n    if (setTimeout$1) {\n      clearTimeout(config.timeout);\n      config.timeout = setTimeout$1(function () {\n        if (test.pauses.size > 0) {\n          return;\n        }\n        clearTimeout(config.timeout);\n        config.timeout = null;\n        config.blocking = false;\n        config.pq.advance();\n      });\n    } else {\n      config.blocking = false;\n      config.pq.advance();\n    }\n  }\n  function collectTests(module) {\n    var tests = [].concat(module.tests);\n    var modules = _toConsumableArray(module.childModules);\n\n    // Do a breadth-first traversal of the child modules\n    while (modules.length) {\n      var nextModule = modules.shift();\n      tests.push.apply(tests, nextModule.tests);\n      modules.push.apply(modules, _toConsumableArray(nextModule.childModules));\n    }\n    return tests;\n  }\n\n  // This returns true after all executable and skippable tests\n  // in a module have been proccessed, and informs 'suiteEnd'\n  // and moduleDone().\n  function allTestsExecuted(module) {\n    return module.testsRun + module.testsIgnored === collectTests(module).length;\n  }\n\n  // This returns true during the last executable non-skipped test\n  // within a module, and informs the running of the 'after' hook\n  // for a given module. This runs only once for a given module,\n  // but must run during the last non-skipped test. When it runs,\n  // there may be non-zero skipped tests left.\n  function lastTestWithinModuleExecuted(module) {\n    return module.testsRun === collectTests(module).filter(function (test) {\n      return !test.skip;\n    }).length - 1;\n  }\n  function incrementTestsRun(module) {\n    module.testsRun++;\n    while (module = module.parentModule) {\n      module.testsRun++;\n    }\n  }\n  function incrementTestsIgnored(module) {\n    module.testsIgnored++;\n    while (module = module.parentModule) {\n      module.testsIgnored++;\n    }\n  }\n\n  /* global module, exports, define */\n  function exportQUnit(QUnit) {\n    var exportedModule = false;\n    if (window$1 && document) {\n      // QUnit may be defined when it is preconfigured but then only QUnit and QUnit.config may be defined.\n      if (window$1.QUnit && window$1.QUnit.version) {\n        throw new Error('QUnit has already been defined.');\n      }\n      window$1.QUnit = QUnit;\n      exportedModule = true;\n    }\n\n    // For Node.js\n    if (typeof module !== 'undefined' && module && module.exports) {\n      module.exports = QUnit;\n\n      // For consistency with CommonJS environments' exports\n      module.exports.QUnit = QUnit;\n      exportedModule = true;\n    }\n\n    // For CommonJS with exports, but without module.exports, like Rhino\n    if (typeof exports !== 'undefined' && exports) {\n      exports.QUnit = QUnit;\n      exportedModule = true;\n    }\n\n    // For AMD\n    if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return QUnit;\n      });\n      QUnit.config.autostart = false;\n      exportedModule = true;\n    }\n\n    // For other environments, including Web Workers (globalThis === self),\n    // SpiderMonkey (mozjs), and other embedded JavaScript engines\n    if (!exportedModule) {\n      g.QUnit = QUnit;\n    }\n  }\n\n  var ConsoleReporter = /*#__PURE__*/function () {\n    function ConsoleReporter(runner) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      _classCallCheck(this, ConsoleReporter);\n      // Cache references to console methods to ensure we can report failures\n      // from tests tests that mock the console object itself.\n      // https://github.com/qunitjs/qunit/issues/1340\n      // Support IE 9: Function#bind is supported, but no console.log.bind().\n      this.log = options.log || Function.prototype.bind.call(console$1.log, console$1);\n      runner.on('error', this.onError.bind(this));\n      runner.on('runStart', this.onRunStart.bind(this));\n      runner.on('testStart', this.onTestStart.bind(this));\n      runner.on('testEnd', this.onTestEnd.bind(this));\n      runner.on('runEnd', this.onRunEnd.bind(this));\n    }\n    return _createClass(ConsoleReporter, [{\n      key: \"onError\",\n      value: function onError(error) {\n        this.log('error', error);\n      }\n    }, {\n      key: \"onRunStart\",\n      value: function onRunStart(runStart) {\n        this.log('runStart', runStart);\n      }\n    }, {\n      key: \"onTestStart\",\n      value: function onTestStart(test) {\n        this.log('testStart', test);\n      }\n    }, {\n      key: \"onTestEnd\",\n      value: function onTestEnd(test) {\n        this.log('testEnd', test);\n      }\n    }, {\n      key: \"onRunEnd\",\n      value: function onRunEnd(runEnd) {\n        this.log('runEnd', runEnd);\n      }\n    }], [{\n      key: \"init\",\n      value: function init(runner, options) {\n        return new ConsoleReporter(runner, options);\n      }\n    }]);\n  }();\n\n  // TODO: Consider using globalThis instead of window, so that the reporter\n  // works for Node.js as well. As this can add overhead, we should make\n  // this opt-in before we enable it for CLI.\n  //\n  // QUnit 3 will switch from `window` to `globalThis` and then make it\n  // no longer an implicit feature of the HTML Reporter, but rather let\n  // it be opt-in via `QUnit.config.reporters = ['perf']` or something\n  // like that.\n  var nativePerf = window$1 && typeof window$1.performance !== 'undefined' &&\n  // eslint-disable-next-line compat/compat -- Checked\n  typeof window$1.performance.mark === 'function' &&\n  // eslint-disable-next-line compat/compat -- Checked\n  typeof window$1.performance.measure === 'function' ? window$1.performance : undefined;\n  var perf = {\n    measure: nativePerf ? function (comment, startMark, endMark) {\n      // `performance.measure` may fail if the mark could not be found.\n      // reasons a specific mark could not be found include: outside code invoking `performance.clearMarks()`\n      try {\n        nativePerf.measure(comment, startMark, endMark);\n      } catch (ex) {\n        Logger.warn('performance.measure could not be executed because of ', ex.message);\n      }\n    } : function () {},\n    mark: nativePerf ? nativePerf.mark.bind(nativePerf) : function () {}\n  };\n  var PerfReporter = /*#__PURE__*/function () {\n    function PerfReporter(runner) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      _classCallCheck(this, PerfReporter);\n      this.perf = options.perf || perf;\n      runner.on('runStart', this.onRunStart.bind(this));\n      runner.on('runEnd', this.onRunEnd.bind(this));\n      runner.on('suiteStart', this.onSuiteStart.bind(this));\n      runner.on('suiteEnd', this.onSuiteEnd.bind(this));\n      runner.on('testStart', this.onTestStart.bind(this));\n      runner.on('testEnd', this.onTestEnd.bind(this));\n    }\n    return _createClass(PerfReporter, [{\n      key: \"onRunStart\",\n      value: function onRunStart() {\n        this.perf.mark('qunit_suite_0_start');\n      }\n    }, {\n      key: \"onSuiteStart\",\n      value: function onSuiteStart(suiteStart) {\n        var suiteLevel = suiteStart.fullName.length;\n        this.perf.mark(\"qunit_suite_\".concat(suiteLevel, \"_start\"));\n      }\n    }, {\n      key: \"onSuiteEnd\",\n      value: function onSuiteEnd(suiteEnd) {\n        var suiteLevel = suiteEnd.fullName.length;\n        var suiteName = suiteEnd.fullName.join('  ');\n        this.perf.mark(\"qunit_suite_\".concat(suiteLevel, \"_end\"));\n        this.perf.measure(\"QUnit Test Suite: \".concat(suiteName), \"qunit_suite_\".concat(suiteLevel, \"_start\"), \"qunit_suite_\".concat(suiteLevel, \"_end\"));\n      }\n    }, {\n      key: \"onTestStart\",\n      value: function onTestStart() {\n        this.perf.mark('qunit_test_start');\n      }\n    }, {\n      key: \"onTestEnd\",\n      value: function onTestEnd(testEnd) {\n        this.perf.mark('qunit_test_end');\n        var testName = testEnd.fullName.join('  ');\n        this.perf.measure(\"QUnit Test: \".concat(testName), 'qunit_test_start', 'qunit_test_end');\n      }\n    }, {\n      key: \"onRunEnd\",\n      value: function onRunEnd() {\n        this.perf.mark('qunit_suite_0_end');\n        this.perf.measure('QUnit Test Run', 'qunit_suite_0_start', 'qunit_suite_0_end');\n      }\n    }], [{\n      key: \"init\",\n      value: function init(runner, options) {\n        return new PerfReporter(runner, options);\n      }\n    }]);\n  }();\n\n  var FORCE_COLOR,\n    NODE_DISABLE_COLORS,\n    NO_COLOR,\n    TERM,\n    isTTY = true;\n  if (typeof process !== 'undefined') {\n    var _ref = process.env || {};\n    FORCE_COLOR = _ref.FORCE_COLOR;\n    NODE_DISABLE_COLORS = _ref.NODE_DISABLE_COLORS;\n    NO_COLOR = _ref.NO_COLOR;\n    TERM = _ref.TERM;\n    isTTY = process.stdout && process.stdout.isTTY;\n  }\n  var $ = {\n    enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY),\n    // modifiers\n    reset: init(0, 0),\n    bold: init(1, 22),\n    dim: init(2, 22),\n    italic: init(3, 23),\n    underline: init(4, 24),\n    inverse: init(7, 27),\n    hidden: init(8, 28),\n    strikethrough: init(9, 29),\n    // colors\n    black: init(30, 39),\n    red: init(31, 39),\n    green: init(32, 39),\n    yellow: init(33, 39),\n    blue: init(34, 39),\n    magenta: init(35, 39),\n    cyan: init(36, 39),\n    white: init(37, 39),\n    gray: init(90, 39),\n    grey: init(90, 39),\n    // background colors\n    bgBlack: init(40, 49),\n    bgRed: init(41, 49),\n    bgGreen: init(42, 49),\n    bgYellow: init(43, 49),\n    bgBlue: init(44, 49),\n    bgMagenta: init(45, 49),\n    bgCyan: init(46, 49),\n    bgWhite: init(47, 49)\n  };\n  function run(arr, str) {\n    var i = 0,\n      tmp,\n      beg = '',\n      end = '';\n    for (; i < arr.length; i++) {\n      tmp = arr[i];\n      beg += tmp.open;\n      end += tmp.close;\n      if (!!~str.indexOf(tmp.close)) {\n        str = str.replace(tmp.rgx, tmp.close + tmp.open);\n      }\n    }\n    return beg + str + end;\n  }\n  function chain(has, keys) {\n    var ctx = {\n      has: has,\n      keys: keys\n    };\n    ctx.reset = $.reset.bind(ctx);\n    ctx.bold = $.bold.bind(ctx);\n    ctx.dim = $.dim.bind(ctx);\n    ctx.italic = $.italic.bind(ctx);\n    ctx.underline = $.underline.bind(ctx);\n    ctx.inverse = $.inverse.bind(ctx);\n    ctx.hidden = $.hidden.bind(ctx);\n    ctx.strikethrough = $.strikethrough.bind(ctx);\n    ctx.black = $.black.bind(ctx);\n    ctx.red = $.red.bind(ctx);\n    ctx.green = $.green.bind(ctx);\n    ctx.yellow = $.yellow.bind(ctx);\n    ctx.blue = $.blue.bind(ctx);\n    ctx.magenta = $.magenta.bind(ctx);\n    ctx.cyan = $.cyan.bind(ctx);\n    ctx.white = $.white.bind(ctx);\n    ctx.gray = $.gray.bind(ctx);\n    ctx.grey = $.grey.bind(ctx);\n    ctx.bgBlack = $.bgBlack.bind(ctx);\n    ctx.bgRed = $.bgRed.bind(ctx);\n    ctx.bgGreen = $.bgGreen.bind(ctx);\n    ctx.bgYellow = $.bgYellow.bind(ctx);\n    ctx.bgBlue = $.bgBlue.bind(ctx);\n    ctx.bgMagenta = $.bgMagenta.bind(ctx);\n    ctx.bgCyan = $.bgCyan.bind(ctx);\n    ctx.bgWhite = $.bgWhite.bind(ctx);\n    return ctx;\n  }\n  function init(open, close) {\n    var blk = {\n      open: \"\\x1B[\".concat(open, \"m\"),\n      close: \"\\x1B[\".concat(close, \"m\"),\n      rgx: new RegExp(\"\\\\x1b\\\\[\".concat(close, \"m\"), 'g')\n    };\n    return function (txt) {\n      if (this !== void 0 && this.has !== void 0) {\n        !!~this.has.indexOf(open) || (this.has.push(open), this.keys.push(blk));\n        return txt === void 0 ? this : $.enabled ? run(this.keys, txt + '') : txt + '';\n      }\n      return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt + '') : txt + '';\n    };\n  }\n\n  /**\n   * Format a given value into YAML.\n   *\n   * YAML is a superset of JSON that supports all the same data\n   * types and syntax, and more. As such, it is always possible\n   * to fallback to JSON.stringfify, but we generally avoid\n   * that to make output easier to read for humans.\n   *\n   * Supported data types:\n   *\n   * - null\n   * - boolean\n   * - number\n   * - string\n   * - array\n   * - object\n   *\n   * Anything else (including NaN, Infinity, and undefined)\n   * must be described in strings, for display purposes.\n   *\n   * Note that quotes are optional in YAML strings if the\n   * strings are \"simple\", and as such we generally prefer\n   * that for improved readability. We output strings in\n   * one of three ways:\n   *\n   * - bare unquoted text, for simple one-line strings.\n   * - JSON (quoted text), for complex one-line strings.\n   * - YAML Block, for complex multi-line strings.\n   *\n   * Objects with cyclical references will be stringifed as\n   * \"[Circular]\" as they cannot otherwise be represented.\n   */\n  function prettyYamlValue(value) {\n    var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    if (value === undefined) {\n      // Not supported in JSON/YAML, turn into string\n      // and let the below output it as bare string.\n      value = String(value);\n    }\n\n    // Support IE 9-11: Use isFinite instead of ES6 Number.isFinite\n    if (typeof value === 'number' && !isFinite(value)) {\n      // Turn NaN and Infinity into simple strings.\n      // Paranoia: Don't return directly just in case there's\n      // a way to add special characters here.\n      value = String(value);\n    }\n    if (typeof value === 'number') {\n      // Simple numbers\n      return JSON.stringify(value);\n    }\n    if (typeof value === 'string') {\n      // If any of these match, then we can't output it\n      // as bare unquoted text, because that would either\n      // cause data loss or invalid YAML syntax.\n      //\n      // - Quotes, escapes, line breaks, or JSON-like stuff.\n      // - Not allowed in YAML unquoted strings per https://yaml.org/spec/1.2.2/#733-plain-style\n      //   * \": \" (colon followed by space)\n      //   * \" #\" (space followed by hash)\n      var rSpecialJson = /['\"\\\\/[{}\\]\\r\\n|:#]/;\n\n      // - Characters that are special at the start of a YAML value\n      var rSpecialYaml = /[-?:,[\\]{}#&*!|=>'\"%@`]/;\n\n      // - Leading or trailing whitespace.\n      var rUntrimmed = /(^\\s|\\s$)/;\n\n      // - Ambiguous as YAML number, e.g. '2', '-1.2', '.2', or '2_000'\n      var rNumerical = /^[\\d._-]+$/;\n\n      // - Ambiguous as YAML bool.\n      //   Use case-insensitive match, although technically only\n      //   fully-lower, fully-upper, or uppercase-first would be ambiguous.\n      //   e.g. true/True/TRUE, but not tRUe.\n      var rBool = /^(true|false|y|n|yes|no|on|off)$/i;\n\n      // Is this a complex string?\n      if (value === '' || rSpecialJson.test(value) || rSpecialYaml.test(value[0]) || rUntrimmed.test(value) || rNumerical.test(value) || rBool.test(value)) {\n        if (!/\\n/.test(value)) {\n          // Complex one-line string, use JSON (quoted string)\n          return JSON.stringify(value);\n        }\n\n        // See also <https://yaml-multiline.info/>\n        // Support IE 9-11: Avoid ES6 String#repeat\n        var _prefix = new Array(indent * 2 + 1).join(' ');\n        var trailingLinebreakMatch = value.match(/\\n+$/);\n        var trailingLinebreaks = trailingLinebreakMatch ? trailingLinebreakMatch[0].length : 0;\n        if (trailingLinebreaks === 1) {\n          // Use the most straight-forward \"Block\" string in YAML\n          // without any \"Chomping\" indicators.\n          var lines = value\n\n          // Ignore the last new line, since we'll get that one for free\n          // with the straight-forward Block syntax.\n          .replace(/\\n$/, '').split('\\n').map(function (line) {\n            return _prefix + line;\n          });\n          return '|\\n' + lines.join('\\n');\n        } else {\n          // This has either no trailing new lines, or more than 1.\n          // Use |+ so that YAML parsers will preserve it exactly.\n          var _lines = value.split('\\n').map(function (line) {\n            return _prefix + line;\n          });\n          return '|+\\n' + _lines.join('\\n');\n        }\n      } else {\n        // Simple string, use bare unquoted text\n        return value;\n      }\n    }\n    var prefix = new Array(indent + 1).join(' ');\n\n    // Handle null, boolean, array, and object\n    return JSON.stringify(decycledShallowClone(value), null, 2).split('\\n').map(function (line, i) {\n      return i === 0 ? line : prefix + line;\n    }).join('\\n');\n  }\n\n  /**\n   * Creates a shallow clone of an object where cycles have\n   * been replaced with \"[Circular]\".\n   */\n  function decycledShallowClone(object) {\n    var ancestors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    if (ancestors.indexOf(object) !== -1) {\n      return '[Circular]';\n    }\n    var type = Object.prototype.toString.call(object).replace(/^\\[.+\\s(.+?)]$/, '$1').toLowerCase();\n    var clone;\n    switch (type) {\n      case 'array':\n        ancestors.push(object);\n        clone = object.map(function (element) {\n          return decycledShallowClone(element, ancestors);\n        });\n        ancestors.pop();\n        break;\n      case 'object':\n        ancestors.push(object);\n        clone = {};\n        Object.keys(object).forEach(function (key) {\n          clone[key] = decycledShallowClone(object[key], ancestors);\n        });\n        ancestors.pop();\n        break;\n      default:\n        clone = object;\n    }\n    return clone;\n  }\n  var TapReporter = /*#__PURE__*/function () {\n    function TapReporter(runner) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      _classCallCheck(this, TapReporter);\n      // Cache references to console methods to ensure we can report failures\n      // from tests tests that mock the console object itself.\n      // https://github.com/qunitjs/qunit/issues/1340\n      // Support IE 9: Function#bind is supported, but no console.log.bind().\n      this.log = options.log || Function.prototype.bind.call(console$1.log, console$1);\n      this.testCount = 0;\n      this.started = false;\n      this.ended = false;\n      this.bailed = false;\n      runner.on('error', this.onError.bind(this));\n      runner.on('runStart', this.onRunStart.bind(this));\n      runner.on('testEnd', this.onTestEnd.bind(this));\n      runner.on('runEnd', this.onRunEnd.bind(this));\n    }\n    return _createClass(TapReporter, [{\n      key: \"onRunStart\",\n      value: function onRunStart(_runSuite) {\n        if (!this.started) {\n          this.log('TAP version 13');\n          this.started = true;\n        }\n      }\n    }, {\n      key: \"onError\",\n      value: function onError(error) {\n        if (this.bailed) {\n          return;\n        }\n        this.bailed = true;\n\n        // Imitate onTestEnd\n        // Skip this if we're past \"runEnd\" as it would look odd\n        if (!this.ended) {\n          this.onRunStart();\n          this.testCount = this.testCount + 1;\n          this.log(\"not ok \".concat(this.testCount, \" \").concat($.red('global failure')));\n          this.logError(error);\n        }\n        this.log('Bail out! ' + errorString(error).split('\\n')[0]);\n        if (this.ended) {\n          this.logError(error);\n        }\n      }\n    }, {\n      key: \"onTestEnd\",\n      value: function onTestEnd(test) {\n        var _this = this;\n        this.testCount = this.testCount + 1;\n        if (test.status === 'passed') {\n          this.log(\"ok \".concat(this.testCount, \" \").concat(test.fullName.join(' > ')));\n        } else if (test.status === 'skipped') {\n          this.log(\"ok \".concat(this.testCount, \" \").concat($.yellow(test.fullName.join(' > ')), \" # SKIP\"));\n        } else if (test.status === 'todo') {\n          this.log(\"not ok \".concat(this.testCount, \" \").concat($.cyan(test.fullName.join(' > ')), \" # TODO\"));\n          test.errors.forEach(function (error) {\n            return _this.logAssertion(error, 'todo');\n          });\n        } else {\n          this.log(\"not ok \".concat(this.testCount, \" \").concat($.red(test.fullName.join(' > '))));\n          test.errors.forEach(function (error) {\n            return _this.logAssertion(error);\n          });\n        }\n      }\n    }, {\n      key: \"onRunEnd\",\n      value: function onRunEnd(runEnd) {\n        this.ended = true;\n        this.log(\"1..\".concat(runEnd.testCounts.total));\n        this.log(\"# pass \".concat(runEnd.testCounts.passed));\n        this.log(\"# \".concat($.yellow(\"skip \".concat(runEnd.testCounts.skipped))));\n        this.log(\"# \".concat($.cyan(\"todo \".concat(runEnd.testCounts.todo))));\n        this.log(\"# \".concat($.red(\"fail \".concat(runEnd.testCounts.failed))));\n      }\n    }, {\n      key: \"logAssertion\",\n      value: function logAssertion(error, severity) {\n        var out = '  ---';\n        out += \"\\n  message: \".concat(prettyYamlValue(error.message || 'failed'));\n        out += \"\\n  severity: \".concat(prettyYamlValue(severity || 'failed'));\n\n        // When pushFailure() is used, actual/expected are initially unset but\n        // eventually in Test#logAssertion, for testReport#pushAssertion, these are\n        // forged into existence as undefined.\n        var hasAny = error.expected !== undefined || error.actual !== undefined;\n        if (hasAny) {\n          out += \"\\n  actual  : \".concat(prettyYamlValue(error.actual));\n          out += \"\\n  expected: \".concat(prettyYamlValue(error.expected));\n        }\n        if (error.stack) {\n          // Since stacks aren't user generated, take a bit of liberty by\n          // adding a trailing new line to allow a straight-forward YAML Blocks.\n          var fmtStack = annotateStacktrace(error.stack, $.grey);\n          if (fmtStack.length) {\n            out += \"\\n  stack: \".concat(prettyYamlValue(fmtStack + '\\n'));\n          }\n        }\n        out += '\\n  ...';\n        this.log(out);\n      }\n    }, {\n      key: \"logError\",\n      value: function logError(error) {\n        var out = '  ---';\n        out += \"\\n  message: \".concat(prettyYamlValue(errorString(error)));\n        out += \"\\n  severity: \".concat(prettyYamlValue('failed'));\n        if (error && error.stack) {\n          var fmtStack = annotateStacktrace(error.stack, $.grey, error.toString());\n          if (fmtStack.length) {\n            out += \"\\n  stack: \".concat(prettyYamlValue(fmtStack + '\\n'));\n          }\n        }\n        out += '\\n  ...';\n        this.log(out);\n      }\n    }], [{\n      key: \"init\",\n      value: function init(runner, options) {\n        return new TapReporter(runner, options);\n      }\n    }]);\n  }();\n\n  var reporters = {\n    console: ConsoleReporter,\n    perf: PerfReporter,\n    tap: TapReporter\n  };\n\n  function makeAddGlobalHook(hookName) {\n    return function addGlobalHook(callback) {\n      if (!config.globalHooks[hookName]) {\n        config.globalHooks[hookName] = [];\n      }\n      config.globalHooks[hookName].push(callback);\n    };\n  }\n  var hooks = {\n    beforeEach: makeAddGlobalHook('beforeEach'),\n    afterEach: makeAddGlobalHook('afterEach')\n  };\n\n  /**\n   * Creates a seeded \"sample\" generator which is used for randomizing tests.\n   */\n  function unitSamplerGenerator(seed) {\n    // 32-bit xorshift, requires only a nonzero seed\n    // https://excamera.com/sphinx/article-xorshift.html\n    var sample = parseInt(generateHash(seed), 16) || -1;\n    return function () {\n      sample ^= sample << 13;\n      sample ^= sample >>> 17;\n      sample ^= sample << 5;\n\n      // ECMAScript has no unsigned number type\n      if (sample < 0) {\n        sample += 0x100000000;\n      }\n      return sample / 0x100000000;\n    };\n  }\n  var ProcessingQueue = /*#__PURE__*/function () {\n    /**\n     * @param {Function} test Reference to the QUnit.test() method\n     */\n    function ProcessingQueue(test) {\n      _classCallCheck(this, ProcessingQueue);\n      this.test = test;\n      this.priorityCount = 0;\n      this.unitSampler = null;\n\n      // This is a queue of functions that are tasks within a single test.\n      // After tests are dequeued from config.queue they are expanded into\n      // a set of tasks in this queue.\n      this.taskQueue = [];\n      this.finished = false;\n    }\n\n    /**\n     * Advances the taskQueue to the next task. If the taskQueue is empty,\n     * process the testQueue\n     */\n    return _createClass(ProcessingQueue, [{\n      key: \"advance\",\n      value: function advance() {\n        this.advanceTaskQueue();\n        if (!this.taskQueue.length && !config.blocking && !config.current) {\n          this.advanceTestQueue();\n        }\n      }\n\n      /**\n       * Advances the taskQueue with an increased depth\n       */\n    }, {\n      key: \"advanceTaskQueue\",\n      value: function advanceTaskQueue() {\n        var start = performance.now();\n        config.depth = (config.depth || 0) + 1;\n        this.processTaskQueue(start);\n        config.depth--;\n      }\n\n      /**\n       * Process the first task on the taskQueue as a promise.\n       * Each task is a function added by Test#queue() in /src/test.js\n       */\n    }, {\n      key: \"processTaskQueue\",\n      value: function processTaskQueue(start) {\n        var _this = this;\n        if (this.taskQueue.length && !config.blocking) {\n          var elapsedTime = performance.now() - start;\n          if (!setTimeout$1 || config.updateRate <= 0 || elapsedTime < config.updateRate) {\n            var task = this.taskQueue.shift();\n            _Promise.resolve(task()).then(function () {\n              if (!_this.taskQueue.length) {\n                _this.advance();\n              } else {\n                _this.processTaskQueue(start);\n              }\n            });\n          } else {\n            setTimeout$1(function () {\n              _this.advance();\n            });\n          }\n        }\n      }\n\n      /**\n       * Advance the testQueue to the next test to process. Call done() if testQueue completes.\n       */\n    }, {\n      key: \"advanceTestQueue\",\n      value: function advanceTestQueue() {\n        if (!config.blocking && !config.queue.length && config.depth === 0) {\n          this.done();\n          return;\n        }\n        var testTasks = config.queue.shift();\n        this.addToTaskQueue(testTasks());\n        if (this.priorityCount > 0) {\n          this.priorityCount--;\n        }\n        this.advance();\n      }\n\n      /**\n       * Enqueue the tasks for a test into the task queue.\n       * @param {Array} tasksArray\n       */\n    }, {\n      key: \"addToTaskQueue\",\n      value: function addToTaskQueue(tasksArray) {\n        var _this$taskQueue;\n        (_this$taskQueue = this.taskQueue).push.apply(_this$taskQueue, _toConsumableArray(tasksArray));\n      }\n\n      /**\n       * Return the number of tasks remaining in the task queue to be processed.\n       * @return {number}\n       */\n    }, {\n      key: \"taskCount\",\n      value: function taskCount() {\n        return this.taskQueue.length;\n      }\n\n      /**\n       * Adds a test to the TestQueue for execution.\n       * @param {Function} testTasksFunc\n       * @param {boolean} prioritize\n       */\n    }, {\n      key: \"add\",\n      value: function add(testTasksFunc, prioritize) {\n        if (prioritize) {\n          config.queue.splice(this.priorityCount++, 0, testTasksFunc);\n        } else if (config.seed) {\n          if (!this.unitSampler) {\n            this.unitSampler = unitSamplerGenerator(config.seed);\n          }\n\n          // Insert into a random position after all prioritized items\n          var index = Math.floor(this.unitSampler() * (config.queue.length - this.priorityCount + 1));\n          config.queue.splice(this.priorityCount + index, 0, testTasksFunc);\n        } else {\n          config.queue.push(testTasksFunc);\n        }\n      }\n\n      /**\n       * This function is called when the ProcessingQueue is done processing all\n       * items. It handles emitting the final run events.\n       */\n    }, {\n      key: \"done\",\n      value: function done() {\n        // We have reached the end of the processing queue and are about to emit the\n        // \"runEnd\" event after which reporters typically stop listening and exit\n        // the process. First, check if we need to emit one final test.\n        if (config.stats.testCount === 0 && config.failOnZeroTests === true) {\n          var error;\n          if (config.filter && config.filter.length) {\n            error = new Error(\"No tests matched the filter \\\"\".concat(config.filter, \"\\\".\"));\n          } else if (config.module && config.module.length) {\n            error = new Error(\"No tests matched the module \\\"\".concat(config.module, \"\\\".\"));\n          } else if (config.moduleId && config.moduleId.length) {\n            error = new Error(\"No tests matched the moduleId \\\"\".concat(config.moduleId, \"\\\".\"));\n          } else if (config.testId && config.testId.length) {\n            error = new Error(\"No tests matched the testId \\\"\".concat(config.testId, \"\\\".\"));\n          } else {\n            error = new Error('No tests were run.');\n          }\n          this.test('global failure', extend(function (assert) {\n            assert.pushResult({\n              result: false,\n              message: error.message,\n              source: error.stack\n            });\n          }, {\n            validTest: true\n          }));\n\n          // We do need to call `advance()` in order to resume the processing queue.\n          // Once this new test is finished processing, we'll reach `done` again, and\n          // that time the above condition will evaluate to false.\n          this.advance();\n          return;\n        }\n        var storage = config.storage;\n        var runtime = Math.round(performance.now() - config.started);\n        var passed = config.stats.all - config.stats.bad;\n        this.finished = true;\n        emit('runEnd', runSuite.end(true));\n        runLoggingCallbacks('done', {\n          // @deprecated since 2.19.0 Use done() without `details` parameter,\n          // or use `QUnit.on('runEnd')` instead. Parameter to be replaced in\n          // QUnit 3.0 with test counts.\n          passed: passed,\n          failed: config.stats.bad,\n          total: config.stats.all,\n          runtime: runtime\n        }).then(function () {\n          // Clear own storage items if all tests passed\n          if (storage && config.stats.bad === 0) {\n            for (var i = storage.length - 1; i >= 0; i--) {\n              var key = storage.key(i);\n              if (key.indexOf('qunit-test-') === 0) {\n                storage.removeItem(key);\n              }\n            }\n          }\n        });\n      }\n    }]);\n  }();\n\n  /**\n   * Handle a global error that should result in a failed test run.\n   *\n   * Summary:\n   *\n   * - If we're strictly inside a test (or one if its module hooks), the exception\n   *   becomes a failed assertion.\n   *\n   *   This has the important side-effect that uncaught exceptions (such as\n   *   calling an undefined function) during a \"todo\" test do NOT result in\n   *   a failed test run.\n   *\n   * - If we're anywhere outside a test (be it in early event callbacks, or\n   *   internally between tests, or somewhere after \"runEnd\" if the process is\n   *   still alive for some reason), then send an \"error\" event to the reporters.\n   *\n   * @since 2.17.0\n   * @param {Error|any} error\n   */\n  function onUncaughtException(error) {\n    if (config.current) {\n      // This omits 'actual' and 'expected' (undefined)\n      config.current.assert.pushResult({\n        result: false,\n        message: \"global failure: \".concat(errorString(error)),\n        // We could let callers specify an offset to subtract a number of frames via\n        // sourceFromStacktrace, in case they are a wrapper further away from the error\n        // handler, and thus reduce some noise in the stack trace. However, we're not\n        // doing this right now because it would almost never be used in practice given\n        // the vast majority of error values will be Error objects, and thus have their\n        // own stack trace already.\n        source: error && error.stack || sourceFromStacktrace(2)\n      });\n    } else {\n      // The \"error\" event was added in QUnit 2.17.\n      // Increase \"bad assertion\" stats despite no longer pushing an assertion in this case.\n      // This ensures \"runEnd\" and \"QUnit.done()\" handlers behave as expected, since the \"bad\"\n      // count is typically how reporters decide on the boolean outcome of the test run.\n      runSuite.globalFailureCount++;\n      config.stats.bad++;\n      config.stats.all++;\n      emit('error', error);\n    }\n  }\n\n  /**\n   * Handle a window.onerror error.\n   *\n   * If there is a current test that sets the internal `ignoreGlobalErrors` field\n   * (such as during `assert.throws()`), then the error is ignored and native\n   * error reporting is suppressed as well. This is because in browsers, an error\n   * can sometimes end up in `window.onerror` instead of in the local try/catch.\n   * This ignoring of errors does not apply to our general onUncaughtException\n   * method, nor to our `unhandledRejection` handlers, as those are not meant\n   * to receive an \"expected\" error during `assert.throws()`.\n   *\n   * @see <https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror>\n   * @deprecated since 2.17.0 Use QUnit.onUncaughtException instead.\n   * @param {Object} details\n   * @param {string} details.message\n   * @param {string} details.fileName\n   * @param {number} details.lineNumber\n   * @param {string|undefined} [details.stacktrace]\n   * @return {bool} True if native error reporting should be suppressed.\n   */\n  function onWindowError(details) {\n    Logger.warn('QUnit.onError is deprecated and will be removed in QUnit 3.0.' + ' Please use QUnit.onUncaughtException instead.');\n    if (config.current && config.current.ignoreGlobalErrors) {\n      return true;\n    }\n    var err = new Error(details.message);\n    err.stack = details.stacktrace || details.fileName + ':' + details.lineNumber;\n    onUncaughtException(err);\n    return false;\n  }\n\n  /* eslint-disable indent */\n\n  /*\n   * This file is a modified version of google-diff-match-patch's JavaScript implementation\n   * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n   * modifications are licensed as more fully set forth in LICENSE.txt.\n   *\n   * The original source of google-diff-match-patch is attributable and licensed as follows:\n   *\n   * Copyright 2006 Google Inc.\n   * https://code.google.com/p/google-diff-match-patch/\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   * https://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * More Info:\n   *  https://code.google.com/p/google-diff-match-patch/\n   *\n   * Usage: QUnit.diff(expected, actual)\n   *\n   */\n  function DiffMatchPatch() {}\n\n  //  DIFF FUNCTIONS\n\n  /**\n   * The data structure representing a diff is an array of tuples:\n   * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n   * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n   */\n  var DIFF_DELETE = -1;\n  var DIFF_INSERT = 1;\n  var DIFF_EQUAL = 0;\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  /**\n   * Find the differences between two texts.  Simplifies the problem by stripping\n   * any common prefix or suffix off the texts before diffing.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n   *     then don't run a line-level diff first to identify the changed areas.\n   *     Defaults to true, which does a faster, slightly less optimal diff.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   */\n  DiffMatchPatch.prototype.DiffMain = function (text1, text2, optChecklines) {\n    // The diff must be complete in up to 1 second.\n    var deadline = Date.now() + 1000;\n\n    // Check for null inputs.\n    if (text1 === null || text2 === null) {\n      throw new Error('Cannot diff null input.');\n    }\n\n    // Check for equality (speedup).\n    if (text1 === text2) {\n      if (text1) {\n        return [[DIFF_EQUAL, text1]];\n      }\n      return [];\n    }\n    if (typeof optChecklines === 'undefined') {\n      optChecklines = true;\n    }\n\n    // Trim off common prefix (speedup).\n    var commonlength = this.diffCommonPrefix(text1, text2);\n    var commonprefix = text1.substring(0, commonlength);\n    text1 = text1.substring(commonlength);\n    text2 = text2.substring(commonlength);\n\n    // Trim off common suffix (speedup).\n    commonlength = this.diffCommonSuffix(text1, text2);\n    var commonsuffix = text1.substring(text1.length - commonlength);\n    text1 = text1.substring(0, text1.length - commonlength);\n    text2 = text2.substring(0, text2.length - commonlength);\n\n    // Compute the diff on the middle block.\n    var diffs = this.diffCompute(text1, text2, optChecklines, deadline);\n\n    // Restore the prefix and suffix.\n    if (commonprefix) {\n      diffs.unshift([DIFF_EQUAL, commonprefix]);\n    }\n    if (commonsuffix) {\n      diffs.push([DIFF_EQUAL, commonsuffix]);\n    }\n    this.diffCleanupMerge(diffs);\n    return diffs;\n  };\n\n  /**\n   * Reduce the number of edits by eliminating operationally trivial equalities.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   */\n  DiffMatchPatch.prototype.diffCleanupEfficiency = function (diffs) {\n    var changes, equalities, equalitiesLength, lastequality, pointer, preIns, preDel, postIns, postDel;\n    changes = false;\n    equalities = []; // Stack of indices where equalities are found.\n    equalitiesLength = 0; // Keeping our own length var is faster in JS.\n    /** @type {?string} */\n    lastequality = null;\n\n    // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n    pointer = 0; // Index of current position.\n\n    // Is there an insertion operation before the last equality.\n    preIns = false;\n\n    // Is there a deletion operation before the last equality.\n    preDel = false;\n\n    // Is there an insertion operation after the last equality.\n    postIns = false;\n\n    // Is there a deletion operation after the last equality.\n    postDel = false;\n    while (pointer < diffs.length) {\n      // Equality found.\n      if (diffs[pointer][0] === DIFF_EQUAL) {\n        if (diffs[pointer][1].length < 4 && (postIns || postDel)) {\n          // Candidate found.\n          equalities[equalitiesLength++] = pointer;\n          preIns = postIns;\n          preDel = postDel;\n          lastequality = diffs[pointer][1];\n        } else {\n          // Not a candidate, and can never become one.\n          equalitiesLength = 0;\n          lastequality = null;\n        }\n        postIns = postDel = false;\n\n        // An insertion or deletion.\n      } else {\n        if (diffs[pointer][0] === DIFF_DELETE) {\n          postDel = true;\n        } else {\n          postIns = true;\n        }\n\n        /*\n         * Five types to be split:\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\n         * <ins>A</del>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<del>C</del>\n         */\n        if (lastequality && (preIns && preDel && postIns && postDel || lastequality.length < 2 && preIns + preDel + postIns + postDel === 3)) {\n          // Duplicate record.\n          diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);\n\n          // Change second copy to insert.\n          diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n          equalitiesLength--; // Throw away the equality we just deleted;\n          lastequality = null;\n          if (preIns && preDel) {\n            // No changes made which could affect previous entry, keep going.\n            postIns = postDel = true;\n            equalitiesLength = 0;\n          } else {\n            equalitiesLength--; // Throw away the previous equality.\n            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n            postIns = postDel = false;\n          }\n          changes = true;\n        }\n      }\n      pointer++;\n    }\n    if (changes) {\n      this.diffCleanupMerge(diffs);\n    }\n  };\n\n  /**\n   * Convert a diff array into a pretty HTML report.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   * @param {integer} string to be beautified.\n   * @return {string} HTML representation.\n   */\n  DiffMatchPatch.prototype.diffPrettyHtml = function (diffs) {\n    var html = [];\n    for (var x = 0; x < diffs.length; x++) {\n      var op = diffs[x][0]; // Operation (insert, delete, equal)\n      var data = diffs[x][1]; // Text of change.\n      switch (op) {\n        case DIFF_INSERT:\n          html[x] = '<ins>' + escapeText(data) + '</ins>';\n          break;\n        case DIFF_DELETE:\n          html[x] = '<del>' + escapeText(data) + '</del>';\n          break;\n        case DIFF_EQUAL:\n          html[x] = '<span>' + escapeText(data) + '</span>';\n          break;\n      }\n    }\n    return html.join('');\n  };\n\n  /**\n   * Determine the common prefix of two strings.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {number} The number of characters common to the start of each\n   *     string.\n   */\n  DiffMatchPatch.prototype.diffCommonPrefix = function (text1, text2) {\n    var pointermid, pointermax, pointermin, pointerstart;\n\n    // Quick check for common null cases.\n    if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {\n      return 0;\n    }\n\n    // Binary search.\n    // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n    pointermin = 0;\n    pointermax = Math.min(text1.length, text2.length);\n    pointermid = pointermax;\n    pointerstart = 0;\n    while (pointermin < pointermid) {\n      if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {\n        pointermin = pointermid;\n        pointerstart = pointermin;\n      } else {\n        pointermax = pointermid;\n      }\n      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n    }\n    return pointermid;\n  };\n\n  /**\n   * Determine the common suffix of two strings.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {number} The number of characters common to the end of each string.\n   */\n  DiffMatchPatch.prototype.diffCommonSuffix = function (text1, text2) {\n    var pointermid, pointermax, pointermin, pointerend;\n\n    // Quick check for common null cases.\n    if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {\n      return 0;\n    }\n\n    // Binary search.\n    // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n    pointermin = 0;\n    pointermax = Math.min(text1.length, text2.length);\n    pointermid = pointermax;\n    pointerend = 0;\n    while (pointermin < pointermid) {\n      if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n        pointermin = pointermid;\n        pointerend = pointermin;\n      } else {\n        pointermax = pointermid;\n      }\n      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n    }\n    return pointermid;\n  };\n\n  /**\n   * Find the differences between two texts.  Assumes that the texts do not\n   * have any common prefix or suffix.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {boolean} checklines Speedup flag.  If false, then don't run a\n   *     line-level diff first to identify the changed areas.\n   *     If true, then run a faster, slightly less optimal diff.\n   * @param {number} deadline Time when the diff should be complete by.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   * @private\n   */\n  DiffMatchPatch.prototype.diffCompute = function (text1, text2, checklines, deadline) {\n    var diffs, longtext, shorttext, i, hm, text1A, text2A, text1B, text2B, midCommon, diffsA, diffsB;\n    if (!text1) {\n      // Just add some text (speedup).\n      return [[DIFF_INSERT, text2]];\n    }\n    if (!text2) {\n      // Just delete some text (speedup).\n      return [[DIFF_DELETE, text1]];\n    }\n    longtext = text1.length > text2.length ? text1 : text2;\n    shorttext = text1.length > text2.length ? text2 : text1;\n    i = longtext.indexOf(shorttext);\n    if (i !== -1) {\n      // Shorter text is inside the longer text (speedup).\n      diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n\n      // Swap insertions for deletions if diff is reversed.\n      if (text1.length > text2.length) {\n        diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n      }\n      return diffs;\n    }\n    if (shorttext.length === 1) {\n      // Single character string.\n      // After the previous speedup, the character can't be an equality.\n      return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n    }\n\n    // Check to see if the problem can be split in two.\n    hm = this.diffHalfMatch(text1, text2);\n    if (hm) {\n      // A half-match was found, sort out the return data.\n      text1A = hm[0];\n      text1B = hm[1];\n      text2A = hm[2];\n      text2B = hm[3];\n      midCommon = hm[4];\n\n      // Send both pairs off for separate processing.\n      diffsA = this.DiffMain(text1A, text2A, checklines, deadline);\n      diffsB = this.DiffMain(text1B, text2B, checklines, deadline);\n\n      // Merge the results.\n      return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n    }\n    if (checklines && text1.length > 100 && text2.length > 100) {\n      return this.diffLineMode(text1, text2, deadline);\n    }\n    return this.diffBisect(text1, text2, deadline);\n  };\n\n  /**\n   * Do the two texts share a substring which is at least half the length of the\n   * longer text?\n   * This speedup can produce non-minimal diffs.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     text1, the suffix of text1, the prefix of text2, the suffix of\n   *     text2 and the common middle.  Or null if there was no match.\n   * @private\n   */\n  DiffMatchPatch.prototype.diffHalfMatch = function (text1, text2) {\n    var longtext, shorttext, dmp, text1A, text2B, text2A, text1B, midCommon, hm1, hm2, hm;\n    longtext = text1.length > text2.length ? text1 : text2;\n    shorttext = text1.length > text2.length ? text2 : text1;\n    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n      return null; // Pointless.\n    }\n    dmp = this; // 'this' becomes 'window' in a closure.\n\n    /**\n     * Does a substring of shorttext exist within longtext such that the substring\n     * is at least half the length of longtext?\n     * Closure, but does not reference any external variables.\n     * @param {string} longtext Longer string.\n     * @param {string} shorttext Shorter string.\n     * @param {number} i Start index of quarter length substring within longtext.\n     * @return {Array.<string>} Five element Array, containing the prefix of\n     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n     *     of shorttext and the common middle.  Or null if there was no match.\n     * @private\n     */\n    function diffHalfMatchI(longtext, shorttext, i) {\n      var seed, j, bestCommon, prefixLength, suffixLength, bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\n      // Start with a 1/4 length substring at position i as a seed.\n      seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n      j = -1;\n      bestCommon = '';\n      while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {\n        prefixLength = dmp.diffCommonPrefix(longtext.substring(i), shorttext.substring(j));\n        suffixLength = dmp.diffCommonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\n        if (bestCommon.length < suffixLength + prefixLength) {\n          bestCommon = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n          bestLongtextA = longtext.substring(0, i - suffixLength);\n          bestLongtextB = longtext.substring(i + prefixLength);\n          bestShorttextA = shorttext.substring(0, j - suffixLength);\n          bestShorttextB = shorttext.substring(j + prefixLength);\n        }\n      }\n      if (bestCommon.length * 2 >= longtext.length) {\n        return [bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB, bestCommon];\n      } else {\n        return null;\n      }\n    }\n\n    // First check if the second quarter is the seed for a half-match.\n    hm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));\n\n    // Check again based on the third quarter.\n    hm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));\n    if (!hm1 && !hm2) {\n      return null;\n    } else if (!hm2) {\n      hm = hm1;\n    } else if (!hm1) {\n      hm = hm2;\n    } else {\n      // Both matched.  Select the longest.\n      hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n    }\n\n    // A half-match was found, sort out the return data.\n    if (text1.length > text2.length) {\n      text1A = hm[0];\n      text1B = hm[1];\n      text2A = hm[2];\n      text2B = hm[3];\n    } else {\n      text2A = hm[0];\n      text2B = hm[1];\n      text1A = hm[2];\n      text1B = hm[3];\n    }\n    midCommon = hm[4];\n    return [text1A, text1B, text2A, text2B, midCommon];\n  };\n\n  /**\n   * Do a quick line-level diff on both strings, then rediff the parts for\n   * greater accuracy.\n   * This speedup can produce non-minimal diffs.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {number} deadline Time when the diff should be complete by.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   * @private\n   */\n  DiffMatchPatch.prototype.diffLineMode = function (text1, text2, deadline) {\n    var a, diffs, linearray, pointer, countInsert, countDelete, textInsert, textDelete, j;\n\n    // Scan the text on a line-by-line basis first.\n    a = this.diffLinesToChars(text1, text2);\n    text1 = a.chars1;\n    text2 = a.chars2;\n    linearray = a.lineArray;\n    diffs = this.DiffMain(text1, text2, false, deadline);\n\n    // Convert the diff back to original text.\n    this.diffCharsToLines(diffs, linearray);\n\n    // Eliminate freak matches (e.g. blank lines)\n    this.diffCleanupSemantic(diffs);\n\n    // Rediff any replacement blocks, this time character-by-character.\n    // Add a dummy entry at the end.\n    diffs.push([DIFF_EQUAL, '']);\n    pointer = 0;\n    countDelete = 0;\n    countInsert = 0;\n    textDelete = '';\n    textInsert = '';\n    while (pointer < diffs.length) {\n      switch (diffs[pointer][0]) {\n        case DIFF_INSERT:\n          countInsert++;\n          textInsert += diffs[pointer][1];\n          break;\n        case DIFF_DELETE:\n          countDelete++;\n          textDelete += diffs[pointer][1];\n          break;\n        case DIFF_EQUAL:\n          // Upon reaching an equality, check for prior redundancies.\n          if (countDelete >= 1 && countInsert >= 1) {\n            // Delete the offending records and add the merged ones.\n            diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);\n            pointer = pointer - countDelete - countInsert;\n            a = this.DiffMain(textDelete, textInsert, false, deadline);\n            for (j = a.length - 1; j >= 0; j--) {\n              diffs.splice(pointer, 0, a[j]);\n            }\n            pointer = pointer + a.length;\n          }\n          countInsert = 0;\n          countDelete = 0;\n          textDelete = '';\n          textInsert = '';\n          break;\n      }\n      pointer++;\n    }\n    diffs.pop(); // Remove the dummy entry at the end.\n\n    return diffs;\n  };\n\n  /**\n   * Find the 'middle snake' of a diff, split the problem in two\n   * and return the recursively constructed diff.\n   * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {number} deadline Time at which to bail if not yet complete.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   * @private\n   */\n  DiffMatchPatch.prototype.diffBisect = function (text1, text2, deadline) {\n    var text1Length, text2Length, maxD, vOffset, vLength, v1, v2, x, delta, front, k1start, k1end, k2start, k2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\n    // Cache the text lengths to prevent multiple calls.\n    text1Length = text1.length;\n    text2Length = text2.length;\n    maxD = Math.ceil((text1Length + text2Length) / 2);\n    vOffset = maxD;\n    vLength = 2 * maxD;\n    v1 = new Array(vLength);\n    v2 = new Array(vLength);\n\n    // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n    // integers and undefined.\n    for (x = 0; x < vLength; x++) {\n      v1[x] = -1;\n      v2[x] = -1;\n    }\n    v1[vOffset + 1] = 0;\n    v2[vOffset + 1] = 0;\n    delta = text1Length - text2Length;\n\n    // If the total number of characters is odd, then the front path will collide\n    // with the reverse path.\n    front = delta % 2 !== 0;\n\n    // Offsets for start and end of k loop.\n    // Prevents mapping of space beyond the grid.\n    k1start = 0;\n    k1end = 0;\n    k2start = 0;\n    k2end = 0;\n    for (d = 0; d < maxD; d++) {\n      // Bail out if deadline is reached.\n      if (Date.now() > deadline) {\n        break;\n      }\n\n      // Walk the front path one step.\n      for (k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n        k1Offset = vOffset + k1;\n        if (k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1]) {\n          x1 = v1[k1Offset + 1];\n        } else {\n          x1 = v1[k1Offset - 1] + 1;\n        }\n        y1 = x1 - k1;\n        while (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {\n          x1++;\n          y1++;\n        }\n        v1[k1Offset] = x1;\n        if (x1 > text1Length) {\n          // Ran off the right of the graph.\n          k1end += 2;\n        } else if (y1 > text2Length) {\n          // Ran off the bottom of the graph.\n          k1start += 2;\n        } else if (front) {\n          k2Offset = vOffset + delta - k1;\n          if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n            // Mirror x2 onto top-left coordinate system.\n            x2 = text1Length - v2[k2Offset];\n            if (x1 >= x2) {\n              // Overlap detected.\n              return this.diffBisectSplit(text1, text2, x1, y1, deadline);\n            }\n          }\n        }\n      }\n\n      // Walk the reverse path one step.\n      for (k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n        k2Offset = vOffset + k2;\n        if (k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1]) {\n          x2 = v2[k2Offset + 1];\n        } else {\n          x2 = v2[k2Offset - 1] + 1;\n        }\n        y2 = x2 - k2;\n        while (x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)) {\n          x2++;\n          y2++;\n        }\n        v2[k2Offset] = x2;\n        if (x2 > text1Length) {\n          // Ran off the left of the graph.\n          k2end += 2;\n        } else if (y2 > text2Length) {\n          // Ran off the top of the graph.\n          k2start += 2;\n        } else if (!front) {\n          k1Offset = vOffset + delta - k2;\n          if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n            x1 = v1[k1Offset];\n            y1 = vOffset + x1 - k1Offset;\n\n            // Mirror x2 onto top-left coordinate system.\n            x2 = text1Length - x2;\n            if (x1 >= x2) {\n              // Overlap detected.\n              return this.diffBisectSplit(text1, text2, x1, y1, deadline);\n            }\n          }\n        }\n      }\n    }\n\n    // Diff took too long and hit the deadline or\n    // number of diffs equals number of characters, no commonality at all.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  };\n\n  /**\n   * Given the location of the 'middle snake', split the diff in two parts\n   * and recurse.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {number} x Index of split point in text1.\n   * @param {number} y Index of split point in text2.\n   * @param {number} deadline Time at which to bail if not yet complete.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   * @private\n   */\n  DiffMatchPatch.prototype.diffBisectSplit = function (text1, text2, x, y, deadline) {\n    var text1a, text1b, text2a, text2b, diffs, diffsb;\n    text1a = text1.substring(0, x);\n    text2a = text2.substring(0, y);\n    text1b = text1.substring(x);\n    text2b = text2.substring(y);\n\n    // Compute both diffs serially.\n    diffs = this.DiffMain(text1a, text2a, false, deadline);\n    diffsb = this.DiffMain(text1b, text2b, false, deadline);\n    return diffs.concat(diffsb);\n  };\n\n  /**\n   * Reduce the number of edits by eliminating semantically trivial equalities.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   */\n  DiffMatchPatch.prototype.diffCleanupSemantic = function (diffs) {\n    var changes = false;\n    var equalities = []; // Stack of indices where equalities are found.\n    var equalitiesLength = 0; // Keeping our own length var is faster in JS.\n    /** @type {?string} */\n    var lastequality = null;\n\n    // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n    var pointer = 0; // Index of current position.\n\n    // Number of characters that changed prior to the equality.\n    var lengthInsertions1 = 0;\n    var lengthDeletions1 = 0;\n\n    // Number of characters that changed after the equality.\n    var lengthInsertions2 = 0;\n    var lengthDeletions2 = 0;\n    while (pointer < diffs.length) {\n      if (diffs[pointer][0] === DIFF_EQUAL) {\n        // Equality found.\n        equalities[equalitiesLength++] = pointer;\n        lengthInsertions1 = lengthInsertions2;\n        lengthDeletions1 = lengthDeletions2;\n        lengthInsertions2 = 0;\n        lengthDeletions2 = 0;\n        lastequality = diffs[pointer][1];\n      } else {\n        // An insertion or deletion.\n        if (diffs[pointer][0] === DIFF_INSERT) {\n          lengthInsertions2 += diffs[pointer][1].length;\n        } else {\n          lengthDeletions2 += diffs[pointer][1].length;\n        }\n\n        // Eliminate an equality that is smaller or equal to the edits on both\n        // sides of it.\n        if (lastequality && lastequality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastequality.length <= Math.max(lengthInsertions2, lengthDeletions2)) {\n          // Duplicate record.\n          diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);\n\n          // Change second copy to insert.\n          diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n\n          // Throw away the equality we just deleted.\n          equalitiesLength--;\n\n          // Throw away the previous equality (it needs to be reevaluated).\n          equalitiesLength--;\n          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n\n          // Reset the counters.\n          lengthInsertions1 = 0;\n          lengthDeletions1 = 0;\n          lengthInsertions2 = 0;\n          lengthDeletions2 = 0;\n          lastequality = null;\n          changes = true;\n        }\n      }\n      pointer++;\n    }\n\n    // Normalize the diff.\n    if (changes) {\n      this.diffCleanupMerge(diffs);\n    }\n    var deletion, insertion, overlapLength1, overlapLength2;\n\n    // Find any overlaps between deletions and insertions.\n    // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n    //   -> <del>abc</del>xxx<ins>def</ins>\n    // e.g: <del>xxxabc</del><ins>defxxx</ins>\n    //   -> <ins>def</ins>xxx<del>abc</del>\n    // Only extract an overlap if it is as big as the edit ahead or behind it.\n    pointer = 1;\n    while (pointer < diffs.length) {\n      if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n        deletion = diffs[pointer - 1][1];\n        insertion = diffs[pointer][1];\n        overlapLength1 = this.diffCommonOverlap(deletion, insertion);\n        overlapLength2 = this.diffCommonOverlap(insertion, deletion);\n        if (overlapLength1 >= overlapLength2) {\n          if (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {\n            // Overlap found.  Insert an equality and trim the surrounding edits.\n            diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]);\n            diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);\n            diffs[pointer + 1][1] = insertion.substring(overlapLength1);\n            pointer++;\n          }\n        } else {\n          if (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {\n            // Reverse overlap found.\n            // Insert an equality and swap and trim the surrounding edits.\n            diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]);\n            diffs[pointer - 1][0] = DIFF_INSERT;\n            diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);\n            diffs[pointer + 1][0] = DIFF_DELETE;\n            diffs[pointer + 1][1] = deletion.substring(overlapLength2);\n            pointer++;\n          }\n        }\n        pointer++;\n      }\n      pointer++;\n    }\n  };\n\n  /**\n   * Determine if the suffix of one string is the prefix of another.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {number} The number of characters common to the end of the first\n   *     string and the start of the second string.\n   * @private\n   */\n  DiffMatchPatch.prototype.diffCommonOverlap = function (text1, text2) {\n    // Cache the text lengths to prevent multiple calls.\n    var text1Length = text1.length;\n    var text2Length = text2.length;\n\n    // Eliminate the null case.\n    if (text1Length === 0 || text2Length === 0) {\n      return 0;\n    }\n\n    // Truncate the longer string.\n    if (text1Length > text2Length) {\n      text1 = text1.substring(text1Length - text2Length);\n    } else if (text1Length < text2Length) {\n      text2 = text2.substring(0, text1Length);\n    }\n    var textLength = Math.min(text1Length, text2Length);\n\n    // Quick check for the worst case.\n    if (text1 === text2) {\n      return textLength;\n    }\n\n    // Start by looking for a single character match\n    // and increase length until no match is found.\n    // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n    var best = 0;\n    var length = 1;\n    while (true) {\n      var pattern = text1.substring(textLength - length);\n      var found = text2.indexOf(pattern);\n      if (found === -1) {\n        return best;\n      }\n      length += found;\n      if (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) {\n        best = length;\n        length++;\n      }\n    }\n  };\n\n  /**\n   * Split two texts into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n   *     An object containing the encoded text1, the encoded text2 and\n   *     the array of unique strings.\n   *     The zeroth element of the array of unique strings is intentionally blank.\n   * @private\n   */\n  DiffMatchPatch.prototype.diffLinesToChars = function (text1, text2) {\n    var lineArray = []; // E.g. lineArray[4] === 'Hello\\n'\n    var lineHash = {}; // E.g. lineHash['Hello\\n'] === 4\n\n    // '\\x00' is a valid character, but various debuggers don't like it.\n    // So we'll insert a junk entry to avoid generating a null character.\n    lineArray[0] = '';\n\n    /**\n     * Split a text into an array of strings.  Reduce the texts to a string of\n     * hashes where each Unicode character represents one line.\n     * Modifies linearray and linehash through being a closure.\n     * @param {string} text String to encode.\n     * @return {string} Encoded string.\n     * @private\n     */\n    function diffLinesToCharsMunge(text) {\n      var chars = '';\n\n      // Walk the text, pulling out a substring for each line.\n      // text.split('\\n') would would temporarily double our memory footprint.\n      // Modifying text would create many large strings to garbage collect.\n      var lineStart = 0;\n      var lineEnd = -1;\n\n      // Keeping our own length variable is faster than looking it up.\n      var lineArrayLength = lineArray.length;\n      while (lineEnd < text.length - 1) {\n        lineEnd = text.indexOf('\\n', lineStart);\n        if (lineEnd === -1) {\n          lineEnd = text.length - 1;\n        }\n        var line = text.substring(lineStart, lineEnd + 1);\n        lineStart = lineEnd + 1;\n        if (hasOwn.call(lineHash, line)) {\n          chars += String.fromCharCode(lineHash[line]);\n        } else {\n          chars += String.fromCharCode(lineArrayLength);\n          lineHash[line] = lineArrayLength;\n          lineArray[lineArrayLength++] = line;\n        }\n      }\n      return chars;\n    }\n    var chars1 = diffLinesToCharsMunge(text1);\n    var chars2 = diffLinesToCharsMunge(text2);\n    return {\n      chars1: chars1,\n      chars2: chars2,\n      lineArray: lineArray\n    };\n  };\n\n  /**\n   * Rehydrate the text in a diff from a string of line hashes to real lines of\n   * text.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   * @param {!Array.<string>} lineArray Array of unique strings.\n   * @private\n   */\n  DiffMatchPatch.prototype.diffCharsToLines = function (diffs, lineArray) {\n    for (var x = 0; x < diffs.length; x++) {\n      var chars = diffs[x][1];\n      var text = [];\n      for (var y = 0; y < chars.length; y++) {\n        text[y] = lineArray[chars.charCodeAt(y)];\n      }\n      diffs[x][1] = text.join('');\n    }\n  };\n\n  /**\n   * Reorder and merge like edit sections.  Merge equalities.\n   * Any edit section can move as long as it doesn't cross an equality.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   */\n  DiffMatchPatch.prototype.diffCleanupMerge = function (diffs) {\n    diffs.push([DIFF_EQUAL, '']); // Add a dummy entry at the end.\n    var pointer = 0;\n    var countDelete = 0;\n    var countInsert = 0;\n    var textDelete = '';\n    var textInsert = '';\n    while (pointer < diffs.length) {\n      switch (diffs[pointer][0]) {\n        case DIFF_INSERT:\n          countInsert++;\n          textInsert += diffs[pointer][1];\n          pointer++;\n          break;\n        case DIFF_DELETE:\n          countDelete++;\n          textDelete += diffs[pointer][1];\n          pointer++;\n          break;\n        case DIFF_EQUAL:\n          // Upon reaching an equality, check for prior redundancies.\n          if (countDelete + countInsert > 1) {\n            if (countDelete !== 0 && countInsert !== 0) {\n              // Factor out any common prefixes.\n              var commonlength = this.diffCommonPrefix(textInsert, textDelete);\n              if (commonlength !== 0) {\n                if (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL) {\n                  diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength);\n                } else {\n                  diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]);\n                  pointer++;\n                }\n                textInsert = textInsert.substring(commonlength);\n                textDelete = textDelete.substring(commonlength);\n              }\n\n              // Factor out any common suffixies.\n              commonlength = this.diffCommonSuffix(textInsert, textDelete);\n              if (commonlength !== 0) {\n                diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1];\n                textInsert = textInsert.substring(0, textInsert.length - commonlength);\n                textDelete = textDelete.substring(0, textDelete.length - commonlength);\n              }\n            }\n\n            // Delete the offending records and add the merged ones.\n            if (countDelete === 0) {\n              diffs.splice(pointer - countInsert, countDelete + countInsert, [DIFF_INSERT, textInsert]);\n            } else if (countInsert === 0) {\n              diffs.splice(pointer - countDelete, countDelete + countInsert, [DIFF_DELETE, textDelete]);\n            } else {\n              diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert, [DIFF_DELETE, textDelete], [DIFF_INSERT, textInsert]);\n            }\n            pointer = pointer - countDelete - countInsert + (countDelete ? 1 : 0) + (countInsert ? 1 : 0) + 1;\n          } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n            // Merge this equality with the previous one.\n            diffs[pointer - 1][1] += diffs[pointer][1];\n            diffs.splice(pointer, 1);\n          } else {\n            pointer++;\n          }\n          countInsert = 0;\n          countDelete = 0;\n          textDelete = '';\n          textInsert = '';\n          break;\n      }\n    }\n    if (diffs[diffs.length - 1][1] === '') {\n      diffs.pop(); // Remove the dummy entry at the end.\n    }\n\n    // Second pass: look for single edits surrounded on both sides by equalities\n    // which can be shifted sideways to eliminate an equality.\n    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n    var changes = false;\n    pointer = 1;\n\n    // Intentionally ignore the first and last element (don't need checking).\n    while (pointer < diffs.length - 1) {\n      if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n        var diffPointer = diffs[pointer][1];\n        var position = diffPointer.substring(diffPointer.length - diffs[pointer - 1][1].length);\n\n        // This is a single edit surrounded by equalities.\n        if (position === diffs[pointer - 1][1]) {\n          // Shift the edit over the previous equality.\n          diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);\n          diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n          diffs.splice(pointer - 1, 1);\n          changes = true;\n        } else if (diffPointer.substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {\n          // Shift the edit over the next equality.\n          diffs[pointer - 1][1] += diffs[pointer + 1][1];\n          diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];\n          diffs.splice(pointer + 1, 1);\n          changes = true;\n        }\n      }\n      pointer++;\n    }\n\n    // If shifts were made, the diff needs reordering and another shift sweep.\n    if (changes) {\n      this.diffCleanupMerge(diffs);\n    }\n  };\n  function diff(o, n) {\n    var diff, output, text;\n    diff = new DiffMatchPatch();\n    output = diff.DiffMain(o, n);\n    diff.diffCleanupEfficiency(output);\n    text = diff.diffPrettyHtml(output);\n    return text;\n  }\n\n  var QUnit = {};\n\n  // The \"currentModule\" object would ideally be defined using the createModule()\n  // function. Since it isn't, add the missing suiteReport property to it now that\n  // we have loaded all source code required to do so.\n  //\n  // TODO: Consider defining currentModule in core.js or module.js in its entirely\n  // rather than partly in config.js and partly here.\n  config.currentModule.suiteReport = runSuite;\n  config.pq = new ProcessingQueue(test);\n  var globalStartCalled = false;\n  var runStarted = false;\n\n  // Figure out if we're running the tests from a server or not\n  QUnit.isLocal = window$1 && window$1.location && window$1.location.protocol === 'file:';\n\n  // Expose the current QUnit version\n  QUnit.version = '2.24.3';\n  extend(QUnit, {\n    config: config,\n    diff: diff,\n    dump: dump,\n    equiv: equiv,\n    reporters: reporters,\n    hooks: hooks,\n    is: is,\n    objectType: objectType,\n    on: on,\n    onError: onWindowError,\n    onUncaughtException: onUncaughtException,\n    pushFailure: pushFailure,\n    assert: Assert.prototype,\n    module: module$1,\n    test: test,\n    // alias other test flavors for easy access\n    todo: test.todo,\n    skip: test.skip,\n    only: test.only,\n    start: function start(count) {\n      if (config.current) {\n        throw new Error('QUnit.start cannot be called inside a test context.');\n      }\n      var globalStartAlreadyCalled = globalStartCalled;\n      globalStartCalled = true;\n      if (runStarted) {\n        throw new Error('Called start() while test already started running');\n      }\n      if (globalStartAlreadyCalled || count > 1) {\n        throw new Error('Called start() outside of a test context too many times');\n      }\n      if (config.autostart) {\n        throw new Error('Called start() outside of a test context when ' + 'QUnit.config.autostart was true');\n      }\n\n      // Until we remove QUnit.load() in QUnit 3, we keep `pageLoaded`.\n      // It no longer serves any purpose other than to support old test runners\n      // that still call only QUnit.load(), or that call both it and QUnit.start().\n      if (!config.pageLoaded) {\n        // If the test runner used `autostart = false` and is calling QUnit.start()\n        // to tell is their resources are ready, but the browser isn't ready yet,\n        // then enable autostart now, and we'll let the tests really start after\n        // the browser's \"load\" event handler calls autostart().\n        config.autostart = true;\n\n        // If we're in Node or another non-browser environment, we start now as there\n        // won't be any \"load\" event. We return early either way since autostart\n        // is responsible for calling scheduleBegin (avoid \"beginning\" twice).\n        if (!document) {\n          QUnit.autostart();\n        }\n        return;\n      }\n      scheduleBegin();\n    },\n    onUnhandledRejection: function onUnhandledRejection(reason) {\n      Logger.warn('QUnit.onUnhandledRejection is deprecated and will be removed in QUnit 3.0.' + ' Please use QUnit.onUncaughtException instead.');\n      onUncaughtException(reason);\n    },\n    extend: function extend$1() {\n      Logger.warn('QUnit.extend is deprecated and will be removed in QUnit 3.0.' + ' Please use Object.assign instead.');\n\n      // delegate to utility implementation, which does not warn and can be used elsewhere internally\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return extend.apply(this, args);\n    },\n    load: function load() {\n      Logger.warn('QUnit.load is deprecated and will be removed in QUnit 3.0.' + ' https://qunitjs.com/api/QUnit/load/');\n      QUnit.autostart();\n    },\n    /**\n     * @internal\n     */\n    autostart: function autostart() {\n      config.pageLoaded = true;\n\n      // Initialize the configuration options\n      // TODO: Move this to config.js in QUnit 3.\n      extend(config, {\n        started: 0,\n        updateRate: 1000,\n        autostart: true,\n        filter: ''\n      }, true);\n      if (!runStarted) {\n        config.blocking = false;\n        if (config.autostart) {\n          scheduleBegin();\n        }\n      }\n    },\n    stack: function stack(offset) {\n      offset = (offset || 0) + 2;\n      // Support Safari: Use temp variable to avoid TCO for consistent cross-browser result\n      // https://bugs.webkit.org/show_bug.cgi?id=276187\n      var source = sourceFromStacktrace(offset);\n      return source;\n    }\n  });\n  registerLoggingCallbacks(QUnit);\n  function scheduleBegin() {\n    runStarted = true;\n\n    // Add a slight delay to allow definition of more modules and tests.\n    if (setTimeout$1) {\n      setTimeout$1(function () {\n        begin();\n      });\n    } else {\n      begin();\n    }\n  }\n  function unblockAndAdvanceQueue() {\n    config.blocking = false;\n    config.pq.advance();\n  }\n  function begin() {\n    if (config.started) {\n      unblockAndAdvanceQueue();\n      return;\n    }\n\n    // QUnit.config.reporters is considered writable between qunit.js and QUnit.start().\n    // Now that QUnit.start() has been called, it is time to decide which built-in reporters\n    // to load.\n    if (config.reporters.console) {\n      reporters.console.init(QUnit);\n    }\n    if (config.reporters.tap) {\n      reporters.tap.init(QUnit);\n    }\n\n    // The test run hasn't officially begun yet\n    // Record the time of the test run's beginning\n    config.started = performance.now();\n\n    // Delete the loose unnamed module if unused.\n    if (config.modules[0].name === '' && config.modules[0].tests.length === 0) {\n      config.modules.shift();\n    }\n    var modulesLog = [];\n    for (var i = 0; i < config.modules.length; i++) {\n      // Don't expose the unnamed global test module to plugins.\n      if (config.modules[i].name !== '') {\n        modulesLog.push({\n          name: config.modules[i].name,\n          moduleId: config.modules[i].moduleId,\n          // Added in QUnit 1.16.0 for internal use by html-reporter,\n          // but no longer used since QUnit 2.7.0.\n          // @deprecated Kept unofficially to be removed in QUnit 3.0.\n          tests: config.modules[i].tests\n        });\n      }\n    }\n\n    // The test run is officially beginning now\n    emit('runStart', runSuite.start(true));\n    runLoggingCallbacks('begin', {\n      totalTests: Test.count,\n      modules: modulesLog\n    }).then(unblockAndAdvanceQueue);\n  }\n  exportQUnit(QUnit);\n\n  (function () {\n    if (!window$1 || !document) {\n      return;\n    }\n    var config = QUnit.config;\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    // Stores fixture HTML for resetting later\n    function storeFixture() {\n      // Avoid overwriting user-defined values\n      // TODO: Change to negative null/undefined check once declared in /src/config.js\n      if (hasOwn.call(config, 'fixture')) {\n        return;\n      }\n      var fixture = document.getElementById('qunit-fixture');\n      if (fixture) {\n        config.fixture = fixture.cloneNode(true);\n      }\n    }\n    QUnit.begin(storeFixture);\n\n    // Resets the fixture DOM element if available.\n    function resetFixture() {\n      if (config.fixture == null) {\n        return;\n      }\n      var fixture = document.getElementById('qunit-fixture');\n      var resetFixtureType = _typeof(config.fixture);\n      if (resetFixtureType === 'string') {\n        // support user defined values for `config.fixture`\n        var newFixture = document.createElement('div');\n        newFixture.setAttribute('id', 'qunit-fixture');\n        newFixture.innerHTML = config.fixture;\n        fixture.parentNode.replaceChild(newFixture, fixture);\n      } else {\n        var clonedFixture = config.fixture.cloneNode(true);\n        fixture.parentNode.replaceChild(clonedFixture, fixture);\n      }\n    }\n    QUnit.testStart(resetFixture);\n  })();\n\n  (function () {\n    // Only interact with URLs via window.location\n    var location = typeof window$1 !== 'undefined' && window$1.location;\n    if (!location) {\n      return;\n    }\n    var urlParams = getUrlParams();\n\n    // TODO: Move to /src/core/ in QUnit 3\n    // TODO: Document this as public API (read-only)\n    QUnit.urlParams = urlParams;\n\n    // TODO: Move to /src/core/config.js in QUnit 3,\n    // in accordance with /docs/api/config.index.md#order\n    QUnit.config.filter = urlParams.filter;\n    // NOTE: Based on readFlatPreconfigNumber from QUnit 3.\n    if (/^[0-9]+$/.test(urlParams.maxDepth)) {\n      QUnit.config.maxDepth = QUnit.dump.maxDepth = +urlParams.maxDepth;\n    }\n    QUnit.config.module = urlParams.module;\n    QUnit.config.moduleId = [].concat(urlParams.moduleId || []);\n    QUnit.config.testId = [].concat(urlParams.testId || []);\n\n    // Test order randomization\n    // Generate a random seed if `?seed` is specified without a value (boolean true),\n    // or when set to the string \"true\".\n    if (urlParams.seed === 'true' || urlParams.seed === true) {\n      // NOTE: This duplicates logic from /src/core/config.js. Consolidated in QUnit 3.\n      QUnit.config.seed = (Math.random().toString(36) + '0000000000').slice(2, 12);\n    } else if (urlParams.seed) {\n      QUnit.config.seed = urlParams.seed;\n    }\n\n    // Add URL-parameter-mapped config values with UI form rendering data\n    QUnit.config.urlConfig.push({\n      id: 'hidepassed',\n      label: 'Hide passed tests',\n      tooltip: 'Only show tests and assertions that fail. Stored as query-strings.'\n    }, {\n      id: 'noglobals',\n      label: 'Check for Globals',\n      tooltip: 'Enabling this will test if any test introduces new properties on the ' + 'global object (`window` in Browsers). Stored as query-strings.'\n    }, {\n      id: 'notrycatch',\n      label: 'No try-catch',\n      tooltip: 'Enabling this will run tests outside of a try-catch block. Makes debugging ' + 'exceptions in IE reasonable. Stored as query-strings.'\n    });\n    QUnit.begin(function () {\n      var urlConfig = QUnit.config.urlConfig;\n      for (var i = 0; i < urlConfig.length; i++) {\n        // Options can be either strings or objects with nonempty \"id\" properties\n        var option = QUnit.config.urlConfig[i];\n        if (typeof option !== 'string') {\n          option = option.id;\n        }\n        if (QUnit.config[option] === undefined) {\n          QUnit.config[option] = urlParams[option];\n        }\n      }\n    });\n    function getUrlParams() {\n      var urlParams = Object.create(null);\n      var params = location.search.slice(1).split('&');\n      var length = params.length;\n      for (var i = 0; i < length; i++) {\n        if (params[i]) {\n          var param = params[i].split('=');\n          var name = decodeQueryParam(param[0]);\n\n          // Allow just a key to turn on a flag, e.g., test.html?noglobals\n          var value = param.length === 1 || decodeQueryParam(param.slice(1).join('='));\n          if (name in urlParams) {\n            urlParams[name] = [].concat(urlParams[name], value);\n          } else {\n            urlParams[name] = value;\n          }\n        }\n      }\n      return urlParams;\n    }\n    function decodeQueryParam(param) {\n      return decodeURIComponent(param.replace(/\\+/g, '%20'));\n    }\n  })();\n\n  var fuzzysort$1 = {exports: {}};\n\n  (function (module) {\n    (function (root, UMD) {\n      if (module.exports) module.exports = UMD();else root.fuzzysort = UMD();\n    })(commonjsGlobal, function UMD() {\n      function fuzzysortNew(instanceOptions) {\n        var fuzzysort = {\n          single: function single(search, target, options) {\n            if (search == 'farzher') return {\n              target: \"farzher was here (^-^*)/\",\n              score: 0,\n              indexes: [0, 1, 2, 3, 4, 5, 6]\n            };\n            if (!search) return null;\n            if (!isObj(search)) search = fuzzysort.getPreparedSearch(search);\n            if (!target) return null;\n            if (!isObj(target)) target = fuzzysort.getPrepared(target);\n            var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n            var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n            return algorithm(search, target, search[0]);\n          },\n          go: function go(search, targets, options) {\n            if (search == 'farzher') return [{\n              target: \"farzher was here (^-^*)/\",\n              score: 0,\n              indexes: [0, 1, 2, 3, 4, 5, 6],\n              obj: targets ? targets[0] : null\n            }];\n            if (!search) return noResults;\n            search = fuzzysort.prepareSearch(search);\n            var searchLowerCode = search[0];\n            var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;\n            var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;\n            var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n            var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n            var resultsLen = 0;\n            var limitedCount = 0;\n            var targetsLen = targets.length;\n\n            // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n\n            // options.keys\n            if (options && options.keys) {\n              var scoreFn = options.scoreFn || defaultScoreFn;\n              var keys = options.keys;\n              var keysLen = keys.length;\n              for (var i = targetsLen - 1; i >= 0; --i) {\n                var obj = targets[i];\n                var objResults = new Array(keysLen);\n                for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\n                  var key = keys[keyI];\n                  var target = getValue(obj, key);\n                  if (!target) {\n                    objResults[keyI] = null;\n                    continue;\n                  }\n                  if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                  objResults[keyI] = algorithm(search, target, searchLowerCode);\n                }\n                objResults.obj = obj; // before scoreFn so scoreFn can use it\n                var score = scoreFn(objResults);\n                if (score === null) continue;\n                if (score < threshold) continue;\n                objResults.score = score;\n                if (resultsLen < limit) {\n                  q.add(objResults);\n                  ++resultsLen;\n                } else {\n                  ++limitedCount;\n                  if (score > q.peek().score) q.replaceTop(objResults);\n                }\n              }\n\n              // options.key\n            } else if (options && options.key) {\n              var key = options.key;\n              for (var i = targetsLen - 1; i >= 0; --i) {\n                var obj = targets[i];\n                var target = getValue(obj, key);\n                if (!target) continue;\n                if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                var result = algorithm(search, target, searchLowerCode);\n                if (result === null) continue;\n                if (result.score < threshold) continue;\n\n                // have to clone result so duplicate targets from different obj can each reference the correct obj\n                result = {\n                  target: result.target,\n                  _targetLowerCodes: null,\n                  _nextBeginningIndexes: null,\n                  score: result.score,\n                  indexes: result.indexes,\n                  obj: obj\n                }; // hidden\n\n                if (resultsLen < limit) {\n                  q.add(result);\n                  ++resultsLen;\n                } else {\n                  ++limitedCount;\n                  if (result.score > q.peek().score) q.replaceTop(result);\n                }\n              }\n\n              // no keys\n            } else {\n              for (var i = targetsLen - 1; i >= 0; --i) {\n                var target = targets[i];\n                if (!target) continue;\n                if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                var result = algorithm(search, target, searchLowerCode);\n                if (result === null) continue;\n                if (result.score < threshold) continue;\n                if (resultsLen < limit) {\n                  q.add(result);\n                  ++resultsLen;\n                } else {\n                  ++limitedCount;\n                  if (result.score > q.peek().score) q.replaceTop(result);\n                }\n              }\n            }\n            if (resultsLen === 0) return noResults;\n            var results = new Array(resultsLen);\n            for (var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll();\n            results.total = resultsLen + limitedCount;\n            return results;\n          },\n          goAsync: function goAsync(search, targets, options) {\n            var canceled = false;\n            var p = new Promise(function (resolve, reject) {\n              if (search == 'farzher') return resolve([{\n                target: \"farzher was here (^-^*)/\",\n                score: 0,\n                indexes: [0, 1, 2, 3, 4, 5, 6],\n                obj: targets ? targets[0] : null\n              }]);\n              if (!search) return resolve(noResults);\n              search = fuzzysort.prepareSearch(search);\n              var searchLowerCode = search[0];\n              var q = fastpriorityqueue();\n              var iCurrent = targets.length - 1;\n              var threshold = options && options.threshold || instanceOptions && instanceOptions.threshold || -9007199254740991;\n              var limit = options && options.limit || instanceOptions && instanceOptions.limit || 9007199254740991;\n              var allowTypo = options && options.allowTypo !== undefined ? options.allowTypo : instanceOptions && instanceOptions.allowTypo !== undefined ? instanceOptions.allowTypo : true;\n              var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;\n              var resultsLen = 0;\n              var limitedCount = 0;\n              function step() {\n                if (canceled) return reject('canceled');\n                var startMs = Date.now();\n\n                // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n\n                // options.keys\n                if (options && options.keys) {\n                  var scoreFn = options.scoreFn || defaultScoreFn;\n                  var keys = options.keys;\n                  var keysLen = keys.length;\n                  for (; iCurrent >= 0; --iCurrent) {\n                    if (iCurrent % 1000 /*itemsPerCheck*/ === 0) {\n                      if (Date.now() - startMs >= 10 /*asyncInterval*/) {\n                        isNode ? setImmediate(step) : setTimeout(step);\n                        return;\n                      }\n                    }\n                    var obj = targets[iCurrent];\n                    var objResults = new Array(keysLen);\n                    for (var keyI = keysLen - 1; keyI >= 0; --keyI) {\n                      var key = keys[keyI];\n                      var target = getValue(obj, key);\n                      if (!target) {\n                        objResults[keyI] = null;\n                        continue;\n                      }\n                      if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                      objResults[keyI] = algorithm(search, target, searchLowerCode);\n                    }\n                    objResults.obj = obj; // before scoreFn so scoreFn can use it\n                    var score = scoreFn(objResults);\n                    if (score === null) continue;\n                    if (score < threshold) continue;\n                    objResults.score = score;\n                    if (resultsLen < limit) {\n                      q.add(objResults);\n                      ++resultsLen;\n                    } else {\n                      ++limitedCount;\n                      if (score > q.peek().score) q.replaceTop(objResults);\n                    }\n                  }\n\n                  // options.key\n                } else if (options && options.key) {\n                  var key = options.key;\n                  for (; iCurrent >= 0; --iCurrent) {\n                    if (iCurrent % 1000 /*itemsPerCheck*/ === 0) {\n                      if (Date.now() - startMs >= 10 /*asyncInterval*/) {\n                        isNode ? setImmediate(step) : setTimeout(step);\n                        return;\n                      }\n                    }\n                    var obj = targets[iCurrent];\n                    var target = getValue(obj, key);\n                    if (!target) continue;\n                    if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                    var result = algorithm(search, target, searchLowerCode);\n                    if (result === null) continue;\n                    if (result.score < threshold) continue;\n\n                    // have to clone result so duplicate targets from different obj can each reference the correct obj\n                    result = {\n                      target: result.target,\n                      _targetLowerCodes: null,\n                      _nextBeginningIndexes: null,\n                      score: result.score,\n                      indexes: result.indexes,\n                      obj: obj\n                    }; // hidden\n\n                    if (resultsLen < limit) {\n                      q.add(result);\n                      ++resultsLen;\n                    } else {\n                      ++limitedCount;\n                      if (result.score > q.peek().score) q.replaceTop(result);\n                    }\n                  }\n\n                  // no keys\n                } else {\n                  for (; iCurrent >= 0; --iCurrent) {\n                    if (iCurrent % 1000 /*itemsPerCheck*/ === 0) {\n                      if (Date.now() - startMs >= 10 /*asyncInterval*/) {\n                        isNode ? setImmediate(step) : setTimeout(step);\n                        return;\n                      }\n                    }\n                    var target = targets[iCurrent];\n                    if (!target) continue;\n                    if (!isObj(target)) target = fuzzysort.getPrepared(target);\n                    var result = algorithm(search, target, searchLowerCode);\n                    if (result === null) continue;\n                    if (result.score < threshold) continue;\n                    if (resultsLen < limit) {\n                      q.add(result);\n                      ++resultsLen;\n                    } else {\n                      ++limitedCount;\n                      if (result.score > q.peek().score) q.replaceTop(result);\n                    }\n                  }\n                }\n                if (resultsLen === 0) return resolve(noResults);\n                var results = new Array(resultsLen);\n                for (var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll();\n                results.total = resultsLen + limitedCount;\n                resolve(results);\n              }\n              isNode ? setImmediate(step) : step(); //setTimeout here is too slow\n            });\n            p.cancel = function () {\n              canceled = true;\n            };\n            return p;\n          },\n          highlight: function highlight(result, hOpen, hClose) {\n            if (typeof hOpen == 'function') return fuzzysort.highlightCallback(result, hOpen);\n            if (result === null) return null;\n            if (hOpen === undefined) hOpen = '<b>';\n            if (hClose === undefined) hClose = '</b>';\n            var highlighted = '';\n            var matchesIndex = 0;\n            var opened = false;\n            var target = result.target;\n            var targetLen = target.length;\n            var matchesBest = result.indexes;\n            for (var i = 0; i < targetLen; ++i) {\n              var char = target[i];\n              if (matchesBest[matchesIndex] === i) {\n                ++matchesIndex;\n                if (!opened) {\n                  opened = true;\n                  highlighted += hOpen;\n                }\n                if (matchesIndex === matchesBest.length) {\n                  highlighted += char + hClose + target.substr(i + 1);\n                  break;\n                }\n              } else {\n                if (opened) {\n                  opened = false;\n                  highlighted += hClose;\n                }\n              }\n              highlighted += char;\n            }\n            return highlighted;\n          },\n          highlightCallback: function highlightCallback(result, cb) {\n            if (result === null) return null;\n            var target = result.target;\n            var targetLen = target.length;\n            var indexes = result.indexes;\n            var highlighted = '';\n            var matchI = 0;\n            var indexesI = 0;\n            var opened = false;\n            var result = [];\n            for (var i = 0; i < targetLen; ++i) {\n              var char = target[i];\n              if (indexes[indexesI] === i) {\n                ++indexesI;\n                if (!opened) {\n                  opened = true;\n                  result.push(highlighted);\n                  highlighted = '';\n                }\n                if (indexesI === indexes.length) {\n                  highlighted += char;\n                  result.push(cb(highlighted, matchI++));\n                  highlighted = '';\n                  result.push(target.substr(i + 1));\n                  break;\n                }\n              } else {\n                if (opened) {\n                  opened = false;\n                  result.push(cb(highlighted, matchI++));\n                  highlighted = '';\n                }\n              }\n              highlighted += char;\n            }\n            return result;\n          },\n          prepare: function prepare(target) {\n            if (!target) return {\n              target: '',\n              _targetLowerCodes: [0 /*this 0 doesn't make sense. here because an empty array causes the algorithm to deoptimize and run 50% slower!*/],\n              _nextBeginningIndexes: null,\n              score: null,\n              indexes: null,\n              obj: null\n            }; // hidden\n            return {\n              target: target,\n              _targetLowerCodes: fuzzysort.prepareLowerCodes(target),\n              _nextBeginningIndexes: null,\n              score: null,\n              indexes: null,\n              obj: null\n            }; // hidden\n          },\n          prepareSlow: function prepareSlow(target) {\n            if (!target) return {\n              target: '',\n              _targetLowerCodes: [0 /*this 0 doesn't make sense. here because an empty array causes the algorithm to deoptimize and run 50% slower!*/],\n              _nextBeginningIndexes: null,\n              score: null,\n              indexes: null,\n              obj: null\n            }; // hidden\n            return {\n              target: target,\n              _targetLowerCodes: fuzzysort.prepareLowerCodes(target),\n              _nextBeginningIndexes: fuzzysort.prepareNextBeginningIndexes(target),\n              score: null,\n              indexes: null,\n              obj: null\n            }; // hidden\n          },\n          prepareSearch: function prepareSearch(search) {\n            if (!search) search = '';\n            return fuzzysort.prepareLowerCodes(search);\n          },\n          // Below this point is only internal code\n          // Below this point is only internal code\n          // Below this point is only internal code\n          // Below this point is only internal code\n\n          getPrepared: function getPrepared(target) {\n            if (target.length > 999) return fuzzysort.prepare(target); // don't cache huge targets\n            var targetPrepared = preparedCache.get(target);\n            if (targetPrepared !== undefined) return targetPrepared;\n            targetPrepared = fuzzysort.prepare(target);\n            preparedCache.set(target, targetPrepared);\n            return targetPrepared;\n          },\n          getPreparedSearch: function getPreparedSearch(search) {\n            if (search.length > 999) return fuzzysort.prepareSearch(search); // don't cache huge searches\n            var searchPrepared = preparedSearchCache.get(search);\n            if (searchPrepared !== undefined) return searchPrepared;\n            searchPrepared = fuzzysort.prepareSearch(search);\n            preparedSearchCache.set(search, searchPrepared);\n            return searchPrepared;\n          },\n          algorithm: function algorithm(searchLowerCodes, prepared, searchLowerCode) {\n            var targetLowerCodes = prepared._targetLowerCodes;\n            var searchLen = searchLowerCodes.length;\n            var targetLen = targetLowerCodes.length;\n            var searchI = 0; // where we at\n            var targetI = 0; // where you at\n            var typoSimpleI = 0;\n            var matchesSimpleLen = 0;\n\n            // very basic fuzzy match; to remove non-matching targets ASAP!\n            // walk through target. find sequential matches.\n            // if all chars aren't found then exit\n            for (;;) {\n              var isMatch = searchLowerCode === targetLowerCodes[targetI];\n              if (isMatch) {\n                matchesSimple[matchesSimpleLen++] = targetI;\n                ++searchI;\n                if (searchI === searchLen) break;\n                searchLowerCode = searchLowerCodes[typoSimpleI === 0 ? searchI : typoSimpleI === searchI ? searchI + 1 : typoSimpleI === searchI - 1 ? searchI - 1 : searchI];\n              }\n              ++targetI;\n              if (targetI >= targetLen) {\n                // Failed to find searchI\n                // Check for typo or exit\n                // we go as far as possible before trying to transpose\n                // then we transpose backwards until we reach the beginning\n                for (;;) {\n                  if (searchI <= 1) return null; // not allowed to transpose first char\n                  if (typoSimpleI === 0) {\n                    // we haven't tried to transpose yet\n                    --searchI;\n                    var searchLowerCodeNew = searchLowerCodes[searchI];\n                    if (searchLowerCode === searchLowerCodeNew) continue; // doesn't make sense to transpose a repeat char\n                    typoSimpleI = searchI;\n                  } else {\n                    if (typoSimpleI === 1) return null; // reached the end of the line for transposing\n                    --typoSimpleI;\n                    searchI = typoSimpleI;\n                    searchLowerCode = searchLowerCodes[searchI + 1];\n                    var searchLowerCodeNew = searchLowerCodes[searchI];\n                    if (searchLowerCode === searchLowerCodeNew) continue; // doesn't make sense to transpose a repeat char\n                  }\n                  matchesSimpleLen = searchI;\n                  targetI = matchesSimple[matchesSimpleLen - 1] + 1;\n                  break;\n                }\n              }\n            }\n            var searchI = 0;\n            var typoStrictI = 0;\n            var successStrict = false;\n            var matchesStrictLen = 0;\n            var nextBeginningIndexes = prepared._nextBeginningIndexes;\n            if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);\n            var firstPossibleI = targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1];\n\n            // Our target string successfully matched all characters in sequence!\n            // Let's try a more advanced and strict test to improve the score\n            // only count it as a match if it's consecutive or a beginning character!\n            if (targetI !== targetLen) for (;;) {\n              if (targetI >= targetLen) {\n                // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n                if (searchI <= 0) {\n                  // We failed to push chars forward for a better match\n                  // transpose, starting from the beginning\n                  ++typoStrictI;\n                  if (typoStrictI > searchLen - 2) break;\n                  if (searchLowerCodes[typoStrictI] === searchLowerCodes[typoStrictI + 1]) continue; // doesn't make sense to transpose a repeat char\n                  targetI = firstPossibleI;\n                  continue;\n                }\n                --searchI;\n                var lastMatch = matchesStrict[--matchesStrictLen];\n                targetI = nextBeginningIndexes[lastMatch];\n              } else {\n                var isMatch = searchLowerCodes[typoStrictI === 0 ? searchI : typoStrictI === searchI ? searchI + 1 : typoStrictI === searchI - 1 ? searchI - 1 : searchI] === targetLowerCodes[targetI];\n                if (isMatch) {\n                  matchesStrict[matchesStrictLen++] = targetI;\n                  ++searchI;\n                  if (searchI === searchLen) {\n                    successStrict = true;\n                    break;\n                  }\n                  ++targetI;\n                } else {\n                  targetI = nextBeginningIndexes[targetI];\n                }\n              }\n            }\n            {\n              // tally up the score & keep track of matches for highlighting later\n              if (successStrict) {\n                var matchesBest = matchesStrict;\n                var matchesBestLen = matchesStrictLen;\n              } else {\n                var matchesBest = matchesSimple;\n                var matchesBestLen = matchesSimpleLen;\n              }\n              var score = 0;\n              var lastTargetI = -1;\n              for (var i = 0; i < searchLen; ++i) {\n                var targetI = matchesBest[i];\n                // score only goes down if they're not consecutive\n                if (lastTargetI !== targetI - 1) score -= targetI;\n                lastTargetI = targetI;\n              }\n              if (!successStrict) {\n                score *= 1000;\n                if (typoSimpleI !== 0) score += -20; /*typoPenalty*/\n              } else {\n                if (typoStrictI !== 0) score += -20; /*typoPenalty*/\n              }\n              score -= targetLen - searchLen;\n              prepared.score = score;\n              prepared.indexes = new Array(matchesBestLen);\n              for (var i = matchesBestLen - 1; i >= 0; --i) prepared.indexes[i] = matchesBest[i];\n              return prepared;\n            }\n          },\n          algorithmNoTypo: function algorithmNoTypo(searchLowerCodes, prepared, searchLowerCode) {\n            var targetLowerCodes = prepared._targetLowerCodes;\n            var searchLen = searchLowerCodes.length;\n            var targetLen = targetLowerCodes.length;\n            var searchI = 0; // where we at\n            var targetI = 0; // where you at\n            var matchesSimpleLen = 0;\n\n            // very basic fuzzy match; to remove non-matching targets ASAP!\n            // walk through target. find sequential matches.\n            // if all chars aren't found then exit\n            for (;;) {\n              var isMatch = searchLowerCode === targetLowerCodes[targetI];\n              if (isMatch) {\n                matchesSimple[matchesSimpleLen++] = targetI;\n                ++searchI;\n                if (searchI === searchLen) break;\n                searchLowerCode = searchLowerCodes[searchI];\n              }\n              ++targetI;\n              if (targetI >= targetLen) return null; // Failed to find searchI\n            }\n            var searchI = 0;\n            var successStrict = false;\n            var matchesStrictLen = 0;\n            var nextBeginningIndexes = prepared._nextBeginningIndexes;\n            if (nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);\n            targetI = matchesSimple[0] === 0 ? 0 : nextBeginningIndexes[matchesSimple[0] - 1];\n\n            // Our target string successfully matched all characters in sequence!\n            // Let's try a more advanced and strict test to improve the score\n            // only count it as a match if it's consecutive or a beginning character!\n            if (targetI !== targetLen) for (;;) {\n              if (targetI >= targetLen) {\n                // We failed to find a good spot for this search char, go back to the previous search char and force it forward\n                if (searchI <= 0) break; // We failed to push chars forward for a better match\n\n                --searchI;\n                var lastMatch = matchesStrict[--matchesStrictLen];\n                targetI = nextBeginningIndexes[lastMatch];\n              } else {\n                var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI];\n                if (isMatch) {\n                  matchesStrict[matchesStrictLen++] = targetI;\n                  ++searchI;\n                  if (searchI === searchLen) {\n                    successStrict = true;\n                    break;\n                  }\n                  ++targetI;\n                } else {\n                  targetI = nextBeginningIndexes[targetI];\n                }\n              }\n            }\n            {\n              // tally up the score & keep track of matches for highlighting later\n              if (successStrict) {\n                var matchesBest = matchesStrict;\n                var matchesBestLen = matchesStrictLen;\n              } else {\n                var matchesBest = matchesSimple;\n                var matchesBestLen = matchesSimpleLen;\n              }\n              var score = 0;\n              var lastTargetI = -1;\n              for (var i = 0; i < searchLen; ++i) {\n                var targetI = matchesBest[i];\n                // score only goes down if they're not consecutive\n                if (lastTargetI !== targetI - 1) score -= targetI;\n                lastTargetI = targetI;\n              }\n              if (!successStrict) score *= 1000;\n              score -= targetLen - searchLen;\n              prepared.score = score;\n              prepared.indexes = new Array(matchesBestLen);\n              for (var i = matchesBestLen - 1; i >= 0; --i) prepared.indexes[i] = matchesBest[i];\n              return prepared;\n            }\n          },\n          prepareLowerCodes: function prepareLowerCodes(str) {\n            var strLen = str.length;\n            var lowerCodes = []; // new Array(strLen)    sparse array is too slow\n            var lower = str.toLowerCase();\n            for (var i = 0; i < strLen; ++i) lowerCodes[i] = lower.charCodeAt(i);\n            return lowerCodes;\n          },\n          prepareBeginningIndexes: function prepareBeginningIndexes(target) {\n            var targetLen = target.length;\n            var beginningIndexes = [];\n            var beginningIndexesLen = 0;\n            var wasUpper = false;\n            var wasAlphanum = false;\n            for (var i = 0; i < targetLen; ++i) {\n              var targetCode = target.charCodeAt(i);\n              var isUpper = targetCode >= 65 && targetCode <= 90;\n              var isAlphanum = isUpper || targetCode >= 97 && targetCode <= 122 || targetCode >= 48 && targetCode <= 57;\n              var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum;\n              wasUpper = isUpper;\n              wasAlphanum = isAlphanum;\n              if (isBeginning) beginningIndexes[beginningIndexesLen++] = i;\n            }\n            return beginningIndexes;\n          },\n          prepareNextBeginningIndexes: function prepareNextBeginningIndexes(target) {\n            var targetLen = target.length;\n            var beginningIndexes = fuzzysort.prepareBeginningIndexes(target);\n            var nextBeginningIndexes = []; // new Array(targetLen)     sparse array is too slow\n            var lastIsBeginning = beginningIndexes[0];\n            var lastIsBeginningI = 0;\n            for (var i = 0; i < targetLen; ++i) {\n              if (lastIsBeginning > i) {\n                nextBeginningIndexes[i] = lastIsBeginning;\n              } else {\n                lastIsBeginning = beginningIndexes[++lastIsBeginningI];\n                nextBeginningIndexes[i] = lastIsBeginning === undefined ? targetLen : lastIsBeginning;\n              }\n            }\n            return nextBeginningIndexes;\n          },\n          cleanup: cleanup,\n          new: fuzzysortNew\n        };\n        return fuzzysort;\n      } // fuzzysortNew\n\n      // This stuff is outside fuzzysortNew, because it's shared with instances of fuzzysort.new()\n      var isNode = typeof commonjsRequire !== 'undefined' && typeof window === 'undefined';\n      var MyMap = typeof Map === 'function' ? Map : function () {\n        var s = Object.create(null);\n        this.get = function (k) {\n          return s[k];\n        };\n        this.set = function (k, val) {\n          s[k] = val;\n          return this;\n        };\n        this.clear = function () {\n          s = Object.create(null);\n        };\n      };\n      var preparedCache = new MyMap();\n      var preparedSearchCache = new MyMap();\n      var noResults = [];\n      noResults.total = 0;\n      var matchesSimple = [];\n      var matchesStrict = [];\n      function cleanup() {\n        preparedCache.clear();\n        preparedSearchCache.clear();\n        matchesSimple = [];\n        matchesStrict = [];\n      }\n      function defaultScoreFn(a) {\n        var max = -9007199254740991;\n        for (var i = a.length - 1; i >= 0; --i) {\n          var result = a[i];\n          if (result === null) continue;\n          var score = result.score;\n          if (score > max) max = score;\n        }\n        if (max === -9007199254740991) return null;\n        return max;\n      }\n\n      // prop = 'key'              2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\n      // prop = 'key1.key2'        10ms\n      // prop = ['key1', 'key2']   27ms\n      function getValue(obj, prop) {\n        var tmp = obj[prop];\n        if (tmp !== undefined) return tmp;\n        var segs = prop;\n        if (!Array.isArray(prop)) segs = prop.split('.');\n        var len = segs.length;\n        var i = -1;\n        while (obj && ++i < len) obj = obj[segs[i]];\n        return obj;\n      }\n      function isObj(x) {\n        return _typeof(x) === 'object';\n      } // faster as a function\n\n      // Hacked version of https://github.com/lemire/FastPriorityQueue.js\n      var fastpriorityqueue = function fastpriorityqueue() {\n        var r = [],\n          o = 0,\n          e = {};\n        function n() {\n          for (var e = 0, n = r[e], c = 1; c < o;) {\n            var f = c + 1;\n            e = c, f < o && r[f].score < r[c].score && (e = f), r[e - 1 >> 1] = r[e], c = 1 + (e << 1);\n          }\n          for (var a = e - 1 >> 1; e > 0 && n.score < r[a].score; a = (e = a) - 1 >> 1) r[e] = r[a];\n          r[e] = n;\n        }\n        return e.add = function (e) {\n          var n = o;\n          r[o++] = e;\n          for (var c = n - 1 >> 1; n > 0 && e.score < r[c].score; c = (n = c) - 1 >> 1) r[n] = r[c];\n          r[n] = e;\n        }, e.poll = function () {\n          if (0 !== o) {\n            var e = r[0];\n            return r[0] = r[--o], n(), e;\n          }\n        }, e.peek = function (e) {\n          if (0 !== o) return r[0];\n        }, e.replaceTop = function (o) {\n          r[0] = o, n();\n        }, e;\n      };\n      var q = fastpriorityqueue(); // reuse this, except for async, it needs to make its own\n\n      return fuzzysortNew();\n    }); // UMD\n\n    // TODO: (performance) wasm version!?\n    // TODO: (performance) threads?\n    // TODO: (performance) avoid cache misses\n    // TODO: (performance) preparedCache is a memory leak\n    // TODO: (like sublime) backslash === forwardslash\n    // TODO: (like sublime) spaces: \"a b\" should do 2 searches 1 for a and 1 for b\n    // TODO: (scoring) garbage in targets that allows most searches to strict match need a penality\n    // TODO: (performance) idk if allowTypo is optimized\n  })(fuzzysort$1);\n  var fuzzysort = fuzzysort$1.exports;\n\n  var stats = {\n    failedTests: [],\n    defined: 0,\n    completed: 0\n  };\n  (function () {\n    // Don't load the HTML Reporter on non-browser environments\n    if (!window$1 || !document) {\n      return;\n    }\n    QUnit.reporters.perf.init(QUnit);\n    var config = QUnit.config;\n    var hiddenTests = [];\n    var collapseNext = false;\n    var hasOwn = Object.prototype.hasOwnProperty;\n    var unfilteredUrl = setUrl({\n      filter: undefined,\n      module: undefined,\n      moduleId: undefined,\n      testId: undefined\n    });\n    var dropdownData = null;\n    function trim(string) {\n      if (typeof string.trim === 'function') {\n        return string.trim();\n      } else {\n        return string.replace(/^\\s+|\\s+$/g, '');\n      }\n    }\n    function addEvent(elem, type, fn) {\n      elem.addEventListener(type, fn, false);\n    }\n    function removeEvent(elem, type, fn) {\n      elem.removeEventListener(type, fn, false);\n    }\n    function addEvents(elems, type, fn) {\n      var i = elems.length;\n      while (i--) {\n        addEvent(elems[i], type, fn);\n      }\n    }\n    function hasClass(elem, name) {\n      return (' ' + elem.className + ' ').indexOf(' ' + name + ' ') >= 0;\n    }\n    function addClass(elem, name) {\n      if (!hasClass(elem, name)) {\n        elem.className += (elem.className ? ' ' : '') + name;\n      }\n    }\n    function toggleClass(elem, name, force) {\n      if (force || typeof force === 'undefined' && !hasClass(elem, name)) {\n        addClass(elem, name);\n      } else {\n        removeClass(elem, name);\n      }\n    }\n    function removeClass(elem, name) {\n      var set = ' ' + elem.className + ' ';\n\n      // Class name may appear multiple times\n      while (set.indexOf(' ' + name + ' ') >= 0) {\n        set = set.replace(' ' + name + ' ', ' ');\n      }\n\n      // Trim for prettiness\n      elem.className = trim(set);\n    }\n    function id(name) {\n      return document.getElementById && document.getElementById(name);\n    }\n    function abortTests() {\n      var abortButton = id('qunit-abort-tests-button');\n      if (abortButton) {\n        abortButton.disabled = true;\n        abortButton.innerHTML = 'Aborting...';\n      }\n      QUnit.config.queue.length = 0;\n      return false;\n    }\n    function interceptNavigation(ev) {\n      // Trim potential accidental whitespace so that QUnit doesn't throw an error about no tests matching the filter.\n      var filterInputElem = id('qunit-filter-input');\n      filterInputElem.value = trim(filterInputElem.value);\n      applyUrlParams();\n      if (ev && ev.preventDefault) {\n        ev.preventDefault();\n      }\n      return false;\n    }\n    function getUrlConfigHtml() {\n      var selection = false;\n      var urlConfig = config.urlConfig;\n      var urlConfigHtml = '';\n      for (var i = 0; i < urlConfig.length; i++) {\n        // Options can be either strings or objects with nonempty \"id\" properties\n        var val = config.urlConfig[i];\n        if (typeof val === 'string') {\n          val = {\n            id: val,\n            label: val\n          };\n        }\n        var escaped = escapeText(val.id);\n        var escapedTooltip = escapeText(val.tooltip);\n        if (!val.value || typeof val.value === 'string') {\n          urlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped + \"' title='\" + escapedTooltip + \"'><input id='qunit-urlconfig-\" + escaped + \"' name='\" + escaped + \"' type='checkbox'\" + (val.value ? \" value='\" + escapeText(val.value) + \"'\" : '') + (config[val.id] ? \" checked='checked'\" : '') + \" title='\" + escapedTooltip + \"' />\" + escapeText(val.label) + '</label>';\n        } else {\n          urlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped + \"' title='\" + escapedTooltip + \"'>\" + escapeText(val.label) + \": <select id='qunit-urlconfig-\" + escaped + \"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";\n          if (Array.isArray(val.value)) {\n            for (var j = 0; j < val.value.length; j++) {\n              escaped = escapeText(val.value[j]);\n              urlConfigHtml += \"<option value='\" + escaped + \"'\" + (config[val.id] === val.value[j] ? (selection = true) && \" selected='selected'\" : '') + '>' + escaped + '</option>';\n            }\n          } else {\n            for (var _j in val.value) {\n              if (hasOwn.call(val.value, _j)) {\n                urlConfigHtml += \"<option value='\" + escapeText(_j) + \"'\" + (config[val.id] === _j ? (selection = true) && \" selected='selected'\" : '') + '>' + escapeText(val.value[_j]) + '</option>';\n              }\n            }\n          }\n          if (config[val.id] && !selection) {\n            escaped = escapeText(config[val.id]);\n            urlConfigHtml += \"<option value='\" + escaped + \"' selected='selected' disabled='disabled'>\" + escaped + '</option>';\n          }\n          urlConfigHtml += '</select></label>';\n        }\n      }\n      return urlConfigHtml;\n    }\n\n    // Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.\n    // Updates the URL with the new state of `config.urlConfig` values.\n    function toolbarChanged() {\n      var field = this;\n      var params = {};\n\n      // Detect if field is a select menu or a checkbox\n      var value;\n      if ('selectedIndex' in field) {\n        value = field.options[field.selectedIndex].value || undefined;\n      } else {\n        value = field.checked ? field.defaultValue || true : undefined;\n      }\n      params[field.name] = value;\n      var updatedUrl = setUrl(params);\n\n      // Check if we can apply the change without a page refresh\n      if (field.name === 'hidepassed' && 'replaceState' in window$1.history) {\n        QUnit.urlParams[field.name] = value;\n        config[field.name] = value || false;\n        var tests = id('qunit-tests');\n        if (tests) {\n          if (field.checked) {\n            var length = tests.children.length;\n            var children = tests.children;\n            for (var i = 0; i < length; i++) {\n              var test = children[i];\n              var className = test ? test.className : '';\n              var classNameHasPass = className.indexOf('pass') > -1;\n              var classNameHasSkipped = className.indexOf('skipped') > -1;\n              if (classNameHasPass || classNameHasSkipped) {\n                hiddenTests.push(test);\n              }\n            }\n\n            // Optimization: Avoid `for-of` iterator overhead.\n            for (var _i = 0; _i < hiddenTests.length; _i++) {\n              tests.removeChild(hiddenTests[_i]);\n            }\n          } else {\n            // Optimization: Avoid `while (arr.length) arr.shift()` which would mutate the array many times.\n            // As of Chrome 126, HTMLElement.append(...hiddenTests) is still slower than\n            // calling appendChild in a loop.\n            for (var _i2 = 0; _i2 < hiddenTests.length; _i2++) {\n              tests.appendChild(hiddenTests[_i2]);\n            }\n            hiddenTests.length = 0;\n          }\n        }\n        window$1.history.replaceState(null, '', updatedUrl);\n      } else {\n        window$1.location = updatedUrl;\n      }\n    }\n    function setUrl(params) {\n      var querystring = '?';\n      var location = window$1.location;\n      params = extend(extend({}, QUnit.urlParams), params);\n      for (var key in params) {\n        // Skip inherited or undefined properties\n        if (hasOwn.call(params, key) && params[key] !== undefined) {\n          // Output a parameter for each value of this key\n          // (but usually just one)\n          var arrValue = [].concat(params[key]);\n          for (var i = 0; i < arrValue.length; i++) {\n            querystring += encodeURIComponent(key);\n            if (arrValue[i] !== true) {\n              querystring += '=' + encodeURIComponent(arrValue[i]);\n            }\n            querystring += '&';\n          }\n        }\n      }\n      return location.protocol + '//' + location.host + location.pathname + querystring.slice(0, -1);\n    }\n    function applyUrlParams() {\n      var filter = id('qunit-filter-input').value;\n      window$1.location = setUrl({\n        filter: filter === '' ? undefined : filter,\n        moduleId: _toConsumableArray(dropdownData.selectedMap.keys()),\n        // Remove module and testId filter\n        module: undefined,\n        testId: undefined\n      });\n    }\n    function toolbarUrlConfigContainer() {\n      var urlConfigContainer = document.createElement('span');\n      urlConfigContainer.innerHTML = getUrlConfigHtml();\n      addClass(urlConfigContainer, 'qunit-url-config');\n      addEvents(urlConfigContainer.getElementsByTagName('input'), 'change', toolbarChanged);\n      addEvents(urlConfigContainer.getElementsByTagName('select'), 'change', toolbarChanged);\n      return urlConfigContainer;\n    }\n    function abortTestsButton() {\n      var button = document.createElement('button');\n      button.id = 'qunit-abort-tests-button';\n      button.innerHTML = 'Abort';\n      addEvent(button, 'click', abortTests);\n      return button;\n    }\n    function toolbarLooseFilter() {\n      var filter = document.createElement('form');\n      var label = document.createElement('label');\n      var input = document.createElement('input');\n      var button = document.createElement('button');\n      addClass(filter, 'qunit-filter');\n      label.innerHTML = 'Filter: ';\n      input.type = 'text';\n      input.value = config.filter || '';\n      input.name = 'filter';\n      input.id = 'qunit-filter-input';\n      button.innerHTML = 'Go';\n      label.appendChild(input);\n      filter.appendChild(label);\n      filter.appendChild(document.createTextNode(' '));\n      filter.appendChild(button);\n      addEvent(filter, 'submit', interceptNavigation);\n      return filter;\n    }\n    function createModuleListItem(moduleId, name, checked) {\n      return '<li><label class=\"clickable' + (checked ? ' checked' : '') + '\"><input type=\"checkbox\" ' + 'value=\"' + escapeText(moduleId) + '\"' + (checked ? ' checked=\"checked\"' : '') + ' />' + escapeText(name) + '</label></li>';\n    }\n\n    /**\n     * @param {Array} Results from fuzzysort\n     * @return {string} HTML\n     */\n    function moduleListHtml(results) {\n      var html = '';\n\n      // Hoist the already selected items, and show them always\n      // even if not matched by the current search.\n      dropdownData.selectedMap.forEach(function (name, moduleId) {\n        html += createModuleListItem(moduleId, name, true);\n      });\n      for (var i = 0; i < results.length; i++) {\n        var mod = results[i].obj;\n        if (!dropdownData.selectedMap.has(mod.moduleId)) {\n          html += createModuleListItem(mod.moduleId, mod.name, false);\n        }\n      }\n      return html;\n    }\n    function toolbarModuleFilter(beginDetails) {\n      var initialSelected = null;\n      dropdownData = {\n        options: beginDetails.modules.slice(),\n        selectedMap: new StringMap(),\n        isDirty: function isDirty() {\n          return _toConsumableArray(dropdownData.selectedMap.keys()).sort().join(',') !== _toConsumableArray(initialSelected.keys()).sort().join(',');\n        }\n      };\n      if (config.moduleId.length) {\n        // The module dropdown is seeded with the runtime configuration of the last run.\n        //\n        // We don't reference `config.moduleId` directly after this and keep our own\n        // copy because:\n        // 1. This naturally filters out unknown moduleIds.\n        // 2. Gives us a place to manage and remember unsubmitted checkbox changes.\n        // 3. Gives us an efficient way to map a selected moduleId to module name\n        //    during rendering.\n        for (var i = 0; i < beginDetails.modules.length; i++) {\n          var mod = beginDetails.modules[i];\n          if (config.moduleId.indexOf(mod.moduleId) !== -1) {\n            dropdownData.selectedMap.set(mod.moduleId, mod.name);\n          }\n        }\n      }\n      initialSelected = new StringMap(dropdownData.selectedMap);\n      var moduleSearch = document.createElement('input');\n      moduleSearch.id = 'qunit-modulefilter-search';\n      moduleSearch.autocomplete = 'off';\n      addEvent(moduleSearch, 'input', searchInput);\n      addEvent(moduleSearch, 'input', searchFocus);\n      addEvent(moduleSearch, 'focus', searchFocus);\n      addEvent(moduleSearch, 'click', searchFocus);\n      var label = document.createElement('label');\n      label.htmlFor = 'qunit-modulefilter-search';\n      label.textContent = 'Module:';\n      var searchContainer = document.createElement('span');\n      searchContainer.id = 'qunit-modulefilter-search-container';\n      searchContainer.appendChild(moduleSearch);\n      var applyButton = document.createElement('button');\n      applyButton.textContent = 'Apply';\n      applyButton.title = 'Re-run the selected test modules';\n      addEvent(applyButton, 'click', applyUrlParams);\n      var resetButton = document.createElement('button');\n      resetButton.textContent = 'Reset';\n      resetButton.type = 'reset';\n      resetButton.title = 'Restore the previous module selection';\n      var clearButton = document.createElement('button');\n      clearButton.textContent = 'Select none';\n      clearButton.type = 'button';\n      clearButton.title = 'Clear the current module selection';\n      addEvent(clearButton, 'click', function () {\n        dropdownData.selectedMap.clear();\n        selectionChange();\n        searchInput();\n      });\n      var actions = document.createElement('span');\n      actions.id = 'qunit-modulefilter-actions';\n      actions.appendChild(applyButton);\n      actions.appendChild(resetButton);\n      if (initialSelected.size) {\n        // Only show clear button if functionally different from reset\n        actions.appendChild(clearButton);\n      }\n      var dropDownList = document.createElement('ul');\n      dropDownList.id = 'qunit-modulefilter-dropdown-list';\n      var dropDown = document.createElement('div');\n      dropDown.id = 'qunit-modulefilter-dropdown';\n      dropDown.style.display = 'none';\n      dropDown.appendChild(actions);\n      dropDown.appendChild(dropDownList);\n      addEvent(dropDown, 'change', selectionChange);\n      searchContainer.appendChild(dropDown);\n      // Set initial moduleSearch.placeholder and clearButton/resetButton.\n      selectionChange();\n      var moduleFilter = document.createElement('form');\n      moduleFilter.id = 'qunit-modulefilter';\n      moduleFilter.appendChild(label);\n      moduleFilter.appendChild(document.createTextNode(' '));\n      moduleFilter.appendChild(searchContainer);\n      addEvent(moduleFilter, 'submit', interceptNavigation);\n      addEvent(moduleFilter, 'reset', function () {\n        dropdownData.selectedMap = new StringMap(initialSelected);\n        // Set moduleSearch.placeholder and reflect non-dirty state\n        selectionChange();\n        searchInput();\n      });\n\n      // Enables show/hide for the dropdown\n      function searchFocus() {\n        if (dropDown.style.display !== 'none') {\n          return;\n        }\n\n        // Optimization: Defer rendering options until focussed.\n        // https://github.com/qunitjs/qunit/issues/1664\n        searchInput();\n        dropDown.style.display = 'block';\n\n        // Hide on Escape keydown or on click outside the container\n        addEvent(document, 'click', hideHandler);\n        addEvent(document, 'keydown', hideHandler);\n        function hideHandler(e) {\n          var inContainer = moduleFilter.contains(e.target);\n          if (e.keyCode === 27 || !inContainer) {\n            if (e.keyCode === 27 && inContainer) {\n              moduleSearch.focus();\n            }\n            dropDown.style.display = 'none';\n            removeEvent(document, 'click', hideHandler);\n            removeEvent(document, 'keydown', hideHandler);\n            moduleSearch.value = '';\n            searchInput();\n          }\n        }\n      }\n\n      /**\n       * @param {string} searchText\n       * @return {string} HTML\n       */\n      function filterModules(searchText) {\n        var results;\n        if (searchText === '') {\n          // Improve on-boarding experience by having an immediate display of\n          // module names, indicating how the interface works. This also makes\n          // for a quicker interaction in the common case of small projects.\n          // Don't mandate typing just to get the menu.\n          results = dropdownData.options.slice(0, 20).map(function (obj) {\n            // Fake empty results. https://github.com/farzher/fuzzysort/issues/41\n            return {\n              obj: obj\n            };\n          });\n        } else {\n          results = fuzzysort.go(searchText, dropdownData.options, {\n            limit: 20,\n            key: 'name',\n            allowTypo: true\n          });\n        }\n        return moduleListHtml(results);\n      }\n\n      // Processes module search box input\n      var searchInputTimeout;\n      function searchInput() {\n        // Use a debounce with a ~0ms timeout. This is effectively instantaneous,\n        // but is better than undebounced because it avoids an ever-growing\n        // backlog of unprocessed now-outdated input events if fuzzysearch or\n        // drodown DOM is slow (e.g. very large test suite).\n        window$1.clearTimeout(searchInputTimeout);\n        searchInputTimeout = window$1.setTimeout(function () {\n          dropDownList.innerHTML = filterModules(moduleSearch.value);\n        });\n      }\n\n      // Processes checkbox change, or a generic render (initial render, or after reset event)\n      // Avoid any dropdown rendering here as this is used by toolbarModuleFilter()\n      // during the initial render, which should not delay test execution.\n      function selectionChange(evt) {\n        var checkbox = evt && evt.target || null;\n        if (checkbox) {\n          // Update internal state\n          if (checkbox.checked) {\n            dropdownData.selectedMap.set(checkbox.value, checkbox.parentNode.textContent);\n          } else {\n            dropdownData.selectedMap.delete(checkbox.value);\n          }\n\n          // Update UI state\n          toggleClass(checkbox.parentNode, 'checked', checkbox.checked);\n        }\n        var textForm = dropdownData.selectedMap.size ? dropdownData.selectedMap.size + ' ' + (dropdownData.selectedMap.size === 1 ? 'module' : 'modules') : 'All modules';\n        moduleSearch.placeholder = textForm;\n        moduleSearch.title = 'Type to search through and reduce the list.';\n        resetButton.disabled = !dropdownData.isDirty();\n        clearButton.style.display = dropdownData.selectedMap.size ? '' : 'none';\n      }\n      return moduleFilter;\n    }\n    function appendToolbar(beginDetails) {\n      var toolbar = id('qunit-testrunner-toolbar');\n      if (toolbar) {\n        toolbar.appendChild(toolbarUrlConfigContainer());\n        var toolbarFilters = document.createElement('span');\n        toolbarFilters.id = 'qunit-toolbar-filters';\n        toolbarFilters.appendChild(toolbarLooseFilter());\n        toolbarFilters.appendChild(toolbarModuleFilter(beginDetails));\n        var clearfix = document.createElement('div');\n        clearfix.className = 'clearfix';\n        toolbar.appendChild(toolbarFilters);\n        toolbar.appendChild(clearfix);\n      }\n    }\n    function appendHeader() {\n      var header = id('qunit-header');\n      if (header) {\n        header.innerHTML = \"<a href='\" + escapeText(unfilteredUrl) + \"'>\" + header.innerHTML + '</a> ';\n      }\n    }\n    function appendBanner() {\n      var banner = id('qunit-banner');\n      if (banner) {\n        banner.className = '';\n      }\n    }\n    function appendTestResults() {\n      var tests = id('qunit-tests');\n      var result = id('qunit-testresult');\n      var controls;\n      if (result) {\n        result.parentNode.removeChild(result);\n      }\n      if (tests) {\n        tests.innerHTML = '';\n        result = document.createElement('p');\n        result.id = 'qunit-testresult';\n        result.className = 'result';\n        tests.parentNode.insertBefore(result, tests);\n        result.innerHTML = '<div id=\"qunit-testresult-display\">Running...<br />&#160;</div>' + '<div id=\"qunit-testresult-controls\"></div>' + '<div class=\"clearfix\"></div>';\n        controls = id('qunit-testresult-controls');\n      }\n      if (controls) {\n        controls.appendChild(abortTestsButton());\n      }\n    }\n    function appendFilteredTest() {\n      var testId = QUnit.config.testId;\n      if (!testId || testId.length <= 0) {\n        return '';\n      }\n      return \"<div id='qunit-filteredTest'>Rerunning selected tests: \" + escapeText(testId.join(', ')) + \" <a id='qunit-clearFilter' href='\" + escapeText(unfilteredUrl) + \"'>Run all tests</a></div>\";\n    }\n    function appendUserAgent() {\n      var userAgent = id('qunit-userAgent');\n      if (userAgent) {\n        userAgent.innerHTML = '';\n        userAgent.appendChild(document.createTextNode('QUnit ' + QUnit.version + '; ' + navigator.userAgent));\n      }\n    }\n    function appendInterface(beginDetails) {\n      var qunit = id('qunit');\n\n      // For compat with QUnit 1.2, and to support fully custom theme HTML,\n      // we will use any existing elements if no id=\"qunit\" element exists.\n      //\n      // Note that we don't fail or fallback to creating it ourselves,\n      // because not having id=\"qunit\" (and not having the below elements)\n      // simply means QUnit acts headless, allowing users to use their own\n      // reporters, or for a test runner to listen for events directly without\n      // having the HTML reporter actively render anything.\n      if (qunit) {\n        qunit.setAttribute('role', 'main');\n\n        // Since QUnit 1.3, these are created automatically if the page\n        // contains id=\"qunit\".\n        qunit.innerHTML = \"<h1 id='qunit-header'>\" + escapeText(document.title) + '</h1>' + \"<h2 id='qunit-banner'></h2>\" + \"<div id='qunit-testrunner-toolbar' role='navigation'></div>\" + appendFilteredTest() + \"<h2 id='qunit-userAgent'></h2>\" + \"<ol id='qunit-tests'></ol>\";\n      }\n      appendHeader();\n      appendBanner();\n      appendTestResults();\n      appendUserAgent();\n      appendToolbar(beginDetails);\n    }\n    function appendTest(name, testId, moduleName) {\n      var tests = id('qunit-tests');\n      if (!tests) {\n        return;\n      }\n      var title = document.createElement('strong');\n      title.className = 'qunit-test-name';\n      title.innerHTML = getNameHtml(name, moduleName);\n      var testBlock = document.createElement('li');\n      testBlock.appendChild(title);\n\n      // No ID or rerun link for \"global failure\" blocks\n      if (testId !== undefined) {\n        var rerunTrigger = document.createElement('a');\n        rerunTrigger.innerHTML = 'Rerun';\n        rerunTrigger.href = setUrl({\n          testId: testId\n        });\n        testBlock.id = 'qunit-test-output-' + testId;\n        testBlock.appendChild(rerunTrigger);\n      }\n      var assertList = document.createElement('ol');\n      assertList.className = 'qunit-assert-list';\n      testBlock.appendChild(assertList);\n      tests.appendChild(testBlock);\n      return testBlock;\n    }\n\n    // HTML Reporter initialization and load\n    QUnit.on('runStart', function (runStart) {\n      stats.defined = runStart.testCounts.total;\n    });\n    QUnit.begin(function (beginDetails) {\n      // Initialize QUnit elements\n      // This is done from begin() instead of runStart, because\n      // urlparams.js uses begin(), which we need to wait for.\n      // urlparams.js in turn uses begin() to allow plugins to\n      // add entries to QUnit.config.urlConfig, which may be done\n      // asynchronously.\n      // <https://github.com/qunitjs/qunit/issues/1657>\n      appendInterface(beginDetails);\n    });\n    function getRerunFailedHtml(failedTests) {\n      if (failedTests.length === 0) {\n        return '';\n      }\n      var href = setUrl({\n        testId: failedTests\n      });\n      return [\"<br /><a href='\" + escapeText(href) + \"'>\", failedTests.length === 1 ? 'Rerun 1 failed test' : 'Rerun ' + failedTests.length + ' failed tests', '</a>'].join('');\n    }\n    QUnit.on('runEnd', function (runEnd) {\n      var banner = id('qunit-banner');\n      var tests = id('qunit-tests');\n      var abortButton = id('qunit-abort-tests-button');\n      var assertPassed = config.stats.all - config.stats.bad;\n      var html = [runEnd.testCounts.total, ' tests completed in ', runEnd.runtime, ' milliseconds, with ', runEnd.testCounts.failed, ' failed, ', runEnd.testCounts.skipped, ' skipped, and ', runEnd.testCounts.todo, ' todo.<br />', \"<span class='passed'>\", assertPassed, \"</span> assertions of <span class='total'>\", config.stats.all, \"</span> passed, <span class='failed'>\", config.stats.bad, '</span> failed.', getRerunFailedHtml(stats.failedTests)].join('');\n      var test;\n      var assertLi;\n      var assertList;\n\n      // Update remaining tests to aborted\n      if (abortButton && abortButton.disabled) {\n        html = 'Tests aborted after ' + runEnd.runtime + ' milliseconds.';\n        for (var i = 0; i < tests.children.length; i++) {\n          test = tests.children[i];\n          if (test.className === '' || test.className === 'running') {\n            test.className = 'aborted';\n            assertList = test.getElementsByTagName('ol')[0];\n            assertLi = document.createElement('li');\n            assertLi.className = 'fail';\n            assertLi.innerHTML = 'Test aborted.';\n            assertList.appendChild(assertLi);\n          }\n        }\n      }\n      if (banner && (!abortButton || abortButton.disabled === false)) {\n        banner.className = runEnd.status === 'failed' ? 'qunit-fail' : 'qunit-pass';\n      }\n      if (abortButton) {\n        abortButton.parentNode.removeChild(abortButton);\n      }\n      if (tests) {\n        id('qunit-testresult-display').innerHTML = html;\n      }\n      if (config.altertitle && document.title) {\n        // Show  for good,  for bad suite result in title\n        // use escape sequences in case file gets loaded with non-utf-8\n        // charset\n        document.title = [runEnd.status === 'failed' ? \"\\u2716\" : \"\\u2714\", document.title.replace(/^[\\u2714\\u2716] /i, '')].join(' ');\n      }\n\n      // Scroll back to top to show results\n      if (config.scrolltop && window$1.scrollTo) {\n        window$1.scrollTo(0, 0);\n      }\n    });\n    function getNameHtml(name, module) {\n      var nameHtml = '';\n      if (module) {\n        nameHtml = \"<span class='module-name'>\" + escapeText(module) + '</span>: ';\n      }\n      nameHtml += \"<span class='test-name'>\" + escapeText(name) + '</span>';\n      return nameHtml;\n    }\n    function getProgressHtml(stats) {\n      return [stats.completed, ' / ', stats.defined, ' tests completed.<br />'].join('');\n    }\n    QUnit.testStart(function (details) {\n      var running, bad;\n      appendTest(details.name, details.testId, details.module);\n      running = id('qunit-testresult-display');\n      if (running) {\n        addClass(running, 'running');\n        bad = QUnit.config.reorder && details.previousFailure;\n        running.innerHTML = [getProgressHtml(stats), bad ? 'Rerunning previously failed test: <br />' : 'Running: ', getNameHtml(details.name, details.module), getRerunFailedHtml(stats.failedTests)].join('');\n      }\n    });\n    function stripHtml(string) {\n      // Strip tags, html entity and whitespaces\n      return string.replace(/<\\/?[^>]+(>|$)/g, '').replace(/&quot;/g, '').replace(/\\s+/g, '');\n    }\n    QUnit.log(function (details) {\n      var testItem = id('qunit-test-output-' + details.testId);\n      if (!testItem) {\n        return;\n      }\n      var message = escapeText(details.message) || (details.result ? 'okay' : 'failed');\n      message = \"<span class='test-message'>\" + message + '</span>';\n      message += \"<span class='runtime'>@ \" + details.runtime + ' ms</span>';\n      var expected;\n      var actual;\n      var diff;\n      var showDiff = false;\n\n      // When pushFailure() is called, it is implied that no expected value\n      // or diff should be shown, because both expected and actual as undefined.\n      //\n      // This must check details.expected existence. If it exists as undefined,\n      // that's a regular assertion for which to render actual/expected and a diff.\n      var showAnyValues = !details.result && (details.expected !== undefined || details.actual !== undefined);\n      if (showAnyValues) {\n        if (details.negative) {\n          expected = 'NOT ' + QUnit.dump.parse(details.expected);\n        } else {\n          expected = QUnit.dump.parse(details.expected);\n        }\n        actual = QUnit.dump.parse(details.actual);\n        message += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" + escapeText(expected) + '</pre></td></tr>';\n        if (actual !== expected) {\n          message += \"<tr class='test-actual'><th>Result: </th><td><pre>\" + escapeText(actual) + '</pre></td></tr>';\n          if (typeof details.actual === 'number' && typeof details.expected === 'number') {\n            if (!isNaN(details.actual) && !isNaN(details.expected)) {\n              showDiff = true;\n              diff = details.actual - details.expected;\n              diff = (diff > 0 ? '+' : '') + diff;\n            }\n          } else if (typeof details.actual !== 'boolean' && typeof details.expected !== 'boolean') {\n            diff = QUnit.diff(expected, actual);\n\n            // don't show diff if there is zero overlap\n            showDiff = stripHtml(diff).length !== stripHtml(expected).length + stripHtml(actual).length;\n          }\n          if (showDiff) {\n            message += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" + diff + '</pre></td></tr>';\n          }\n        } else if (expected.indexOf('[object Array]') !== -1 || expected.indexOf('[object Object]') !== -1) {\n          message += \"<tr class='test-message'><th>Message: </th><td>\" + 'Diff suppressed as the depth of object is more than current max depth (' + QUnit.dump.maxDepth + ').<p>Hint: Use <code>QUnit.dump.maxDepth</code> to ' + \" run with a higher max depth or <a href='\" + escapeText(setUrl({\n            maxDepth: 0\n          })) + \"'>\" + 'Rerun without max depth</a>.</p></td></tr>';\n        } else {\n          message += \"<tr class='test-message'><th>Message: </th><td>\" + 'Diff suppressed as the expected and actual results have an equivalent' + ' serialization</td></tr>';\n        }\n        if (details.source) {\n          message += \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText(details.source) + '</pre></td></tr>';\n        }\n        message += '</table>';\n\n        // This occurs when pushFailure is set and we have an extracted stack trace\n      } else if (!details.result && details.source) {\n        message += '<table>' + \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText(details.source) + '</pre></td></tr>' + '</table>';\n      }\n      var assertList = testItem.getElementsByTagName('ol')[0];\n      var assertLi = document.createElement('li');\n      assertLi.className = details.result ? 'pass' : 'fail';\n      assertLi.innerHTML = message;\n      assertList.appendChild(assertLi);\n    });\n    QUnit.testDone(function (details) {\n      var tests = id('qunit-tests');\n      var testItem = id('qunit-test-output-' + details.testId);\n      if (!tests || !testItem) {\n        return;\n      }\n      removeClass(testItem, 'running');\n      var status;\n      if (details.failed > 0) {\n        status = 'failed';\n      } else if (details.todo) {\n        status = 'todo';\n      } else {\n        status = details.skipped ? 'skipped' : 'passed';\n      }\n      var assertList = testItem.getElementsByTagName('ol')[0];\n      var good = details.passed;\n      var bad = details.failed;\n\n      // This test passed if it has no unexpected failed assertions\n      var testPassed = details.failed > 0 ? details.todo : !details.todo;\n      if (testPassed) {\n        // Collapse the passing tests\n        addClass(assertList, 'qunit-collapsed');\n      } else {\n        stats.failedTests.push(details.testId);\n        if (config.collapse) {\n          if (!collapseNext) {\n            // Skip collapsing the first failing test\n            collapseNext = true;\n          } else {\n            // Collapse remaining tests\n            addClass(assertList, 'qunit-collapsed');\n          }\n        }\n      }\n\n      // The testItem.firstChild is the test name\n      var testTitle = testItem.firstChild;\n      var testCounts = bad ? \"<b class='failed'>\" + bad + '</b>, ' + \"<b class='passed'>\" + good + '</b>, ' : '';\n      testTitle.innerHTML += \" <b class='counts'>(\" + testCounts + details.assertions.length + ')</b>';\n      stats.completed++;\n      if (details.skipped) {\n        testItem.className = 'skipped';\n        var skipped = document.createElement('em');\n        skipped.className = 'qunit-skipped-label';\n        skipped.innerHTML = 'skipped';\n        testItem.insertBefore(skipped, testTitle);\n      } else {\n        addEvent(testTitle, 'click', function () {\n          toggleClass(assertList, 'qunit-collapsed');\n        });\n        testItem.className = testPassed ? 'pass' : 'fail';\n        if (details.todo) {\n          var todoLabel = document.createElement('em');\n          todoLabel.className = 'qunit-todo-label';\n          todoLabel.innerHTML = 'todo';\n          testItem.className += ' todo';\n          testItem.insertBefore(todoLabel, testTitle);\n        }\n        var time = document.createElement('span');\n        time.className = 'runtime';\n        time.innerHTML = details.runtime + ' ms';\n        testItem.insertBefore(time, assertList);\n      }\n\n      // Show the source of the test when showing assertions\n      if (details.source) {\n        var sourceName = document.createElement('p');\n        sourceName.innerHTML = '<strong>Source: </strong>' + escapeText(details.source);\n        addClass(sourceName, 'qunit-source');\n        if (testPassed) {\n          addClass(sourceName, 'qunit-collapsed');\n        }\n        addEvent(testTitle, 'click', function () {\n          toggleClass(sourceName, 'qunit-collapsed');\n        });\n        testItem.appendChild(sourceName);\n      }\n      if (config.hidepassed && (status === 'passed' || details.skipped)) {\n        // use removeChild instead of remove because of support\n        hiddenTests.push(testItem);\n        tests.removeChild(testItem);\n      }\n    });\n    QUnit.on('error', function (error) {\n      var testItem = appendTest('global failure');\n      if (!testItem) {\n        // HTML Reporter is probably disabled or not yet initialized.\n        return;\n      }\n\n      // Render similar to a failed assertion (see above QUnit.log callback)\n      var message = escapeText(errorString(error));\n      message = \"<span class='test-message'>\" + message + '</span>';\n      if (error && error.stack) {\n        message += '<table>' + \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeText(error.stack) + '</pre></td></tr>' + '</table>';\n      }\n      var assertList = testItem.getElementsByTagName('ol')[0];\n      var assertLi = document.createElement('li');\n      assertLi.className = 'fail';\n      assertLi.innerHTML = message;\n      assertList.appendChild(assertLi);\n\n      // Make it visible\n      testItem.className = 'fail';\n    });\n\n    // Avoid readyState issue with phantomjs\n    // Ref: #818\n    var usingPhantom = function (p) {\n      return p && p.version && p.version.major > 0;\n    }(window$1.phantom);\n    if (usingPhantom) {\n      console$1.warn('Support for PhantomJS is deprecated and will be removed in QUnit 3.0.');\n    }\n    if (!usingPhantom && document.readyState === 'complete') {\n      QUnit.autostart();\n    } else {\n      addEvent(window$1, 'load', QUnit.autostart);\n    }\n\n    // Wrap window.onerror. We will call the original window.onerror to see if\n    // the existing handler fully handles the error; if not, we will call the\n    // QUnit.onError function.\n    var originalWindowOnError = window$1.onerror;\n\n    // Cover uncaught exceptions\n    // Returning true will suppress the default browser handler,\n    // returning false will let it run.\n    window$1.onerror = function (message, fileName, lineNumber, columnNumber, errorObj) {\n      var ret = false;\n      if (originalWindowOnError) {\n        for (var _len = arguments.length, args = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n          args[_key - 5] = arguments[_key];\n        }\n        ret = originalWindowOnError.call.apply(originalWindowOnError, [this, message, fileName, lineNumber, columnNumber, errorObj].concat(args));\n      }\n\n      // Treat return value as window.onerror itself does,\n      // Only do our handling if not suppressed.\n      if (ret !== true) {\n        // If there is a current test that sets the internal `ignoreGlobalErrors` field\n        // (such as during `assert.throws()`), then the error is ignored and native\n        // error reporting is suppressed as well. This is because in browsers, an error\n        // can sometimes end up in `window.onerror` instead of in the local try/catch.\n        // This ignoring of errors does not apply to our general onUncaughtException\n        // method, nor to our `unhandledRejection` handlers, as those are not meant\n        // to receive an \"expected\" error during `assert.throws()`.\n        if (config.current && config.current.ignoreGlobalErrors) {\n          return true;\n        }\n\n        // According to\n        // https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror,\n        // most modern browsers support an errorObj argument; use that to\n        // get a full stack trace if it's available.\n        var error = errorObj || new Error(message);\n        if (!error.stack && fileName && lineNumber) {\n          error.stack = \"\".concat(fileName, \":\").concat(lineNumber);\n        }\n        QUnit.onUncaughtException(error);\n      }\n      return ret;\n    };\n    window$1.addEventListener('unhandledrejection', function (event) {\n      QUnit.onUncaughtException(event.reason);\n    });\n  })();\n\n})();\n","/* eslint-disable array-element-newline */\nimport $ from 'jquery';\nimport QUnit from 'qunit';\nimport {getBankIndexByName, convertBanquePostale, convertBoobank, convertPaypal} from './banks.js';\nimport {initConverter, convertData, optimizeData} from './converter.js';\n\nQUnit.config.autostart = false;\n\ninitConverter(() => {\n  QUnit.start();\n});\n\nQUnit.module('Convert singles lines');\n\nQUnit.test('convertBanquePostale', assert => {\n  let line;\n  line = convertBanquePostale([\n    '25/01/2015', 'TRANSACTION', '-500,00', '',\n  ]);\n  assert.deepEqual(line, '01-25-15;;;;TRANSACTION;-500,00;;', 'Amount with a comma.');\n\n  line = convertBanquePostale([\n    '25/01/2015', 'TRANSACTION', '1000.59', '',\n  ]);\n  assert.deepEqual(line, '01-25-15;;;;TRANSACTION;1000.59;;', 'Amount with a dot.');\n});\n\nQUnit.test('convertBanquePostale - pay modes', assert => {\n  let line;\n  line = convertBanquePostale([\n    '15/12/2014', 'CHEQUE N 2224444', '-100,99', '',\n  ]);\n  assert.deepEqual(line, '12-15-14;2;;;CHEQUE N 2224444;-100,99;;', 'Cheque - CHEQUE N');\n\n  line = convertBanquePostale([\n    '11/10/2014', 'VIREMENT DE JEAN DUPONT REFERENCE : 123456789', '11,70', '85,27',\n  ]);\n  assert.deepEqual(line, '10-11-14;4;;;VIREMENT DE JEAN DUPONT REFERENCE : 123456789;11,70;;', 'Transfer - VIREMENT DE');\n\n  line = convertBanquePostale([\n    '25/10/2014', 'VIREMENT EMIS PAR JEAN DUPONT', '101,70', '85,27',\n  ]);\n  assert.deepEqual(line, '10-25-14;4;;;VIREMENT EMIS PAR JEAN DUPONT;101,70;;', 'Transfer - VIREMENT EMIS');\n\n  line = convertBanquePostale([\n    '25/10/1999', 'VIREMENT POUR BINNETTE', '45,20', '85,27',\n  ]);\n  assert.deepEqual(line, '10-25-99;4;;;VIREMENT POUR BINNETTE;45,20;;', 'Transfer - VIREMENT POUR');\n\n  line = convertBanquePostale([\n    '27/07/2013', 'ACHAT CB GEANT CASINO     26.07.13 CARTE NUMERO                XYZ  ', '-18,26', '-23,54',\n  ]);\n  assert.deepEqual(line, '07-27-13;6;;;ACHAT CB GEANT CASINO 26.07.13 CARTE NUMERO XYZ;-18,26;;', 'Debit card - ACHAT CB');\n\n  line = convertBanquePostale([\n    '27/07/2013', 'COMMISSION PAIEMENT PAR CARTE USA SELLER', '-18,26', '-23,54',\n  ]);\n  assert.deepEqual(line, '07-27-13;6;;;COMMISSION PAIEMENT PAR CARTE USA SELLER;-18,26;;', 'Debit card - COMMISSION PAIEMENT PAR CARTE');\n\n  line = convertBanquePostale([\n    '27/07/2013', 'COMMISSION RETRAIT PAR CARTE DAB PARIS FRANCE', '-18,26', '-23,54',\n  ]);\n  assert.deepEqual(line, '07-27-13;6;;;COMMISSION RETRAIT PAR CARTE DAB PARIS FRANCE;-18,26;;', 'Debit card - COMMISSION RETRAIT PAR CARTE');\n\n  line = convertBanquePostale([\n    '12/10/2014', 'CARTE X1234    12/10/14 A 12H21 RETRAIT DAB LA BANQUE POSTALE  ', '-150,00', '-700,15',\n  ]);\n  assert.deepEqual(line, '10-12-14;6;;;CARTE X1234 12/10/14 A 12H21 RETRAIT DAB LA BANQUE POSTALE;-150,00;;', 'Debit card - RETRAIT DAB');\n\n  line = convertBanquePostale([\n    '21/11/2014', 'TELEREGLEMENT DE REGLEMENT IMPOT 1234', '-253,00', '-49,12',\n  ]);\n  assert.deepEqual(line, '11-21-14;6;;;TELEREGLEMENT DE REGLEMENT IMPOT 1234;-253,00;;', 'Debit card - TELEREGLEMENT DE REGLEMENT IMPOT');\n\n  line = convertBanquePostale([\n    '21/11/2014', 'CREDIT CARTE BANCAIRE CARREFOUR', '11,59', '-49,12',\n  ]);\n  assert.deepEqual(line, '11-21-14;6;;;CREDIT CARTE BANCAIRE CARREFOUR;11,59;;', 'Debit card - CREDIT CARTE BANCAIRE');\n\n  line = convertBanquePostale([\n    '04/11/2018', 'RETRAIT THISBANK 04.11.18 EUR 20,00 CARTE NO 666', '20,00', '',\n  ]);\n  assert.deepEqual(line, '11-04-18;6;;;RETRAIT THISBANK 04.11.18 EUR 20,00 CARTE NO 666;20,00;;', 'Debit card - RETRAIT ');\n\n  line = convertBanquePostale([\n    '04/11/2018', 'COMMISSION PAIEMENT PAR CARTE 04.11.18 EUR 0,99 CARTE NO 777', '0,99', '',\n  ]);\n  assert.deepEqual(line, '11-04-18;6;;;COMMISSION PAIEMENT PAR CARTE 04.11.18 EUR 0,99 CARTE NO 777;0,99;;', 'Debit card - COMMISSION PAIEMENT PAR CARTE[space]');\n\n  line = convertBanquePostale([\n    '04/11/2018', 'COMMISSION PAIEMENT PAR CARTE', '0,99', '',\n  ]);\n  assert.deepEqual(line, '11-04-18;6;;;COMMISSION PAIEMENT PAR CARTE;0,99;;', 'Debit card - COMMISSION PAIEMENT PAR CARTE');\n\n  line = convertBanquePostale([\n    '04/11/2014', 'PRELEVEMENT DE OPERATEUR TELEPHONE MOBILE', '-10,00', '-22,44',\n  ]);\n  assert.deepEqual(line, '11-04-14;7;;;PRELEVEMENT DE OPERATEUR TELEPHONE MOBILE;-10,00;;', 'Standing order - PRELEVEMENT');\n\n  line = convertBanquePostale([\n    '18/11/2014', 'REMISE DE CHEQUE N  1114444 DE MR JEAN DUPONT', '100,00', '',\n  ]);\n  assert.deepEqual(line, '11-18-14;9;;;REMISE DE CHEQUE N 1114444 DE MR JEAN DUPONT;100,00;;', 'Deposit - REMISE DE CHEQUE N');\n\n  line = convertBanquePostale([\n    '18/11/2014', 'REMISE DE CHEQUES DE MR JEAN DUPONT', '100,00', '',\n  ]);\n  assert.deepEqual(line, '11-18-14;9;;;REMISE DE CHEQUES DE MR JEAN DUPONT;100,00;;', 'Deposit - REMISE DE CHEQUE N');\n\n  line = convertBanquePostale([\n    '18/11/2014', 'VERSEMENT EFFECTUE DE MR JEAN DUPONT', '100,00', '',\n  ]);\n  assert.deepEqual(line, '11-18-14;9;;;VERSEMENT EFFECTUE DE MR JEAN DUPONT;100,00;;', 'Deposit - REMISE DE CHEQUE N');\n\n  line = convertBanquePostale([\n    '18/11/2014', 'COTISATION TRIMESTRIELLE DE VOTRE FORMULE DE COMPTE', '1,00', '',\n  ]);\n  assert.deepEqual(line, '11-18-14;10;;;COTISATION TRIMESTRIELLE DE VOTRE FORMULE DE COMPTE;1,00;;', 'FI fee - COTISATION TRIMESTRIELLE DE VOTRE FORMULE DE COMPTE');\n});\n\nQUnit.test('convertBoobank', assert => {\n  let line;\n  line = convertBoobank([\n    '', '2014-08-29', '', '', '', '', '', 'memo1', '-11,20',\n  ]);\n  assert.deepEqual(line, '08-29-14;;;;memo1;-11,20;;', 'Amount with a comma.');\n\n  line = convertBoobank([\n    '', '2014-08-29', '', '', '', '', '', 'memo1', '12.20',\n  ]);\n  assert.deepEqual(line, '08-29-14;;;;memo1;12.20;;', 'Amount with a dot.');\n});\n\nQUnit.test('convertPaypal', assert => {\n  let line;\n  line = convertPaypal([\n    '25/01/2015', '', '', 'memo3', 'memo2', '', 'memo5', '', '', '-200,39', '', '',\n    'memo4', '', '', 'memo1', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '', '', '', '', '', '', '',\n  ]);\n  assert.deepEqual(line, '01-25-15;;;;memo1, memo2, memo3, memo4, memo5;-200,39;;', 'Amount with a comma.');\n\n  line = convertPaypal([\n    '25/01/2015', '', '', 'memo3', 'memo2', '', 'memo5', '', '', '1099.99', '', '',\n    'memo4', '', '', 'memo1', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '', '', '', '', '', '', '',\n  ]);\n  assert.deepEqual(line, '01-25-15;;;;memo1, memo2, memo3, memo4, memo5;1099.99;;', 'Amount with a dot.');\n});\n\nQUnit.module('Convert single lines with errors');\n\nQUnit.test('convertBanquePostale', assert => {\n  assert.throws(() => {\n    convertBanquePostale([\n      '25/13/2015', 'TRANSACTION', '-500,00', '',\n    ]);\n  },\n  new Error('Invalid date: 25/13/2015'),\n  'Wrong date 25/13/2015.');\n});\n\nQUnit.test('convertBoobank', assert => {\n  assert.throws(() => {\n    convertBoobank([\n      '', '2015-13-20', '', '', 'memo2', '', '', 'memo1', '-10,20',\n    ]);\n  },\n  new Error('Invalid date: 2015-13-20'),\n  'Wrong date 2015-13-20.');\n});\n\nQUnit.test('convertPaypal', assert => {\n  assert.throws(() => {\n    convertPaypal([\n      '30/13/2015', '', '', 'memo3', 'memo2', '', 'memo5', '', '', '-200,39', '', '',\n      'memo4', '', '', 'memo1', '', '', '', '', '', '', '', '', '', '', '', '', '',\n      '', '', '', '', '', '', '', '', '', '', '', '', '',\n    ]);\n  },\n  new Error('Invalid date: 30/13/2015'),\n  'Wrong date 30/13/2015.');\n});\n\nQUnit.module('Convert whole files');\n\nQUnit.test('Banque Postale - csv file', assert => {\n  const done = assert.async();\n  const inputFilename = 'banquePostale.csv';\n  const expectedFilename = 'banquePostale_converted.csv';\n  let converted;\n  let expected;\n\n  $.when(\n    $.get('data/tests/' + inputFilename, data => {\n      const index = getBankIndexByName('Banque Postale');\n      converted = convertData(index, data, inputFilename);\n    }),\n    $.get('data/tests/' + expectedFilename, data => {\n      expected = {\n        status: true,\n        data,\n        message: '',\n        errors: [],\n      };\n    }),\n  ).then(() => {\n    assert.deepEqual(converted.data.split('\\n').length, 100, 'converted.length = 100');\n    assert.deepEqual(converted.status, expected.status, 'Status is true');\n    assert.deepEqual(converted.data.replaceAll('\\r\\n', '\\n').split('\\n'), expected.data.replaceAll('\\r\\n', '\\n').split('\\n'), 'Same data');\n    assert.deepEqual(converted.message, expected.message, 'Message is empty');\n    assert.deepEqual(converted.errors, expected.errors, 'No errors');\n    done();\n  });\n});\n\nQUnit.test('Banque Postale - tsv file', assert => {\n  const done = assert.async();\n  const inputFilename = 'banquePostale.tsv';\n  const expectedFilename = 'banquePostale_converted.csv';\n  let converted;\n  let expected;\n\n  $.when(\n    $.get('data/tests/' + inputFilename, data => {\n      const index = getBankIndexByName('Banque Postale');\n      converted = convertData(index, data, inputFilename);\n    }),\n    $.get('data/tests/' + expectedFilename, data => {\n      expected = {\n        status: true,\n        data,\n        message: '',\n        errors: [],\n      };\n    }),\n  ).then(() => {\n    assert.deepEqual(converted.data.split('\\n').length, 100, 'converted.length = 100');\n    assert.deepEqual(converted.status, expected.status, 'Status is true');\n    assert.deepEqual(converted.data.replaceAll('\\r\\n', '\\n').split('\\n'), expected.data.replaceAll('\\r\\n', '\\n').split('\\n'), 'Same data');\n    assert.deepEqual(converted.message, expected.message, 'Message is empty');\n    assert.deepEqual(converted.errors, expected.errors, 'No errors');\n    done();\n  });\n});\n\nQUnit.test('BNP Paribas Fortis - csv file', assert => {\n  const done = assert.async();\n  const inputFilename = 'bnpParibasFortis.csv';\n  const expectedFilename = 'bnpParibasFortis_converted.csv';\n  let converted;\n  let expected;\n\n  $.when(\n    $.get('data/tests/' + inputFilename, data => {\n      const index = getBankIndexByName('BNP Paribas Fortis');\n      converted = convertData(index, data, inputFilename);\n    }),\n    $.get('data/tests/' + expectedFilename, data => {\n      expected = {\n        status: true,\n        data,\n        message: '',\n        errors: [],\n      };\n    }),\n  ).then(() => {\n    assert.deepEqual(converted.data.split('\\n').length, 17, 'converted.length = 17');\n    assert.deepEqual(converted.status, expected.status, 'Status is true');\n    assert.deepEqual(converted.data.replaceAll('\\r\\n', '\\n').split('\\n'), expected.data.replaceAll('\\r\\n', '\\n').split('\\n'), 'Same data');\n    assert.deepEqual(converted.message, expected.message, 'Message is empty');\n    assert.deepEqual(converted.errors, expected.errors, 'No errors');\n    done();\n  });\n});\n\nQUnit.test('Boobank - csv file', assert => {\n  const done = assert.async();\n  const inputFilename = 'boobank.csv';\n  const expectedFilename = 'boobank_converted.csv';\n  let converted;\n  let expected;\n\n  $.when(\n    $.get('data/tests/' + inputFilename, data => {\n      const index = getBankIndexByName('Boobank');\n      converted = convertData(index, data, inputFilename);\n    }),\n    $.get('data/tests/' + expectedFilename, data => {\n      expected = {\n        status: true,\n        data,\n        message: '',\n        errors: [],\n      };\n    }),\n  ).then(() => {\n    assert.deepEqual(converted.data.split('\\n').length, 50, 'converted.length = 50');\n    assert.deepEqual(converted.status, expected.status, 'Status is true');\n    assert.deepEqual(converted.data.replaceAll('\\r\\n', '\\n').split('\\n'), expected.data.replaceAll('\\r\\n', '\\n').split('\\n'), 'Same data');\n    assert.deepEqual(converted.message, expected.message, 'Message is empty');\n    assert.deepEqual(converted.errors, expected.errors, 'No errors');\n    done();\n  });\n});\n\nQUnit.test('Paypal - csv file', assert => {\n  const done = assert.async();\n  const inputFilename = 'paypal.csv';\n  const expectedFilename = 'paypal_converted.csv';\n  let converted;\n  let expected;\n\n  $.when(\n    $.get('data/tests/' + inputFilename, data => {\n      const index = getBankIndexByName('PayPal');\n      converted = convertData(index, data, inputFilename);\n    }),\n    $.get('data/tests/' + expectedFilename, data => {\n      expected = {\n        status: true,\n        data,\n        message: '',\n        errors: [],\n      };\n    }),\n  ).then(() => {\n    assert.deepEqual(converted.data.split('\\n').length, 30, 'converted.length = 30');\n    assert.deepEqual(converted.status, expected.status, 'Status is true');\n    assert.deepEqual(converted.data.replaceAll('\\r\\n', '\\n').split('\\n'), expected.data.replaceAll('\\r\\n', '\\n').split('\\n'), 'Same data');\n    assert.deepEqual(converted.message, expected.message, 'Message is empty');\n    assert.deepEqual(converted.errors, expected.errors, 'No errors');\n    done();\n  });\n});\n\nQUnit.test('Paypal - txt file', assert => {\n  const done = assert.async();\n  const inputFilename = 'paypal.txt';\n  const expectedFilename = 'paypal_converted.csv';\n  let converted;\n  let expected;\n\n  $.when(\n    $.get('data/tests/' + inputFilename, data => {\n      const index = getBankIndexByName('PayPal');\n      converted = convertData(index, data, inputFilename);\n    }),\n    $.get('data/tests/' + expectedFilename, data => {\n      expected = {\n        status: true,\n        data,\n        message: '',\n        errors: [],\n      };\n    }),\n  ).then(() => {\n    assert.deepEqual(converted.data.split('\\n').length, 30, 'converted.length = 30');\n    assert.deepEqual(converted.status, expected.status, 'Status is true');\n    assert.deepEqual(converted.data.replaceAll('\\r\\n', '\\n').split('\\n'), expected.data.replaceAll('\\r\\n', '\\n').split('\\n'), 'Same data');\n    assert.deepEqual(converted.message, expected.message, 'Message is empty');\n    assert.deepEqual(converted.errors, expected.errors, 'No errors');\n    done();\n  });\n});\n\nQUnit.module('Convert whole files with errors');\n\nQUnit.test('Banque Postale - csv file', assert => {\n  const done = assert.async();\n  const inputFilename = 'banquePostaleWithErrors.csv';\n  const expectedFilename = 'banquePostaleWithErrors_converted.csv';\n  let converted;\n  let expected;\n\n  $.when(\n    $.get('data/tests/' + inputFilename, data => {\n      const index = getBankIndexByName('Banque Postale');\n      converted = convertData(index, data, inputFilename);\n    }),\n    $.get('data/tests/' + expectedFilename, data => {\n      expected = {\n        status: true,\n        data,\n        message: '',\n        errors: [\n          'Error on line: 38. Error: Invalid date:            \"SANS DATE NI COMA    \"',\n          'Error on line: 58. Error: Line does not have enough fields. Found: 2. Minimum: 3.',\n          'Error on line: 65. Error: Line does not have enough fields. Found: 1. Minimum: 3.',\n          'Error on line: 80. Error: Invalid date:           ',\n          'Error on line: 98. Error: Invalid date: 29/02/2003',\n        ],\n      };\n    }),\n  ).then(() => {\n    assert.deepEqual(converted.data.split('\\n').length, 100, 'converted.length = 100');\n    assert.deepEqual(converted.status, expected.status, 'Status is true');\n    assert.deepEqual(converted.data.replaceAll('\\r\\n', '\\n').split('\\n'), expected.data.replaceAll('\\r\\n', '\\n').split('\\n'), 'Same data');\n    assert.deepEqual(converted.message, expected.message, 'Message is empty');\n    assert.deepEqual(converted.errors, expected.errors, 'No errors');\n    done();\n  });\n});\n\nQUnit.module('Optimize XHB');\n\nQUnit.test('Example - XHB file', assert => {\n  const done = assert.async();\n  const inputFilename = 'example.xhb';\n  const expectedFilename = 'example_optimized.xhb';\n  let optimized;\n  let expected;\n\n  $.when(\n    $.get('data/tests/' + inputFilename, data => {\n      optimized = optimizeData(data);\n    }),\n    $.get('data/tests/' + expectedFilename, data => {\n      expected = data;\n    }),\n  ).then(() => {\n    assert.deepEqual(optimized.split('\\n').length, expected.split('\\n').length, 'Same length');\n    assert.deepEqual(optimized.replaceAll('\\r\\n', '\\n').split('\\n'), expected.replaceAll('\\r\\n', '\\n').split('\\n'), 'Same data');\n    done();\n  });\n});\n"],"names":["$parcel$global","globalThis","$parcel$interopDefault","a","__esModule","default","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","_arrayLikeToArray","r","length","e","n","Array","_classCallCheck","TypeError","_defineProperties","t","o","enumerable","configurable","writable","Object","defineProperty","_toPropertyKey","i","_toPrimitive","Symbol","toPrimitive","String","Number","key","_createClass","prototype","_slicedToArray","_arrayWithHoles","isArray","_iterableToArrayLimit","l","iterator","u","f","next","done","push","value","return","_unsupportedIterableToArray","_nonIterableRest","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","from","_nonIterableSpread","_typeof","toString","slice","name","test","NO_COLOR","TERM","UMD","g","getGlobalThis","self","window$1","console$1","console","setTimeout$1","setTimeout","clearTimeout","process$1","process","window","document","navigator","localSessionStorage","x","sessionStorage","setItem","removeItem","StringMap","Map","keys","input","_this","store","create","hasOwn","hasOwnProperty","has","strKey","get","set","val","size","delete","forEach","callback","clear","StringSet","Set","values","item","add","hasOwn$1","performance","now","bind","Date","diff$1","b","filter","indexOf","inArray","includes","elem","array","objectValues","obj","allowArray","arguments","undefined","vals","is","objectValuesSubset","model","subset","extend","undefOnly","prop","objectType","match","type","isNaN","toLowerCase","generateHash","module1","testName","str","hash","charCodeAt","hex","errorString","error","resultErrorString","message","concat","escapeText","replace","s","BOXABLE_TYPES","memory","useStrictEquality","useObjectValueEquality","valueOf","getConstructor","proto","getPrototypeOf","getRegExpFlags","regexp","flags","objTypeCallbacks","null","boolean","number","string","symbol","date","nan","source","function","typeEquiv","outerEq","aVal","innerEq","bVal","originalMemory","map","aKey","bKey","entryTypeCallbacks","object","some","pair","aObjType","bObjType","compareConstructors","aProperties","bProperties","_i","sort","aType","bType","innerEquiv","res","equiv","config","altertitle","collapse","countStepsAsOne","failOnZeroTests","maxDepth","moduleId","reorder","reporters","requireExpects","scrolltop","storage","testId","urlConfig","currentModule","tests","childModules","testsRun","testsIgnored","hooks","before","beforeEach","afterEach","after","globalHooks","pq","_event_listeners","_event_memory","_deprecated_timeout_shown","_deprecated_countEachStep_shown","blocking","callbacks","modules","queue","stats","all","bad","testCount","readFlatPreconfigBoolean","dest","readFlatPreconfigNumber","readFlatPreconfigString","readFlatPreconfigStringArray","readFlatPreconfig","qunit_config_altertitle","qunit_config_autostart","qunit_config_collapse","qunit_config_failonzerotests","qunit_config_filter","qunit_config_fixture","qunit_config_hidepassed","qunit_config_maxdepth","qunit_config_module","qunit_config_moduleid","qunit_config_noglobals","qunit_config_notrycatch","qunit_config_reorder","qunit_config_requireexpects","qunit_config_scrolltop","qunit_config_seed","qunit_config_testid","qunit_config_testtimeout","reporterKeys","qunit_config_reporters_console","qunit_config_reporters_tap","env","preConfig","QUnit","version","seed","Math","random","dump","quote","literal","join","pre","arr","post","separator","inner","indent","base","stack","depth","up","ret","parse","down","reName","objType","objIndex","typeOf","parser","parsers","parserType","pop","setInterval","nodeType","multiline","HTML","extra","chr","indentChar","setParser","_error","unknown","fn","exec","nodelist","nonEnumerableProperties","_key","_key2","node","_node","open","close","tag","nodeName","attrs","attributes","nodeValue","functionArgs","args","fromCharCode","functionCode","attribute","sym","Logger","warn","Function","log","SuiteReport","parentSuite","fullName","globalFailureCount","childSuites","pushChildSuite","recordTime","_startTime","start","suite","testCounts","total","getTestCounts","_endTime","end","runtime","getRuntime","status","getStatus","round","counts","passed","failed","skipped","todo","reduce","valid","_this$getTestCounts","moduleStack","runSuite","setHookFromEnvironment","environment","potentialHook","makeSetHook","hookName","processModule","options","scope","testEnvironment","parentModule","moduleName","skip","modifiers","suiteReport","ignored","moduleFns","prevModule","cbReturnValue","then","clearSuiteReports","childSuite","splice","focused$1","module$1","modulesInQueue","only","apply","if","condition","fileName","qunitFileName","split","annotateStacktrace","formatInternal","eToString","frames","annotated","shift","initialInternal","frame","isInternal","extractStacktrace","offset","include","sourceFromStacktrace","Assert","testContext","duration","timeout","timeoutHandler","internalResetTimeout","assertionMessage","result","steps","pushResult","actualStepsClone","deepEqual","stepsCount","asserts","expected","count","requiredCalls","internalStop","actual","delta","abs","negative","currentAssert","current","assert","resultInfo","currentTest","block","_validateExpectedExce2","validateExpectedExceptionArgs","ignoreGlobalErrors","_validateException2","validateException","promise","_validateExpectedExce4","async","_validateException4","assertionMethod","expectedType","raises","SUPPORTED_EVENTS","MEMORY_EVENTS","emit","eventName","data","originalCallbacks","commonjsGlobal","promisePolyfill","globalNS","setTimeoutFunc","Boolean","noop","Promise1","_state","_handled","_value","_deferreds","doResolve","handle","self1","deferred","_immediateFn","cb","onFulfilled","onRejected","resolve","reject","newValue","finale","_unhandledRejectionFn","len","Handler","reason","ex","prom","constructor","remaining","allSettled","race","setImmediate","setImmediateFunc","_Promise","runLoggingCallbacks","promiseChain","TestReport","suiteName","assertions","pushTest","errors","getFailedAssertions","getAssertions","assertion","Test","settings","withData","pauses","nextPauseId","stackOffset","finished","method","errorForStack","validTest","testReport","pushFailure","saveGlobal","pollution","noglobals","notStartedModules","getNotStartedModules","startModule","reverse","moduleStartChain","started","previousFailure","run","notrycatch","runTest","internalRecover","resolvePromise","old","newGlobals","deletedGlobals","queueGlobalHook","hook","_this2","queueHook","hookOwner","_this3","callHook","preserveEnvironment","collectTests","taskCount","handler","processHooks","finish","stepsList","actualCountForExpect","incrementTestsIgnored","incrementTestsRun","slimAssertions","allTestsExecuted","completedModules","parent","moduleDoneChain","completedModule","nextModule","preserveTestEnvironment","previousFailCount","getItem","prioritize","details","logAssertion","pushAssertion","timeoutDuration","pauseId","pause","cancelled","testTimeout","internalStart","phase","_test","resume","moduleChainIdMatch","testModule","selectedId","selectedModule","moduleChainNameMatch","testModuleName","regexFilter","stringFilter","exclude","pattern","regex","RegExp","charAt","focused","addTest","newTest","addOnlyTest","makeEachTestName","argument","rNonObviousStr","runEach","eachFn","valueType","testKey","valueForName","advance","each","dataset","_","ConsoleReporter","runner","on","onError","onRunStart","onTestStart","onTestEnd","onRunEnd","runStart","runEnd","nativePerf","mark","measure","perf","comment","startMark","endMark","PerfReporter","onSuiteStart","onSuiteEnd","suiteStart","suiteLevel","suiteEnd","testEnd","$","enabled","reset","bold","dim","italic","underline","inverse","hidden","strikethrough","black","red","green","yellow","blue","magenta","cyan","white","gray","grey","bgBlack","bgRed","bgGreen","bgYellow","bgBlue","bgMagenta","bgCyan","bgWhite","tmp","beg","rgx","blk","txt","ctx","prettyYamlValue","isFinite","JSON","stringify","rSpecialJson","rSpecialYaml","rUntrimmed","rNumerical","rBool","_prefix","trailingLinebreakMatch","trailingLinebreaks","lines","line","_lines","prefix","decycledShallowClone","clone","ancestors","element","tap","TapReporter","ended","bailed","_runSuite","logError","severity","out","fmtStack","makeAddGlobalHook","ProcessingQueue","priorityCount","unitSampler","taskQueue","advanceTaskQueue","advanceTestQueue","processTaskQueue","elapsedTime","updateRate","task","testTasks","addToTaskQueue","tasksArray","_this$taskQueue","testTasksFunc","sample","parseInt","index","floor","onUncaughtException","DiffMatchPatch","DiffMain","text1","text2","optChecklines","deadline","commonlength","diffCommonPrefix","commonprefix","substring","diffCommonSuffix","commonsuffix","diffs","diffCompute","unshift","diffCleanupMerge","diffCleanupEfficiency","changes","equalities","equalitiesLength","lastequality","pointer","preIns","preDel","postIns","postDel","diffPrettyHtml","html","op","pointermid","pointermax","pointermin","pointerstart","min","pointerend","checklines","longtext","shorttext","hm","text1A","text2A","text1B","text2B","midCommon","diffsA","diffsB","diffHalfMatch","diffLineMode","diffBisect","dmp","hm1","hm2","diffHalfMatchI","j","bestCommon","prefixLength","suffixLength","bestLongtextA","bestLongtextB","bestShorttextA","bestShorttextB","ceil","linearray","countInsert","countDelete","textInsert","textDelete","diffLinesToChars","chars1","chars2","lineArray","diffCharsToLines","diffCleanupSemantic","text1Length","text2Length","maxD","vLength","v1","v2","front","k1start","k1end","k2start","k2end","k2Offset","k1Offset","x1","x2","y1","y2","d","k1","k2","vOffset","diffBisectSplit","y","text1a","text1b","text2a","text2b","diffsb","deletion","insertion","overlapLength1","overlapLength2","lengthInsertions1","lengthDeletions1","lengthInsertions2","lengthDeletions2","max","diffCommonOverlap","textLength","best","found","lineHash","diffLinesToCharsMunge","text","chars","lineStart","lineEnd","lineArrayLength","diffPointer","position","globalStartCalled","runStarted","isLocal","location","protocol","diff","output","events","listeners","stacktrace","lineNumber","globalStartAlreadyCalled","autostart","pageLoaded","scheduleBegin","onUnhandledRejection","_len","load","callbackNames","registerLoggingCallback","begin","unblockAndAdvanceQueue","modulesLog","totalTests","exportedModule","define","amd","fixture","getElementById","cloneNode","testStart","resetFixtureType","newFixture","createElement","setAttribute","innerHTML","parentNode","replaceChild","clonedFixture","urlParams","getUrlParams","params","search","param","decodeQueryParam","label","tooltip","option","decodeURIComponent","fuzzysort$1","isNode","MyMap","k","preparedCache","preparedSearchCache","noResults","matchesSimple","matchesStrict","cleanup","defaultScoreFn","score","getValue","segs","isObj","fastpriorityqueue","c","poll","peek","replaceTop","q","fuzzysortNew","instanceOptions","fuzzysort","single","target","indexes","getPreparedSearch","getPrepared","algorithm","allowTypo","algorithmNoTypo","go","targets","searchLowerCode","prepareSearch","threshold","limit","resultsLen","limitedCount","targetsLen","scoreFn","keysLen","objResults","keyI","_targetLowerCodes","_nextBeginningIndexes","results","goAsync","canceled","p","Promise","iCurrent","step","startMs","cancel","highlight","hOpen","hClose","highlightCallback","highlighted","matchesIndex","opened","targetLen","matchesBest","char","substr","matchI","indexesI","prepare","prepareLowerCodes","prepareSlow","prepareNextBeginningIndexes","targetPrepared","searchPrepared","searchLowerCodes","prepared","targetLowerCodes","searchLen","searchI","targetI","typoSimpleI","matchesSimpleLen","isMatch","searchLowerCodeNew","typoStrictI","successStrict","matchesStrictLen","nextBeginningIndexes","firstPossibleI","matchesBestLen","lastTargetI","strLen","lowerCodes","lower","prepareBeginningIndexes","beginningIndexes","beginningIndexesLen","wasUpper","wasAlphanum","targetCode","isUpper","isAlphanum","isBeginning","lastIsBeginning","lastIsBeginningI","new","root","failedTests","defined","completed","hiddenTests","collapseNext","unfilteredUrl","setUrl","dropdownData","beginDetails","header","banner","controls","button","userAgent","qunit","title","className","removeChild","insertBefore","appendChild","addEvent","abortTests","createTextNode","appendToolbar","toolbar","urlConfigContainer","getUrlConfigHtml","selection","urlConfigHtml","escaped","escapedTooltip","_j","addClass","addEvents","getElementsByTagName","toolbarChanged","toolbarFilters","interceptNavigation","toolbarModuleFilter","searchInputTimeout","initialSelected","selectedMap","isDirty","mod","moduleSearch","autocomplete","searchInput","searchFocus","htmlFor","textContent","searchContainer","applyButton","applyUrlParams","resetButton","clearButton","selectionChange","actions","dropDownList","dropDown","style","display","moduleFilter","hideHandler","inContainer","contains","keyCode","focus","removeEvent","filterModules","searchText","createModuleListItem","evt","checkbox","checked","toggleClass","placeholder","disabled","clearfix","assertLi","assertList","abortButton","assertPassed","getRerunFailedHtml","children","scrollTo","running","appendTest","getNameHtml","testItem","showDiff","stripHtml","testDone","removeClass","good","testPassed","testTitle","firstChild","todoLabel","time","sourceName","hidepassed","usingPhantom","phantom","major","readyState","originalWindowOnError","onerror","columnNumber","errorObj","addEventListener","event","trim","removeEventListener","elems","hasClass","force","ev","filterInputElem","preventDefault","field","selectedIndex","defaultValue","updatedUrl","history","classNameHasPass","classNameHasSkipped","_i2","replaceState","querystring","arrValue","encodeURIComponent","host","pathname","testBlock","rerunTrigger","href","nameHtml","$6KOho","$132Nu","$jkzyX","$3Bnob","initConverter","convertBanquePostale","convertBoobank","convertPaypal","throws","converted","inputFilename","when","getBankIndexByName","convertData","replaceAll","optimized","optimizeData"],"version":3,"file":"tests.4586ab75.js.map"}